# 作业25：[[计算机组成：存储器层次结构]]


## 问答题

比较下面代码的空间局部性

```c
#define N 1000

typedef struct {
	int vel[3];
	int acc[3];
} point;

point p[n]

void clear1(point *p, int n) {
	int i, j;
	for(i = 0; i < n; i++) {
		for(j = 0; j < 3; j++) {
			p[i].vel[j] = 0;
		}
		for(j = 0; j  3; j++) {
			p[i].acc[j] = 0;
		}
	}
}

void clear2(point *p, int n) {
	int i, j;
	for(i = 0; i < n; i++) {
		for(j = 0; j < 3; j++) {
			p[i].vel[j] = 0;
			p[i].acc[j] = 0;
		}
	}
}

void clear3(point *p, int n) {
	int i, j;
	for(j = 0; j < 3; j++) {
		for(i = 0; i < n; i++) {
			p[i].vel[j] = 0;
		}
		for(i = 0; i < n; i++) {
			p[i].acc[j] = 0;
		}
	}
}
```

> [!tip] 
> 
> 假设该次访问的内存是上一次访问的内存的前一个或后一个位置，就记录局部性为 `1`。否则记录局部分析为 `0`
> 

下图展示了数组 `p` 的部分内容

![Pasted image 20241028115629|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755788391549-a65822175dd04a53903bd6224036e21a.png)

对于 `clear1()` 函数，内层的两个循环，第一个循环访问 `vel[3]`，第二个循环访问 `acc[3]` 每次访问都是上次访问内存位置的下一个位置，因此内层两个循环的局部性的和为 $5$ 

对于 `clear2()` 函数，内层循环先访问 `vel[j]` 后访问 `acc[j]`；显然相邻两次内存访问的位置差为 $3$，因此局部性和记录为 $-3$

对于 `clear3()` 函数，内层的两个循环，第一个循环访问 `p[i].vel[j]`，第二个循环访问 `p[j].acc[j]`，两个内层循环每次访问的内存位置距离上一次差为 $6$，因此局部性和记录为 $-12$


---

如下假设：

+ 内存是字节寻址的
+ 内存访问的是 $1$ 字节的字（不是 $4$ 字节的字）
+ 地址的宽度为 $13$ 位
+ 高速缓存是 $2$ 路组相联的($E=2$)，块大小为 $4$ 字节($B=4$)，有 $8$ 个组( $S=8$ )

高速缓存的内容如下，所有的数字都是以十六进制来表示的

![Pasted image 20241028122344|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755788391549-4539c283da474661aeadc650c1417375.png)

指出地址中用来确定下列内容的字段：
+ 高速缓存块偏移
+ 高速缓存组索引
+ 高速缓存标记

由于每个块大小有 $4$ 个字节，由于 $4 = 2^2$，因此块偏移需要 $2$ 位；由于缓存有 $8$ 个组，由于 $6 = 2^3$，因此组索引需要 $3$ 位；标记位需要 $t = 13 - (2+3) = 8$ 位

![Pasted image 20241028153555|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755788391552-5cce2aed97cb49b7bf65ed62203c69bb.png)

---


假设一个程序运行在上面例题中的机器上，它引用地址 `0x0E34` 处的 $1$ 个字节的字。指出访问的高速缓存条目和十六进制表示的返回的高速缓存字节值。指出是否会发生缓存不命中。如果会出现缓存不命中，用 `#`  来表示 返回的高速缓存字节


地址 `0x0E34` 如下图

![Pasted image 20241028154041|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755788391553-e8d01520cabc41d9a1ad27bc33e422b4.png)

+ 块偏移为 `0x0`
+ 组索引位 `0x5`
+ 标记位 `0x71`

根据高速缓存内容，选择组 $5$，标记位为 `0x71` 的行设置了有效位，因此 **缓存命中**。从块偏移 `0x0` 处读取 $1$ 字节为 `0x0B`
 
---

地址为 `0x0DD5` 如下图

![Pasted image 20241028154524|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755788391553-f57dd816763040599fc96e922e8a15db.png)

+ 块偏移为 `0x1`
+ 组索引为 `0x5`
+ 标记位位 `0x6E`

根据高速缓存内容，选择组 $5$，标记为 `0X6E` 的行没有设置有效位，因此 **缓存不命中**


