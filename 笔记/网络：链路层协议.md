# 网络：链路层协议

对于同⼀台设备上的进程间通信，有很多种方式，比如有管道、消息队列、共享内存、信号等方式，而对于不同设备上的进程间通信，就需要 **⽹络** 通信，而设备是多样性的，所以要兼容多种多样的设备，就协商出了⼀套通用的 **⽹络协议**

> [!tip]
> 
> 网络的出现是为了提供给两个运行在不同计算机上的进程进行通信的
> 

## 互联网

**互联网**，会将不同的计算机网络连接起来并允许位于网络中的主机相互之间进行通信

> [!tip]
>互联网即 **网络的网络**，其中的一个网络称为 **子网**

下图就是一个简单的互联网

![Pasted image 20241113221403|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784213810-24cb7d9ccfff4cf9b29396ea44a9d1f8.png)


机器 `tekapo` 是一种 **路由器**，它一台 **将一个子网络连接到另一个子网络** 并在它们之间传输数据的计算机

为了使互联之间进行通信，设计出了多种互联网 **互联协议**。其中， **TCP/IP** 是使用为最广泛的 **协议套件** 

## 网络通信分层模型

### TCP/IP 模型

一个**联网协议**是 **定义如何在一个网络上传输信息的一组规则**。**联网协议** 通常会 **被组织成一系列的层**

> [!tip]
> 
> 每一层都构建于下层之上并提供特性以供上层使用
> 

**TCP/IP 协议套件** 是一个 **分层联网协议**。如下图

![Pasted image 20241113221821|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784213810-8d71a184be9d49d3b580f53ce6b89268.png)

**TCP/IP** 包括 **因特网协议(IP)** 和位于 **其上层的各个协议层**。（实现这些层的代码通常被称为协议栈。）名字 TCP/IP 是从 **_传输控制协议(TCP)_** 是使用最为广泛的传输层协议这样一个事实而得出来的

协议分层如此强大和灵活的其中一个原因是透明：**每一个协议层都对上层隐藏下层的操作和复杂性**

> [!example] 每个协议层对其上层隐藏实现细节
> 
> 如一个使用 TCP 的应用程序只需要使用标准的 socket API 并清楚自己正在使用一项可靠的字节流传输服务，而无需理解 TCP 操作的细节。应用程序也无需知道 IP 和数据链路层的操作细节
> 

### ISO/OSI 模型

**ISO/OSI 模型**（开放系统互联参考模型，Open Systems Interconnection Reference Model）是一种 **分层网络架构模型**，用于帮助理解不同网络协议和技术如何协同工作，确保跨平台和跨技术的互操作性

该模型 **将网络通信过程分为七个层次**，每一层负责不同的任务，从物理传输到应用服务。下图对比了 ISO/OSI 模型和 TCP/IP 模型

![Pasted image 20241113230034|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784213811-201677430ca04dfab0272cada5810555.png)

### 封装与解包

**封装** 是分层联网协议中的一个重要的原则，每个协议层都 **将上层数据包装为它能识别的数据**。下图给出了 TCP/IP 协议层中的封装

![Pasted image 20241116003222|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784213811-e8763cfcb063405cb26d4bb485ba04f2.png)

> [!tip] 封装：将上层协议的数据使用一个 **头** 封装为当前层可以识别的数据
> 
> 每一层都会在上层传递过来的数据前面附加上一个可以识别当前层的头
> 

> [!tip]
> 封装中的关键概念是 **低层会将从高层向低层传递的信息（如应用程序数据、TCP 段、IP 数据报）当成不透明的数据来处理**

换句话说，**低层不会尝试对高层发送过来的信息进行解释**，而只会将这些信息放到低层所使用的包中并在将这个包向下传递到低层之前 **添加自身这一层的头信息**

> [!hint] 
> 
>当数据从低层传递到高层时将会进行一个逆向的 **解包** 过程。如下图所示
>
> ![Pasted image 20241116003313|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784213812-ca1b1dc5ac42497b83599528590b603e.png)
>

后续我们将按照 TCP/IP 模型学习

## 协议

在没有约定数据如何解析之前，单纯的将数据从发送方拷贝到接收方是没有用处的

计算机之间的通信是通过 **字节序列** 进行传输，如果没有提前约定字节序列的解析方式，接收方可能按照任意方式解析它收到的数据。因此，在通信前需要提前约定字节序列的解析方式，从而确保接收双方看到的数据是一样的

这种发送方和接收方 **提前约定好的数据解析方式** 称为 **协议**

> [!tip] 协议：通信双方提前约定好的数据解析方式

### 网络数据流

下图展示了通过 TCP/IP 协议进行的分层 **逻辑通信** 和 **数据流动**

![Pasted image 20241114003826|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784213812-5d11456996fb41c689eb9c1bbaaacbdf.png)

主机 $A$ 将应用层数据传递给传输层(TCP/UDP协议)，并在应用层数据的头部附加上 **TCP/UDP 头**。然后，传输层协数据传递给网络层(IP以恶)，并在传输层数据头部附加上 **IP 头**。最后，网络层数据传递给数据链路层，并在网络层数据头部附加上 **MAC 头**和尾部附加上 **FCS**

主机 $B$ 在数据链路层收到主机 $A$ 传递过来的数据，去除数据链路层识别的附加信息并将剩余信息传递给网络层。然后，网络层并去除识别的附加信息并传递给传输层。最后，传输层去除识别的附加信息并传递给应用层


通过上面描述，我们发送两个主机之间 **相同层次的数据是一样的**。当我们考虑主机 $A$ 和主机 $B$ 之间的通信时，我们只考虑同等层次的协议即可

> [!tip] 
> 
> 每个层次只需要考虑自己应该实现的，而不需要关心下层实现。也就是说，后续介绍的 **协议都只属于它所在的层次**
> 

### 常见协议

常见协议的公开协议可以在 [RFC-editor](https://www.rfc-editor.org/) 查看。下表列出 TCP/IP 模型中涉及的各层协议

| 层次    | 协议                                      |
| :---- | --------------------------------------- |
| 应用层   | **https 协议**，ftp 协议，ssh 协议，POP3/SMTP 协议 |
| 传输层   | **TCP 协议**，**UDP 协议**，SCTP 协议           |
| 网络层   | **IP 协议**，ICMP 协议，IGMP 协议               |
| 数据链路层 | **ARP 协议**                              |

表中加粗的协议后续我们会重点介绍

### 地址

在 TCP/IP 协议栈中，需要使用到 $3$ 种地址：**端口** **IP地址** 和 **MAC地址**

#### 端口

当消息到达主机之后，**如何确定消息是发送给那个进程的呢？** 就像存储单元的地址一样，可以 **给系统中的进程编号**，这个编号称为 **端口号**，简称 **端口**。

> [!tip] 端口号：主机上的某个进程的编号，它是一个 $16$ 位无符号整数。取值范围为 $0 \sim 65535$ 

有些 **众所周知的端口号** 已经被永久地分配给特定的应用程序。下表列出了几个常见的

|   端口号   | 应用程序              |
| :-----: | :---------------- |
|  $21$   | `FTP` 文件传输服务      |
|  $22$   | `ssh` 安全的 `shell` |
|  $23$   | `TELNET` 终端仿真服务   |
|  $25$   | `SMTP` 简单邮件传输服务   |
|  $53$   | `DNS` 域名解析服务      |
| $67,68$ | `DHCP` 服务器和客户端    |
|  $80$   | `HTTP` Web服务器     |
|  $443$  | `HTTPS` Web服务器    |

#### IP 地址

消息发送到网络后，**如何确定消息发送给那个主机呢？** 类似的，也可以对网络中的设备进行编号，这个编号称为 **IP 地址**

> [!tip] IP 地址：网络中的某个主机的编号
> 
> IPv4 协议使用 $32$ 位的整数对网络中的主机进行编号。为了让人类可读，通常采用 **点分十进制标记法**：即将地址的 **每个 _字节_ 都写成一个十进制数字**，中间 **以点号隔开**，如 `204.152.189.116`
> 
> IPv6 协议使用 $128$ 位的整数对网络中的主机进行编号。为了人类可读，通常采用 **冒号分隔的 $16$ 位十六进制数字表示**，例如 `F000:0:0:0:0:0:A:1` 
> 
> IPv6 地址通常包含一个 $0$ 序列，并且为了标记方便，可以使用两个冒号(`::`)来表示这种序列。因此上面的地址可以被重写成 `F000::A1`
> 

#### MAC 地址

消息到达局域网之后，**如何确定消息是发送给局域网中的哪个设备呢？** 在局域网中，标识网络设备的是 **MAC 地址**(Media Access Control Address)，也称为局域网地址，它是一个用来**确认网络设备位置的地址**

> [!tip] MAC 地址：确认网络设备位置的地址，采用 $48$ 位($6$ 字节)表示
> 
> 第一个字节的低第一位表示这个 MAC 地址是 **单播** 地址($0$)还是 **多播** 地址($1$)
> 
> 第一个字节的低第二位表示这个 MAC 地址是全局地址($0$)还是本地地址($0$)
> 
> 下图给出了 MAC 地址的结构
> 
> ![Pasted image 20241115223730|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784213813-a20ffdb62b7b4c5884e090f68425b5b1.png)
> 

## 数据链路层协议

### 以太网标准

以太网是最常用的数据链路层标准之一，它于$1980$ 年由 DEC、Intel 和 Xerox 首次发布，并随后略加修订被 IEEE 采纳为 802.3 标准。

早期以太网的结构通常是共享的：**多个主机共享一个网络介质传播数据**，如果多个主机同时发送数据，则需要采用一些算法来 **避免碰撞**

![Pasted image 20241116103153|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784213814-139a5e786fb84c239f7dccdbce4133d7.png)

> [!tip] 带冲突检测的载波侦听多路访问(CSMA/CD)
> 
> 由于多个计算机共享同一网络，该标准需要再每个以太网接口实现一种分布式算法，以控制一个计算机发送自己的数据
> 
> 协调哪些计算机可以访问介质，同时不需要其他特殊协议或者同步
> 

采用 CSMA/CD，任何给定的时间内，网络中只有一个 **帧** 传输。计算机首先检测目前网络上是否正在发送信号，并 **在网络空闲时发送自己的帧**。

> [!hint] 
> 
> 如果其他计算机碰巧同时发送信号，发生重叠的电信号被检测为一次碰撞。在这种情况下，每个计算机等待一个 **随机时间**，然后再次尝试发送
> 
> 随机时间的选着依据统一的概率分布，随后每个碰撞被检测到时间长度加倍。最终每个计算机都有机会发送数据，或者尝试一定次数后超时(传统以太网尝试次数为 $16$)
> 

CSMA/CD 这样的访问方法更正式的名称为 **介质控制访问(MAC)协议**。MAC 协议有很多类型，有些基于每个计算机尝试独立使用网络，有些基于预先安排的协调

随着网络速度不断提升，基于竞争的 MAC 协议逐渐被取代。局域网中每个计算机共享以太网逐渐被一个 **星形拓扑接口** 的网络取代了：主机通过一条独享的网线和 **交换机** 连接，由交换机负责在为每个主机提供全双工通信。


![Pasted image 20241116105054|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784213815-0f93c1094e7b4a0fb31a2c2c615f3246.png)

交换以太网中包含多个计算机，每个计算机使用一条专用的线路连接到一个交换机 **端口**。大多数情况下，交换机以 **全双工** 方式运行，并且不需要使用 CSMA/CD 算法。交换机可以通过交换机端口级联形成更大的以太网，该端口称为 **上行端口**

> [!tip] 交换机通过 **端口** 与交换以太网中的计算机链接，并通过 **上行端口** 与其他交换机链接

现如今最流行的无线网络是 **无线局域网(WLAN)**。IEEE 标准为 802.11。虽然标准不同，但是帧格式和通用接口大部分来自 802.3，并且都是 IEEE 802 局域网标准的一部分

> [!hint] 
> 
> TCP/P 用于以太网的大部分功能，也可用于 WI-FI 网络
> 

### 以太网帧格式

所有的以太网帧都基于一个共同的格式。如下图，显示了当前的以 **太网帧** 格式，以及它与 IEEE 提出的一个相对新的术语 **IEEE 分组** 的关系

![Pasted image 20241116113017|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784213816-656eb1795fa743bab19687bcd9f20959.png)

> [!tip] 前导字段：接收器电路用它确定一个帧的到达时间，并确定编码位之间的时间量
> 
> 以太网是一个异步的网络（即每个以太网接口卡中不保持精确的时钟同步），从一个接口到另一个接口的编码位之间的间隔可能不同
> 
> 前导是一个公认的模式，典型值为 $0xAA$。在发现 **帧起始分隔符(SFD)** 时，接收器使用它 **恢复时钟**
>
 
> [!tip] SFD：帧起始分隔符
> 
> SFD 的典型值为 $0XAB$
> 

#### 目的地址和源地址

基本的帧格式包括 $48$ 位($6$ 字节)的 **目的地址** 和 **源地址**，这些地址有时也称为 **MAC 地址**

> [!tip] MAC 地址的别称
> + 链路层地址
> + 802 地址
> + 硬件地址
> + 物理地址

以太网的目的地址也允许 **寻址到多台设备**，称为 **广播** 或 **组播**。广播用于 ARP 协议，组播用于 ICMPv6 协议，以实现 **网络层地址(IP 地址)** 和 **链路层地址(MAC 地址)** 之间的映射

#### 类型字段或长度字段

源地址后面紧跟着一个 **类型字段** 或一个 **长度字段**。在多数情况下，**用于确定头部后面的数据类型**

> [!tip] TCP/IP 网络使用的类型值
> + IPv4：$\text{0x0800}$
> + IPv6：$\text{0x86DD}$
> + ARP：$\text{0x0806}$
>   
> $\text{0x8100}$ 表示一个 Q标签帧，可以携带一个虚拟局域网或 8021.1Q 标准的 VLAN ID

一个以太网帧的基本大小是 $1518$ 字节，但最近的标准将该值扩大到 $2000$ 字节

> [!attention] 
> 
> 最初的 IEEE 802.3 标准将 类型/长度字段作为长度字段使用。这字段被 **重载**。关键是看字段值
> + 字段值大于或等于 $1536$，则该字段表示类型，由标准分配的超过 $1536$ 的值
> + 字段值小于或等于 $1500$，则该字段表示长度
> 

#### 标签字段

在类型字段或长度字段之后，IEEE 802.3-2008 提供了多种标签包含其他 IEEE 标准定义的各种协议字段。最常见的就是有 IEEE 802.1p 和 IEEE 802.1q 使用的标签，它提供虚拟局域网和一些服务质量(QoS) 指示符

> [!attention] 
> 
> 当前的 IEEE 802.3-2008 标准采用修改后的 802.3 帧格式，提供了最大为 $482$ 字节的标签，它携带在每个以太网帧中
> 
> 有些较大的帧称为信封帧，长度可能达到 $2000$ 字节。包含 802.1p/q 标签的帧称为 Q标签帧，也是信封帧
> 
> 注意，并非所有的信封帧都是 Q 标签帧
> 

#### 有效载荷

在上述字段之后，是帧的数据区或 **有效载荷** 部分。这里存储高层 **协议数据单元(Protocol Data Unit, PDU)** 的地方

传统上，以太网的有效载荷一直是 $1500$ 字节，它代表以太网的 **最大传输单元(Maximum Transmission Unit, MTU)**。

目前，大多数系统以以太网使用的 $1500$ 字节的 MTU，虽然在必要时它也可以设置为一个较小的值。有效载荷有时被填充为 $0$，以确保帧的总体长度符合最小长度要求

#### 帧校验序列

在以太网帧格式中，有效载荷区域之后的最后字段提供了对帧完整性的检查。采用 **循环冗余校验(CRC)** 字段附加在有效载荷最后，有 $32$ 位，有时称为 IEEE/ANSI 标准的 **CRC32**

> [!tip]  CRC 检验步骤：要使用一个 $n$ 位 CRC 检测数据传输错误，就需要执行如下步骤
> 
> 第一步：首先，在被检查消息中追加 $n$ 位 $0$ 形成一个扩展消息
> 
> 第二步：然后，扩展消息(使用模 $2$ 除法)除以一个 $(n+1)$ 位的值，这个作为除数的值称为生成多项式
> 
> 第三步：最后，将第二步中的余数的二进制反码(商被丢弃)放置在消息的 CRC 字段
> 

生成多项式已经被标准化为一系列不同的 $n$ 值。以太网使用 $n=32$，CRC32 的生成多项式值的二进制数为 $100000100110000010001110110110111_2$

为了理解如何使用($\mod 2$)**二进制除法** 计算余数，下面图展示了 CRC4 的简答例子。CRC4 的生成多项式的标准化值为 $10011_2$。如果我们要发送 $16$ 位的消息 $1001111000101111_2$。首先，将发送的消息追加 $4$ 个 $0$ 形成扩展消息 $10011110001011110000_2$。然后，执行二进制除法，如下图所示

![Pasted image 20241117093825|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784213819-0cf13fbf1b274896ad262fcad600e67d.png)

这个除法的余数为 $1111_2$，将余数的反码 $0000$ 放置在帧的 CRC 或者 FCS(帧校验序列) 字段中。

> [!tip] 帧校验过程：在接收到该数据之后，接收方执行相同的除法计算出余数，并判断该值与 FCS 字段的值是否匹配
> + 如果两者不匹配，帧可能在传输过程中受损，通常被丢弃
> 

>[!attention] CRC 功能可用于提示信息受损，位模式的任何改变极有可能导致余数的改变

### 帧大小

以太网帧有最小和最大尺寸。**最小的帧是 $64$ 字节**，要求有效载荷长度最小为 $48$ 字节。当有效载荷较小时，填充 $0$ 到有效载荷尾部，以确保最小长度

 除了有效数据的 $48$ 字节，剩余 $16$ 字节分别包含了 CRC32($4$ 字节校验序列) 和 $12$ 字节的源地址和目标地址
 
> [!hint] 
> 
> 最小尺寸的帧中不包含标签字段
> 

传统的以太网的 **最大帧是 $1518$ 字节**，有效载荷为 $1500$ 字节，源地址和目标地址为 $12$ 字节，类型和长度占 $2$ 字节，FCS 字段占 $4$ 字节

> [!tip] 最大帧包含 $1500$ 字节的载荷，$14$ 字节的头部和 $4$ 字节的 FCS

> [!important] 
> 
> 选择 $1518$ 字节作为最大帧的原因：如果发现一个帧错误时，只需要重传 $\text{1.5 KB}$  以修复该问题
> 

MTU 大小限制为 $1500$ 字节，为了发送一个更大的消息，则需要多个帧。对于 TCP/IP 网络中较大尺寸 $\text{64 KB}$，需要至少 $44$ 个帧

---
由于多个以太网帧构成一个更大的上层 PDU，**每个帧都贡献了一个固定的开销**。更糟糕的是，为了允许以太网硬件接收电路正确恢复来自网络的数据，并为其他设备提供将字节流量于已有流量区分开的机会，**以太网帧在网络中不能无缝地压缩在一起**

Ethernet Ⅱ  规范在帧的开始处定义了 **$7$ 字节的前导 和 $1$ 字节的 SFD**，以及 $12$ 字节的 **包间距时间**

> [!tip] 包间距时间
> 
> + $\text{10 Mb/s}$ 为 $\text{9.6 us}$
> + $\text{100 Mb/s}$ 为 $\text{960 ns}$
> + $\text{1000 Mb/s}$ 为 $\text{96 ns}$
> + $\text{10000 Mb/s}$ 为 $\text{9.6 ns}$
> 

### 地址解析协议 ARP

> [!tip] 从一台主机向另一台主机传递帧需要两个地址: **网络层地址** 和 **硬件地址**
> 
> 一个传统 IPv4 网络需要使用自己的地址：$32$ 位的 IPv4 地址。如果一台主机要将一个帧发送给另一台主机，仅知道这台主机的 IP 地址是不够的，还需要知道主机在网络中的有效硬件地址
> 

**以太网驱动程序必须知道目的主机的硬件地址，以便直接向它发送数据**。对于 TCP/IP 网络，**地址解析协议(ARP)** 提供了一种在 IPv4 地址和各种网络技术使用的硬件地址之间的映射

> [!warning] **ARP 仅用于 IPv4**，IPv6 使用邻居发现协议，它被合并入 ICMPv6
> 

---

这里需要注意的是，网络层地址和链路层地址是由不同部门分配的

> [!tip] 链路层地址：由设备制造商定义
> 
> 链路层地址存储在设备的永久性内存中，所以链路层地址是不变的
> 

由于 **链路层地址不变**，工作在特定硬件技术上的任意协议族，必须利用特定类型的地址。这 **允许不同协议族中网络层协议同时运行**

> [!tip] 网络层地址：IP 地址是由用户或网络管理员分配，并且可以按需选择
> 
> 为便携设备分配的 IP 地址可能改变。IP 地址通常从附近的网络连接点的地址池中获得，它在系统启用或配置时分配
> 

当两个局域网的主机之间传输的 **以太网帧包含 IP 数据报** 时，由 $48$ 位以太网地址确定该帧的目的网络接口卡(简称，网卡)

地址解析是发现 **IP 地址** 和 **MAC 地址** 之间的映射关系的过程。对于 TCP/IP 协议族，地址解析由 ARP 实现。ARP 是一个通用的协议，支持多种地址之间的映射。实际上，**ARP 几乎总是用于 $32$ 位 IPv4 地址和以太网 $48$ 位 MAC 地址之间的映射**

> [!important] ARP 提供了从网络层地址到相关硬件地址的 **动态** 映射
> 
> 所谓动态映射是因为 ARP 会自动执行和随时间变化，而不需要系统管理员重新配置
> 
> 也就是说，如果一台主机 **更换了网卡**，从而改变了它的硬件地址，但 **保留其分配的 IP 地址**，ARP 可以 **在一定延时后继续正常运转**
> 

#### ARP 查询工作流程

当使用 Internet 服务时，本地计算机必须确定如何与相关的服务器联系。首先，判断该服务器位于 **本地** 还是 **远程**

> [!tip] 本地：同一 IP 子网的一部分

如果是远程的，需要一台可达目的地的路由器。因为，**仅在位于同一 IP 子网的系统时，ARP 才能工作**。

> [!tip] ARP 查询的工作流程：链路层发送广播帧被所有主机接收；IP 地址匹配的主机返回响应；IP 地址不配的主机丢弃该广播帧
> 
> 以太网主机位于 **同一广播域** 中，ARP 查询使用链路层 **广播帧** 发送，并被所有主机接收。IP 地址匹配的主机向请求主机返回响应。IP 地址不匹配的主机丢弃 ARP 查询>
> 

下图展示了 ARP 请求和应答的过程

![Pasted image 20241117211517|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784213821-6a3a31abf2164505bcc4cf7f87d9b264.png)

#### ARP 帧格式

下图显示了在以太网中转换一个 IPv4 地址时常用的 APR 请求和应当分组的格式

![Pasted image 20241117205227|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784213821-c058eb8a7ef647818258eb4e1797c9e7.png)

前 $14$ 字节是标准以太网帧头部，其余部分由 ARP 协议定义。前 $8$ 字节是通用的，剩余部分专门用于将 IPv4 地址映射到 $48$ 位的以太网地址

> [!tip] 以太网帧头部：目的和源字段，以及长度或类型字段
> 
> 对于 ARP 请求，**目的**以太网地址是 **广播地址**，即 `ff:ff:ff:ff:ff:ff`。在同一广播域中的所有以太网接口可接收这些帧
> 
> 在 ARP 请求中，$2$ 字节的长度和类型字段必须是 $0x0806$
> 

> [!tip] ARP 请求或应答消息前 $4$ 个字段：它们指定了最后 $4$ 个字段的类型和大小
> 
> + 硬件类型：指出硬件地址类型。对于以太网，该值为 $1$
> + 协议类型：指出映射的协议地址类型。对于 IPv4 地址，该值为 $0x0800$。当以太网帧包含 IPv4 数据报时，可能与以太网帧的类型字段一致
> + 硬件大小：硬件地址的字节数
> + 协议大小：协议地址的字节数
> 

> [!tip] Op 字段：指出该操作是 ARP 请求还是 ARP 应答
> + ARP 请求的值为 $1$
> + ARP 请求的值为 $2$
> 
> 由于 ARP 请求和 ARP 应答的长度类型字段相同，因此该字段是必须的
> 

> [!tip] ARP 请求或应答消息后 $4$ 个字段：它们给出了请求或应答的具体内容
> 
> + 发送方硬件地址：以太网 MAC 地址
> 
> + 发送方协议地址：IPv4 地址
> 
> + 目的硬件地址：MAC 地址
> 
> + 目的协议地址：IPv4 地址
> 
> 这里存在一些重复信息：以太网头部和 ARP 消息都包含发送方硬件地址
> 
> 对于一个 ARP 请求，目的硬件地址设为 $0$，其他地址都需要填充。当一个系统接收到 ARP 请求，它填充自己的硬件地址，将两个发送方地址和两个接收方地址互换，将 Op 字段设置为 $2$，然后发送生成的应答
> 

#### 使用 wireshark 抓包分析 ARP 请求

下图展示了当前计算机分配到的网络连接属性

![Pasted image 20241117213529|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784213824-027628b8a1ac4b47a0579471e96a68f1.png)

在 Windows 上，命令 `arp -a` 用于显示当前计算机中保存的 ARP 缓存

![Pasted image 20241117213658|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784213825-25169b997a0744fd94c9fd5894aea366.png)

现在，使用 wireshark 抓取 ARP 协议的请求和响应。首先，打开 wireshark；然后清空当前计算机中的 ARP 缓存。这样就可以抓取 ARP 请求和响应了

![Pasted image 20241117214039|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784213826-0e66b3966958472f9c0849d8d86fd7e4.png)

首先，我们查看 **ARP 请求**，即目的地为 Broadcast 的包

![Pasted image 20241117214707|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784213826-79585f2b904445089b778d0b9bcbfbb1.png)

> [!tip] 
> 
> ARP 请求中的目的 MAC 地址全是 $1$，即 **广播地址**
> 

然后，我们查看 **ARP 响应**，即目的地址为 `Intel_86:be:9c` 的包

![Pasted image 20241117215229|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784213827-537aec7d288341b48572d7dd1002dc39.png)

> [!important] 对比 ARP 请求和响应包，响应方向请求包中添加自己的硬件地址，然后互换两个发送方地址和目的地址，从而创建应答包

