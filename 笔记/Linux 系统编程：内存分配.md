# 内存分配

许多系统程序需要为动态数据结构分配额外内存，此类数据结构的大小由运行时所获取的信息决定

## 在堆上分配内存

进程可以通过增加堆的大小来分配内存，所谓堆是一段长度可变的连续虚拟内存，始于进程的未初始化数据段末尾，随着内存的分配和释放而增减。如下图，通常将堆的当前内存边界称为 **program break**

![[Pasted image 20241013130418.png]]

### 调整 program break

改变堆的大小（即分配或释放内存），其实就像命令内核改变进程的 program break 位置一样简单。**最初，program break 正好位于未初始化数据段末尾之后**（如上图，与 `&end`  位置相同）

在 program break 的位置抬升后，程序可以访问新分配区域内的任何内存地址，而此时物理内存页尚未分配

> [!tip] 
> 
> **内核会在进程首次试图访问这些虚拟内存地址时自动分配新的物理内存页**
> 

传统的 UNIX 系统提供了两个 **操纵 program break 的系统调用**：`brk()` 和 `sbrk()`，在 Linux 中依然可用。虽然代码中很少直接使用这些系统调用，但了解它们有助于弄清内存分配的工作过程

```c
#include <unistd.h>

int brk(void *end_data_segment);
/* 成功返回 0；错误返回 -1 */
```

系统调用 `brk()` 会将 `program break` 设置为参数 `end_data_segment` 所指定的位置

> [!tip] 
> 
> 虚拟内存以页为单位进行分配，`end_data_segment` 实际会 **四舍五入到下一个内存页的边界处**
> 

> [!warning] 
> 
> 当试图将 `program break` 设置为一个低于其初始值（即低于`&end`）的位置时，有可能会导致无法预知的行为
> 
> 当程序试图访问的数据位于初始化或未初始化数据段中当前尚不存在的部分时，就会引发 **分段内存访问错误：段错误**
> 

`program break` 可以设定的精确上限取决于一系列因素，这包括进程中对数据段大小的资源限制(`RLIMIT_DATA`)，以及内存映射、共享内存段、共享库的位置

```c
#include <unistd.h>

void *sbrk(intptr_t increment);
/* 成功返回前一个 program break；失败返回 (void *) -1 */
```

系统调用 `sbrk()` 将 `program break` 在原有地址上增加从参数 `increment` 传入的大小。在 Linux 中，`sbrk()` 是在 `brk()`基础上实现的一个库函数

> [!tip] 参数 `increment`：该参数的类型是 `intptr_t` 类型，属于整数数据类型
> 

> [!tip]  返回值
> 
> 成功返回前一个 `program break` 的地址
> 
> 失败返回 `(void *) -1`
> 

调用 `sbrk(0)` 将返回 `program break` 的当前位置，对其不做改变。在意图跟踪堆的大小，或是监视内存分配函数包的行为时，可能会用到这一用法

### malloc 和 free

一般情况下，C 程序使用 `malloc()` 函数族在堆上分配内存，使用 `free()` 释放内存。详细参考 [[C 语言：指针高级#动态内存分配]]

下面我们探究 `malloc()` 和 `free()` 的实现，在 [[作业22：内存分配]] 中将简单实现这两个函数。

`malloc()` 的实现很简单。它首先会扫描之前由 `free()` 所释放的 **空闲内存块列表**，以求找到尺寸大于或等于要求的一块空闲内存

> [!tip] 扫描 `free()` 的空闲内存块列表，找到尺寸大于或等于 `malloc()` 要求的空闲内存
> 
> 如果这一内存块的 **尺寸正好与要求相当**，就把它直接返回给调用者
> 
> 如果是一块 **较大的内存**，那么将对其 **进行分割**，在将一块大小相当的内存返回给调用者的同时，把较小的那块空闲内存块保留在 **空闲列表** 中
> 
> 
> 

如果在空闲内存列表中根本找不到足够大的空闲内存块，那么 `malloc()` 会调用 `sbrk()` 以分配更多的内存

> [!tip] `free()` 的空闲内存块中没有合适的尺寸，调用 `sbrk()` 分配更多的内存
> 
> 为减少对 `sbrk()` 的调用次数，`malloc()` 并未只是严格按所需字节数来分配内存，而是以更大幅度（以虚拟内存页大小的数倍）来增加 `program break`，并将超出部分置于空闲内存列表
> 

当 `free()` 将内存块置于空闲列表之上时，是如何知晓内存块大小的？这是通过一个小技巧来实现的。**当 `malloc()` 分配内存块时，会额外分配几个字节来存放记录这块内存大小的整数值**。该整数位于内存块的起始处，而实际返回给调用者的内存地址恰好位于这一长度记录字节之后

![[Pasted image 20241023193720.png]]

当将内存块置于空闲内存列表（双向链表）时，`free()` 会使用内存块本身的空间来存放链表指针，将自身添加到列表中

![[Pasted image 20241023193822.png]]

随着对内存不断地释放和重新分配，空闲列表中的空闲内存会和已分配的在用内存混杂在一起

![[Pasted image 20241023193909.png]]

C 语言允许程序创建指向堆中任意位置的指针，并修改其指向的数据，包括由 `free()` 和 `malloc()` 函数维护的内存块长度、指向前一空闲块和后一空闲块的指针。这将导致很多编程错误

> [!example] 
> 
> 假设经由一个错误指针，**程序无意间增加了一块已分配内存的长度值**，并随即释放这块内存，`free()` 因之会在空闲列表中记录下这块长度失真的内存。随后，`malloc()` 也许会重新分配这块内存，从而导致如下场景：程序的两个指针分别指向两块它认为互不相干的已分配内存，但实际上这两块内存却相互重叠
> 

为了避免上述错误，应该遵守下列规则

> [!tip] 
> 
> 分配一块内存后，应当小心谨慎，**不要改变这块内存范围外的任何内容**。错误的指针运算，或者循环更新内存块内容时出现的 “off-by-one”（一字之偏）错误，都有可能导致这一情况
> 
> **释放同一块已分配内存超过一次是错误的**。Linux 上的 `glibc` 库经常报出分段错误（`SIGSEGV` 信号）。这是好事，因为它提醒我们犯下了一个编程错误。然而，当两次释放同一块内存时，更常见的后果是导致不可预知的行为。
> 
> **`free()` 只能释放有 `malloc()` 函数族分配的内存**。若非经由 `malloc` 函数包中函数所返回的指针，绝不能在调用 `free()` 函数时使用
> 
> 在编写需要 **长时间运行的程序**（例如，shell 或网络守护进程）时，出于各种目的，如果需要反复分配内存，那么 **应当确保释放所有已使用完毕的内存**。如若不然，堆将稳步增长，直至抵达可用虚拟内存的上限，在此之后分配内存的任何尝试都将以失败告终。这种情况被称之为 **“内存泄漏”**
> 

## 在栈上分配内存

和 `malloc` 函数包中的函数功能一样，`alloca()` 也可以动态分配内存，不过不是从堆上分配内存，而是通过 **增加栈帧的大小从栈上分配**

根据定义，当前调用函数的栈帧位于栈的顶部，故而这种方法是可行的。因此，帧的上方存在扩展空间，只需修改堆栈指针值即可

```c
#include <alloca.h>

void *alloca(size_t size);
/* 返回指向分配块的指针 */
```

> [!tip] 参数 `size`：指定在栈上分配的字节数


> [!tip] 返回值：
> 
> 函数 `alloca()` 将指向已分配内存块的指针作为其返回值
> 

> [!warning] 
> 
> 不要使用 `free()` 来释放 `alloca()` 分配的内存。也不能使用 `realloc()` 来调整 `alloca()` 分配的内存大小
> 
