# 基本概念

1989 年圣诞节期间，荷兰人 Guido van Rossum 为了打发无聊时间决定开发一种全新的解释性脚本语言。他希望这门新语言具有简单易用的特性。

在 1991 年初发布了第一个公开发行版。由于他非常喜欢 BBC 喜剧 `《Monty Python’s Flying Circus》`，因此给这门新语言取名 Python

目前 Python 已经成为科学计算、运维领域等最主要的编程语言，拥有非常便捷的开发库

## Python 解释器

Python 是一门解释型的语言，当我们写好一个 `.py` 文件后，需要经过解释器的编译生成 Python 字节码，解释器最终执行的是这些编译生成的字节码

Python 有许多版本的解释器，如下表所示。其中，使用最广泛的还是 CPython 解释器，它是 Python 官方推荐的解释器，使用 C 语言开发

| 解释器         | 描述                                               |
| :---------- | ------------------------------------------------ |
| **CPython** | 官方提供的解释器，使用 C 语言开发。目前使用最广泛的解释器                   |
| IPython     | 交互式的 Python 解释器，本质上就是对 CPython 的功能进行增强           |
| PyPy        | 使用 Python 编写的 Python 解释器。通过 JIT 技术动态编译 Python 源码 |
| Jython      | 运行在 JVM 上的 Python 解释器，将 Python 字节码翻译为 Java 字节码   |
| IronPython  | 运行在 .NET 平台上的解释器                                 |
| stackless   | 不使用 CPython 的栈，采用微线程(协程)概念编程                     |

## 注释

注释用于解释说明代码，提供程序可读性。在编写程序时，我们应该尽量的书写注释。方便后续维护我们的代码

Python 中的注释有多种。这里我们首先介绍 **行注释**。

```python
# 这是一条行注释
```

使用 `#` 开头，随后直到遇见换行符之前都是属于注释内容，Python 解释器会忽略 `#` 及其之后的一行内容

此外 Python 还支持 **文档注释**，不过这个注释会被 Python 解释器读取，存放在对象的 `__doc__` 属性中

## 数字

Python 解释器内建的数字类型包括 **整数(int)** **浮点数(float)** **复数(complex)**。下面我们分别介绍这 $3$ 种数字类型

### 整数

与 C/C++ 不同的时，Python 中整数不区分尺寸也不区分有符号和无符号数。在 Python 中，整数采用统一的 **补码编码** 的方式存储，并且不限制整数对象占用的内存大小

> [!tip] 
> 
> 换句话说，就是 Python 中的整数大小取决于 Python 解释器运行机器的内存大小
> 

在 Python 中，创建一个整数对象可以直接使用 **整数字面值**，Python 解释器读取到整数字面值时，就会创建一个整数对象并使用字面值初始化它。Python 支持 $4$ 种整数字面值的形式：**十进制** **十六进制** **八进制** 和 **二进制**

Python 官方文档 [整数字面值](https://docs.python.org/zh-cn/3.13/reference/lexical_analysis.html#integer-literals) 给出了上述 $4$ 中形式的词法规则

```python
# 整数字面值有 4 种：十进制字面值 二进制字面值  八进制字面值  十六进制字面值
integer      ::= decinteger | bininteger | octinteger | hexinteger

# 十进制字面值的定义：非零数字开头，随后是至少出现 0 次 "_数字" 的组合；或者 "0" 开头，随后至少出现 0 次 "_0" 的组合。其中 _ 可以省略
decinteger   ::= nonzerodigit (["_"] digit)* | "0"+ (["_"] "0")* 

# 二进制字面值的定义：以 0 开头，随后是 b 或 B，之后至少出现 1 次 "_二进制数" 的组合。其中 _ 可以省略
bininteger   ::= "0" ("b" | "B") (["_"] bindigit)+

# 八进制字面值的定义：以 0 开头，随后是 o 或 O，之后至少出现 1 次 "_八进制数" 的组合。其中 _ 可以省略
octinteger   ::= "0" ("o" | "O") (["_"] octdigit)+

# 十六进制字面值的定义：以 0 开头，随后是 x 或 X，之后至少出现 1 次 "_十六进制数" 的组合。其中 _ 可以省略
hexinteger   ::= "0" ("x" | "X") (["_"] hexdigit)+


# 非零数字：包含 1 2 3 4 5 6 7 8 9 
nonzerodigit ::= "1"..."9"
# 数字：包含 0 1 2 3 4 5 6 7 8 9 
digit        ::= "0"..."9"
# 二进制数字：只有 0 或 1
bindigit     ::= "0" | "1"
# 八进制数字：包含 0 1 2 3 4 5 6 7
octdigit     ::= "0"..."7"
# 十六进制数字：包含 数字 和 Aa Bb Cc Dd Ee Ff
hexdigit     ::= digit | "a"..."f" | "A"..."F"
```

> [!tip] 
> 
> 整数字面值没有长度限制。在确定数值时，会忽略字面值中的下划线(`_`)。下划线只是为了分组数字，让数字更易读
> 
> 注意：除了 0 以外，十进制数字的开头不允许有零。
> 

下面给出了一些合法的整数字面值

```python
7     2147483647                        0o177    0b100110111
3     79228162514264337593543950336     0o377    0xdeadbeef
      100_000_000_000                   0b_1110_0101
```

#### bool 类型

Python 中的 bool 类型是 int 类型的一个子类型。只有两种取值：`True` 或 `False`。

```python
>>> int(True), int(False)
(1, 0)
```

> [!tip] 
> 
> `True` 默认就是 `int` 类型的 $1$；`False` 默认就是 `int` 类型的 $0$
> 

### 浮点数

Python 中的浮点数本质上就是 C/C++ 中的 `double` 类型，采用 **IEEE 754 双精度浮点格式** 存储。也就是说 Python 中浮点数的绝对值最大值约为 $1.797693 \times 10^{308}$，超过这个数字的浮点数都是 `inf`

在 Python 中，创建一个浮点数对象可以使用 **浮点数字面值**。Python 提供了 $2$ 种浮点数字面值格式。它们的词法规则定义如下

```python
# 浮点数字面值：    浮点形式      指数形式
floatnumber   ::= pointfloat | exponentfloat

# 浮点数形式定义：可选的整数部分，随后是分数部分；或者整数部分，随后是一个小数点
pointfloat    ::= [digitpart] fraction | digitpart "."

# 指数形式定义：整数或者浮点数形式，随后是指数
exponentfloat ::= (digitpart | pointfloat) exponent

# 整数部分：任意数字，随后是至少 0 次 "_数字" 的组合
digitpart     ::= digit (["_"] digit)*

# 分数部分：小数点开头，随后是整数分别
fraction      ::= "." digitpart

# 指数部分定义：e或E，随后是可选的 + 或 -，随后是整数部分
exponent      ::= ("e" | "E") ["+" | "-"] digitpart
```

> [!attention] 
> 
> 注意，浮点数字面值在解析时，整数和指数部分总以 $10$ 为基数。 
> 
> + 例如，`077e010` 是合法的，表示的数值与 `77e10` 相同。
> 
> 浮点数字面值的支持范围取决于具体实现。 整数字面值支持用下划线分组数字。
> 

下面是一些合法的浮点数字面值

```python
3.14    10.    .001    1e100    3.14e-10    0e0    3.14_15_93
```

### 复数

Python 内置支持了复数类型。其虚数部分的字面值如下

```python
imagnumber ::= (floatnumber | digitpart) ("j" | "J")
```

> [!tip] 
> 
> 虚数字面值生成实部为 $0.0$ 的复数。 复数由一对浮点数表示，它们的取值范围相同。 
> 
> 创建实部不为零的复数，则需添加浮点数，例如 `(3+4j)`
> 

虚数字面值示例如下:

```python
3.14j   10.j    10j     .001j   1e100j   3.14e-10j   3.14_15_93j
```

### 其他数字类型

Python 通过标准包的形式提供了其他类型的数字。例如， [`Decimal`](https://docs.python.org/zh-cn/3.13/library/decimal.html#decimal.Decimal "decimal.Decimal") 或 [`Fraction`](https://docs.python.org/zh-cn/3.13/library/fractions.html#fractions.Fraction "fractions.Fraction")

## 变量

在 C/C++ 中，必须声明一个变量，然后初始化这个变量。那么如何在 Python 程序中创建一个变量呢？

> [!tip] 
> 
> Python 中的变量与 C/C++ 完全不同，这是因为 Python 的内存管理方式带来的差异。现在，我们只需要知道直接对一个变量 **赋值** 就可以定义一个变量即可
> 
> 与 C/C++ 一样，Python 使用赋值运算符(`=`) 给一个变量赋值
> 

```python
m = 28  # 创建一个整数对象，其值为 20
```

当 Python 解释器语句这样的语句之后，就会新建一个整数对象，并让标识符 `m` 指向该对象。变量 `m` 类似于 C/C++ 中的指针，它指向了一个对象所在的内存空间。下图展示了这种关系

![Pasted image 20250322184027|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755785888325-c0cf182c54e2482dbe0eccb3b146a4d3.png)

与 C/C++ 不同的时，这个变量 `m` 可以指向另一个类型的对象。换句话说，Python 中的变量是无类型的

```python
m = 3.14
```

此时，内存关系图如下

![Pasted image 20250322194326|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755785888325-7859046a65654eba82b3e541bcb6cd05.png)

> [!tip] 
> 
> Python 中的变量就像贴纸一样，可以贴在任意类型的对象之上
> 

### 动态语言

到此我们发现了 Python 与 C/C++ 的一个巨大差异。Python 中的变量不像 C/C++ 那样是确定类型的。只有当 Python 解释器执行到赋值这一条语句时，才会确定变量的类型。

> [!tip] 
> 
> 这种在执行过程中才确定变量类型的语言称为 **动态语言**。而 C/C++ 这种确定变量类型的语言称为 **静态语言**
> 
> 动态语言的优势就是非常灵活，但是灵活的代价就是容易出错。而静态语言可以在程序执行前作静态检查，尽量将错误在执行前排除，从而提高程序的执行效率
> 

在 Python 我们可以使用 `type()` 函数获取一个对象的类型

```python
>>> type(1.1)
<class 'float'>
>>> type(1)
<class 'int'>
```

### 标识符的命名规范

上述中出现的 `m` 就是一个标识符，指代了一个对象。当我们使用标识符 `m` 的时候就是使用 `m` 指向的对象。这个概念就与 C++ 的引用非常相似。我们在程序中给一个标识符命名时需要遵循一些 **规则** 和 **规范**

> [!tip] 
> 
> 规则：就不能违背的原则，必须按照这样的规范命名
> + 不能以数字打头
> + 必须由 Unicode 字符组成，通常使用 ASCII 码表示的字符
> + 额外还可以使用下划线(`_`)
> + 标识符不能是 Python 的关键字：例如，不能是 `def` `class` 等被 Python 语言保留使用的名字
> 
> 规范：程序开发中要求的，这是可选的
> + 不允许使用中文，也不建议使用拼音
> + 不要使用有歧义的单词：例如 `class_`
> + 不要随便使用下划线开头的标识符
> + 不要使用 Python 预定义的名字(内置函数或类型) 的名字
> 

### 关键字和预定义标识符

下表列出了 Python 语言中的所有关键字，共计 $35$ 个：这些关键字一定不能用作标识符

| 描述     | 列1       | 列2         | 列3        | 列4         | 列5       |
| :----- | :------- | ---------- | --------- | ---------- | -------- |
| 布尔值和空值 | `False`  | `None`     | `True`    |            |          |
| 逻辑运算符  | `and`    | `or`       | `not`     | `is`       |          |
| 条件语句   | `if`     | `elif`     | `else`    |            |          |
| 循环控制   | `for`    | `while`    | `break`   | `continue` |          |
| 函数定义   | `def`    | `return`   | `lambda`  |            |          |
| 异常处理   | `try`    | `except`   | `finally` | `rais`     | `assert` |
| 类与面向对象 | `class`  | `pass`     |           |            |          |
| 变量作用域  | `global` | `nonlocal` |           |            |          |
| 模块导入   | `import` | `from`     | `as`      |            |          |
| 上下文管理  | `with`   |            |           |            |          |
| 删除对象   | `del`    |            |           |            |          |
| 模式匹配   | `match`  | `case`     |           |            |          |
| 异步编程   | `async`  | `await`    |           |            |          |

下表列出来 Python 中内置函数，共计 $69$ 个：尽量不要使用这些名字作为标识符

| 列1           | 列2            | 列3             | 列4              | 列5               |
| :----------- | ------------- | -------------- | --------------- | ---------------- |
| `bool()`     | `int()`       | `float()`      | `complex()`     | `str`            |
| `bytes()`    | `bytearray()` | `memoryview()` | `list()`        | `tuple()`        |
| `set()`      | `frozenset()` | `dict()`       |                 |                  |
|              |               |                |                 |                  |
| `print()`    | `input()`     | `open()`       |                 |                  |
|              |               |                |                 |                  |
| `abs()`      | `pow()`       | `round()`      | `divmod()`      | `sum()`          |
| `min()`      | `max()`       |                |                 |                  |
|              |               |                |                 |                  |
| `len()`      | `sorted()`    | `enumerate()`  | `reversed()`    | `zip()`          |
| `map()`      | `filter()`    | `all()`        | `any()`         |                  |
|              |               |                |                 |                  |
| `id()`       | `type()`      | `isinstance()` | `issubclass()`  | `hash()`         |
| `callable()` | `dir()`       | `vars()`       |                 |                  |
|              |               |                |                 |                  |
| `globals()`  | `locals()`    | `eval()`       | `exec()`        | `compile()`      |
|              |               |                |                 |                  |
| `help()`     | `super()`     | `object()`     | `classmethod()` | `staticmethod()` |
| `property()` | `delattr()`   | `getattr()`    | `setattr()`     | `hasattr()`      |
|              |               |                |                 |                  |
| `ascii()`    | `bin()`       | `oct()`        | `hex()`         | `format()`       |
| `chr()`      | `ord()`       |                |                 |                  |

> [!tip] 
> 
> 这些内置函数在后续的学习过程中都会接触到
> 

## 字符串

除了数字外，Python 还可以操作文本，由 `str` 类型表示，称为 **字符串**。字符串用成对的单引号(`'....'`) 或双引号(`"...."`) 来标示，它们的结果完全相同

> [!attention] 
> 
> 请注意：Python 中没有字符类型，哪怕是像 `'a'` `'!'` 这种只有一个字符的使用单引号标示的也是字符串
> 

```python
>>> 'spam eggs'  # 单引号
'spam eggs'
>>> "Paris rabbit got your back :)! Yay!"  # 双引号
'Paris rabbit got your back :)! Yay!'
>>> '1975'  # 用引号括起来的数字也是字符串
'1975'
```

如果字符串本身中需要包含引号，那么我们需要对它进行 **转义**，即在前面加上一个反斜线 `\`。或者使用不同类型的引号

```python
>>> 'doesn\'t'  # 使用 \' 来转义单引号...
"doesn't"
>>> "doesn't"  # ...或者改用双引号
"doesn't"
>>> '"Yes," they said.' 
'"Yes," they said.'
>>> "\"Yes,\" they said."
'"Yes," they said.'
>>> '"Isn\'t," they said.'
'"Isn\'t," they said.'
```

在 Python shell 中，字符串定义和输出看起来可能不同。使用内置函数 `print()`，它会忽略标示用的引号，并打印经过转义的特殊字符，产生更易读的输出

```python
>>> s = 'First line.\nSecond line.'  # \n 表示换行符
>>> s  # 不用 print()，特殊字符将包括在字符串中
'First line.\nSecond line.'
>>> print(s)  # 用 print()，特殊字符会被转写，因此 \n 将产生一个新行
First line.
Second line.
```

如果不希望前置 `\` 的字符转义成特殊字符，可以使用 _原始字符串_，在引号前添加 `r` 即可：

```python
>>> print('C:\some\name')  # 这里 \n 表示换行符！
C:\some
ame
>>> print(r'C:\some\name')  # 请注意引号前的 r
C:\some\name
```

> [!tip] 
> 
> 前缀 `r` 表示 `raw`，即裸的，原始的。这字符串中的所有字符都仅仅是字符，没有特殊函数
> 
> 请注意：原始字符串中不能以 `\` 字符结束
> 

```python
>>> r"hello\"
  File "<python-input-5>", line 1
    r"hello\"
    ^
SyntaxError: unterminated string literal (detected at line 1); perhaps you escaped the end quote?
```

## 缩进与续行

与 C/C++ 不同的是，**Python 使用缩进表示一个代码块**。例如

```python
a = input("输入一个字符")
if a == "a":
	print(a)  # 这是一个全新的代码块
```

> [!tip] 
> 
> 一般约定使用 $4$ 个空格作为缩进。请注意，在 Python 程序中，缩进要么使用空格，要么使用 `tab`，禁止两者混用
> 

---
有时候，一个表达式很长，导致一行容纳不下，我们可以使用续行符将相邻的物理行视为同一个逻辑行

```python
a = "hello, "\
"world"
print(a)  # "hello, world"
```

> [!attention] 
> 
> 请注意：对于很长的表达式需要拆分到多行书写的，通常使用一对圆括号 `()`，在圆括号内的将视为同一行
> 

## 进制与整数编码

> [!seealso] 
> 
> 关于进制的详细内容请参考 [[计算机组成：数字系统]]
> 

在 Python 中，我们可以使用内置函数 `bin()` `oct()` `hex()` 获得一个整数的二进制、八进制和十六进制表示的字符串。注意，返回的字符串符合整数的字面值词法规则

```python
>>> a = 1024
>>> bin(a)
'0b10000000000'
>>> oct(a)
'0o2000'
>>> hex(a)
'0x400'
```

> [!seealso] 
> 
> 关于整数编码详细内容请参考
> + [[计算机组成：数据存储#存储整数]]
> + [[计算机组成：整数的表示与运算]]
> 

请注意，Python 中的整数只采用 **补码编码**。补码编码的规则就是最高位的权重为 $(-1)^{b_n} \times 2^{n-1}$。换句话说，就是最高位被置为 $1$ 时，表示负数

## 逻辑值检测

Python 中任何对象都可以进行逻辑值检测，以便于在 `if` 和 `while` 语句中作为条件使用或者作为逻辑运算符的操作数使用

下表列出了逻辑值等价于 `False` 的内置类型对象

|       描述        |                 对象/常量                  |
| :-------------: | :------------------------------------: |
| 被定义为`Fasle` 的常量 |             `None`，`False`             |
|                 |                                        |
|     数值类型的零      |        整数 `0`，浮点数 `0.0`，虚数 `0j`        |
|     数值类型的零      |     `Decimal(0)`, `Fraction(0, 1)`     |
|                 |                                        |
|      空的序列       | `""` 空字符串，`[]` 空列表，`()` 空元组，`range(0)` |
|                 |                                        |
|      空多项集       |  `{}` 空字典，`set()`  `frozenset()` 空集合   |

## 运算符

下面我们介绍 Python 中的运算符：**算术运算符** **位运算符** **比较运算符** **逻辑运算符** **赋值运算符**

### 算术运算符

Python 提供的算术运算符包括
+ 加法(`+`) 
+ 减法(`-`) 
+ 乘法(`*`)
+ 真实除法(`/`) 
+ floor 除法(`//`) 
+ 取模(`%`)
+ 幂运算符(`**` 和 `pow()`) 
+ `divmod(a, b)`：返回 `(a // b, a % b)`
·
> [!tip] 
> 
> 真实除法运算符(`/`) 始终返回浮点数，而 floor 除法运算符(`//`) 返回的是真实除法的向下取整。然而，`//` 返回不一定是 `int` 类型，还需要根据其操作数的类型确定
> 

```python
>>> 2 / 5
0.4
>>> 2 // 5.0  # 返回的是浮点数类型
0.0
>>> 2 // 5  # 返回整数类型
0
```

> [!tip] 
>`remander = dividend % divisor`。最终是根据 `remainder(余数) = dividend(被除数) - quotient(商) * divisor(除数)` 计算得到。
> 
> 由于 `quotient = dividend // divisor` 是采用向下取整的。也就是说，最终余数的结果为 `remainder = dividend - (dividend // divisor) * divisor`
> 

```python
>>> 7 % 2  # 返回 1 : 7 - (7 // 2) * 2
1
>>> 7 % -2  # 返回 -1: 7 - (7 // -2) * (-2)
-1
>>> -7 % 2  # 返回 1: -7 -(-7 // 2) * 2
1
>>> -7 % -2  # 返回 -1: -7 - (-7 // -2) * (-2)
-1
```

> [!summary] 
> 
> 也就说，取模运算符 `%` 的返回值的符号与右操作数相同
>

> [!attention] 
> 
> 请注意：除了复数类型外，其他数字类型都支持上述运算符
> 

### 位运算符

Python 提供了与 C/C++ 相同的位运算符，它们的运算方式也是相同的。

> [!seealso] 
> 
> [[C 语言：基本概念#位运算符]]
> 

> [!attention] 
> 
> 在 Python 中，移位运算符执行的是 **算术移位**
> + 参考 [[计算机组成：数据运算#算术移位运算]]
> 

位或(`|`): 只要有一位为 $1$，那么结果就是 $1$（**有 $1$ 则为 $1$**）

```python
a = 0b10001
b = 0b01010

print(a | b)  # 0b11011 ==> 27
```

 位与(`&`) : 两个位都为 $1$，那么结果才是 $1$(**同为 $1$ 才是 $1$**)
 
```python
a = 0b10001
b = 0b01010

print(a & b)  # 0b00000 ==> 0
```

 异或 `^` : 两个位相同，那么结果就是 $0$(**不同为 $1$**)

```python
a = 0b10001
b = 0b01010

print(a ^ b)  # 0b11011 ==> 27
```

按位取反 `~` : $0$ 变 $1$，$1$ 变 $0$

```python
a = 0b10001
"""
python 中整数的长度是无限的，并采用补码表示

a = 0b10001 ==> 0000..000|10001 
~a = 1111..111|01110 ==> -18
"""
print(~a)  # 101110 ==> -18
```

 左移 `<<` : 将一个数的二进制码向左移动指定的位数。`x << n` 等价 `x * 2 ** n`
 
```python
a = 0b10001
"""
a = 0b10001 => 2^5 + 1 = 32 + 1 = 33
a << 2 = 0b1000100 => 2^6 + 2^2 = 64 + 4 = 68
"""
print(a << 2)  # 0b1000100 ==> 40
```

右移 `>>` : 将一个数的二进制码向右移动指定的位数。`x >> n` 等价于 `x // 2 ** n`

```python
a = 0b10001
"""
a = 0b10001 => 2^5 + 1 = 32 + 1 = 33
a >> 2 = 0b00100 => 2^2 = 4
"""
print(a >> 2)  # 0b00100 ==> 4
```

### 比较运算符

下表列出了 Python 提供了 $8$ 中比较运算符，它们具有相同的优先级，并且高于逻辑运算符的优先级

| 运算符      | 含义       |
| :------- | :------- |
| `<`      | 严格小于     |
| `<=`     | 小于或等于    |
| `>`      | 严格大于     |
| `>=`     | 大于或等于    |
| `==`     | 等于       |
| `!=`     | 不等于      |
| `is`     | 对象标识是否相等 |
| `is not` | 对象标识是否不等 |

需要注意：除了不同的数字类型外，其他不同类型的对象时不能进行比较的

```python
>>> [1,2,3] < (1,2,4)
Traceback (most recent call last):
  File "<python-input-23>", line 1, in <module>
    [1,2,3] < (1,2,4)
TypeError: '<' not supported between instances of 'list' and 'tuple'
```

比较运算符 `==` 总是定义良好的。如果对象为提供 `__eq__()` 方法，那么比较运算符 `==` 与 `is` 等价的。本质上就是比较两个对象是否是同一个对象

```python
>>> [1,2,3] == (1,2,4)
False
```

此外，Python 还有两个运算符 `in` 和 `not in`，它们用于判断某个对象是否是容器中的元素

```python
>>> 'a' in "hello"
False
>>> 'e' in "hello"
True
```

> [!tip] 
> 
> `in` 和 `not in` 的优先级与比较运算符相同
> 

与 C/C++ 不同的是，Python 的比较运算符符合数学定义的，即支持连续比较。例如， `x < y < z` 这种连续的比较等价于 `x < y and y < z` 的。

> [!attention] 
> 
> `x < y < z` 与 `x < y and y < z` 是等价的。唯一的区别就是 `x < y < z` 中，`y` 只会求值一次。而在 `x < y and y < z` 中，`y` 会求值两次
> 

### 逻辑运算符

逻辑运算是每种语言都必须支持的运算，Python 中的逻辑运算符以关键字的形式出现

+ `not` 逻辑非：对逻辑值取反。即 `not False` 的值是 `True`，`not True` 的值是 `False`
+ `and` 逻辑与：要求两个逻辑值同时为 `True` 时， `and` 才返回 `True`
+ `or` 逻辑或：要求两个逻辑值只要出现 `True`，`or` 就返回 `True`

显然，`and` 和 `or` 有 **短路** 的特性。Python 在执行 `and` 或 `or` 构成的表达式时，从左到右依次检查操作数的逻辑值，只要遇见能够确定整个 `and` 或 `or` 表达式的操作数的值时就立即返回确定整个表达式的操作数

```python
>>> 1 and 0 and 2  # 遇见 0 时就确定了 and 表达式的值，此时返回 0
0
>>> [1] or 0  # 遇见 [1] 时就确定 or 表达式的值，此时返回的是 [1]
[1]
```

> [!attention] 
> 
> 请注意，Python 中的 `and` 和 `or` 返回不是 `bool` 类型，而是确定整个表达式值的操作数
> 

### 赋值运算符

Python 和其他语言一样使用 `=` 给变量赋值。请注意：在 Python 中赋值是语句而不是表达式。在 Python 中的连续赋值与 C/C++ 中是不同的

```python
>>> a = b = c = 10  # 等价于三条赋值语句：分别给变量 a b c 赋值
>>> 
>>> a = b = (c = 10)  # 语法错误
  File "<python-input-35>", line 1
    a = b = (c = 10)  # 语法错误
             ^^^^^^
SyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?
```

和 C/C++ 一样，Python 允许将算术运算符和赋值运算符组合成 **增强赋值运算符**

| 运算符         | 结果                  |
| :---------- | :------------------ |
| `x += y`    | 等价于 `x = x + y`     |
| `x -= y`    | 等价于 `x = x - y`     |
| `x *= y`    | 等价于 `x = x * y`     |
| `x /= y`    | 等价于 `x = x / y`     |
| `x //= y`   | 等价于 `x = x // y`    |
| `x **= y`   | 等价于 `x = x ** y`    |
| x $\mid$= y | 等价于 x = x $\mid$  y |
| `x &= y`    | 等价于 `x = x & y`     |
| `x ^= y`    | 等价于 `x = x ^ y`     |
| `x <<= n`   | 等价于 `x = x << n`    |
| `x >>= n`   | 等价于 `x = x >> n`    |

### 运算符的优先级

探究运算符的优先级是很有必要的。理解运算符的优先级有助于我们写出间接的代码

下表对 Python 中运算符的优先顺序进行了总结，从最高优先级到最低优先级进行排序。 相同单元格内的运算符具有相同优先级。 除非语法显式地指明，否则运算符均为双目运算符。 相同单元格内的运算符从左至右组合的（只有 **幂运算符是从右至左组合的**）。

| 运算符                                                     | 描述              |
| :------------------------------------------------------ | --------------- |
| `(expr...)` `[expr...]` `{key:value ...}` `{expr...}`   | 最高的优先级，显示创建对象   |
| `x[i]` `x[i:j]` `func()` `obj.attr`                     | 索引和切片 函数调用 属性引用 |
| `await x`                                               | 等待可等待对象         |
| `**`                                                    | 幂运算             |
| `+x` `-x` `~x`                                          | 一元正负号，按位取反      |
| `*` `@` `/` `//` `%`                                    | 乘法和除法           |
| `+` `-`                                                 | 加法和减法           |
| `<<` `>>`                                               | 左移和右移           |
| `&`                                                     | 位与              |
| `^`                                                     | 异或              |
| $\mid$                                                  | 位或              |
| `in` `not in` `is` `is not` `<` `<=` `>` `>=` `!=` `==` | 比较运算符           |
| `not x`                                                 | 逻辑非             |
| `and`                                                   | 逻辑与             |
| `or`                                                    | 逻辑或             |
| `expr1 if expr2 else expr3`                             | 条件表达式           |
| `lambda`                                                | 匿名函数            |
| `:=`                                                    | 海象运算符           |

## 类型转换

将一种数据类型的值转换为另一种数据类型的值的过程称为类型转换。Python 支持两种形式的类型转换： **隐式类型转换** 和 **显式类型转换**

### 隐式类型转换

在执行算术运算时，Python 要求两个操作数的类型必须相同。然而，我们可以很自然的写出一个整数与一个浮点数的算术运算表达式

```python
>>> 2 + 1.14
3.1399999999999997
>>> 3.0 + 3j
(3+3j)
```

当一个表达式中既有整数又有浮点数时，**Python 会隐式的将整数类型的对象转换为浮点数类型的对象**。将整数类型的值转换为浮点数类型的值可以避免数据丢失

> [!attention] 
> 
> 由于 Python 中的整数可以非常大，然而浮点数确有限制。当整数超出浮点数能够表示的范围时，可能会出现程序异常
> 

```python
>>> 99999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999 + 1.0

Traceback (most recent call last):
  File "<python-input-46>", line 1, in <module>
  ...
OverflowError: int too large to convert to float
```

### 显示类型转换

某些对象是不能进行隐式类型转换为其他类型的对象的。比如，字符串类型的对象想要转换为整数或浮点数，就必须使用显示类型转换

> [!tip] 
> 
> Python 中，将字符串或浮点数转换为整数需要使用内置函数 `int()`
> 

如果 `int()` 接收到的参数是一个浮点数，那么 `int()` 将使用浮点数的整数部分创建一个 `int` 类型的对象

```python
>>> int(4.13)
4
```

如果 `int()` 接收到的参数是一个字符串，那么 `int()` 就使用字符串构造一个 `int` 类型的对象，其值是字符串表示的整数字面值

```python
>>> int("          1010")  # 跳过空白符
1010
>>> int("-1010")
-1010
>>> int("a1010")  # 不符合十进制整数的字面值形式，从而导致转换失败
Traceback (most recent call last):
  File "<python-input-52>", line 1, in <module>
    int("a1010")
    ~~~^^^^^^^^^
ValueError: invalid literal for int() with base 10: 'a1010'
>>> int("a1010", base=16)  # 字符串符合十六进制的整数字面值形式
659472
```

> [!attention] 
> 
> `int()` 默认使用 **十进制*** 解析字符串并构造一个整数对象。如果字符串不符合 Python 中十进制整数字面值的词法将解析失败
> 
> 可通过 `base` 参数指定 `int()` 函数按照 `base` 进制解析字符串
> 

---

> [!tip] 
> 
> 在 Python 中，将字符串或整数转换为浮点数使用函数 `float()`
> 

```python
>>> float(10)
10.0
>>> float("1e2")
100.0
>>> float("4.3")
4.3
>>> float("inf")
inf
>>> float("NAN")
nan
```

> [!attention] 
> 
> `float()` 接收到字符串参数时，会安装 Python 中的浮点数字面值的方式构建一个 `float` 类型的对象。
> 
> 此外，可以使用 `"inf"` 表示无穷大，和 `"NaN"` 表示这不是一个数字
> 

---

> [!tip] 
> 
> 在 Python 中将其他类型转为字符串类型使用函数 `str()`。本质上 `str()` 获得的是对象的字符串表示，即 `print()` 输出的对象的形式
> 

```python
>>> str(90.123)
'90.123'
>>> str(9e10)
'90000000000.0'
>>> str(10)
'10'
```

将整数转换为字符串还可以使用 `bin()` `oct()` `hex()` 这三个内置函数

## 内置函数

Python 解释器内置了许多函数，下面我们复习之前已经学过的内置函数

| 函数                                | 描述                   |
| :-------------------------------- | :------------------- |
| `print(*args, sep=' ', end='\n')` | 输出 `args` 中对象的字符串表示  |
| `pow(x, y, z)`                    | 等价于 `x ** y % z`     |
| `divmod(x, y)`                    | 返回 `(x // y, x % y)` |
| `bin()` `oct()` `hex()`           | 返回整数二进制 八进制 十六进制字符串  |
| `bool()`                          | 返回对象等价的布尔值           |
| `int()`                           | 返回 `int` 类型的对象       |
| `float()`                         | 返回 `float` 类型的对象     |
| `complex()`                       | 返回 `complex` 类型的对象   |
| `str()`                           | 返回 `str` 类型的对象       |
| `type()`                          | 获取对象所属的类型            |

由于在 Python 中，变量的类型是动态确定的，在对变量执行操作之前通常需要检查变量的类型。内置函数 `isinstance(obj, type)` 提供检查变量类型的能力，它用于检测 `obj` 对象是否是 `type` 类型的实例。

```python
>>> isinstance(True, int)  # 由于 bool 类型是 int 的子类型，因此 bool 对象就是 int 类型的实例
True
>>> isinstance(1, str)
False
>>> isinstance(1, (str, bool, list, int))  # 判断对象是否是一组类型中之一的对象
True
```

与计算机交互的时候我们可能需要从计算机外部输入数据，Python 中的内置函数 `input(prompt)` 用于从标准输入中 **读取一行字符**，并返回字符串

```python
>>> x = input("输入数据: ")
输入数据: 123
>>> type(x)
<class 'str'>
```

> [!tip] 
> 
> `input(prompt)` 首先将 `prompt` 参数的值写入到标准输出，然后从标准输入读取一行字符
> 

在处理数字时，通常我们需要执行 **舍入** 操作。Python 提供的多种舍入操作：向下取整(`//` 或者 `math.floor()`)，向上取整(`math.ceil()`)，截断(`int()`)，`round()`。

```python
>>> round(0.1), round(0.6), round(1.2), round(1.7), round(2.3),round(2.8)
(0, 1, 1, 2, 2, 3)
>>> round(1.5)
2
>>> round(2.5)
2
>>> round(-2.5)
-2
>>> round(4.5)
4
```

> [!tip] 
> 
> `round()` 执行的舍入规则为：四舍六入五凑偶。
> + 被保留数字的后一位如果小于 $5$ 则舍去
> + 被保留数字的后一位如果大于 $5$ 则进位
> + 被保留数字的后一位如果等于 $5$ 则根据被保留数字是否位偶数决定是否进位
> 	+ 如果被保留数字为偶数，则舍去
> 	+ 如果被保留数字为奇数，则进位
> 

有时候，我们需要从一组对象中筛选最大值和最小值，可以使用 Python 提供的内建函数 `max()` 和 `min()`。目前，我们只考虑从多个同种类型的对象中筛选最大值和最小值

```python
>>> max(1, 2, 3, 4, 5, 9, 10, 0)  # 赛选多个参数中的最大值
10
>>> max([1, 2, 3, 4, 5, 9, 100])  # 从一个序列中赛选最大值
100
```

## 流程控制

任何一门编程语言都需要提供流程控制的能力，Python 也不例外。

在 Python 中，代码默认是按照 **顺序执行**。根据不同的条件选择不同的执行路径，这称为 **条件分支**。根据是否满足同一个条件执行同一片代码，这称为 **循环**

下面我们首先介绍条件分支语句

### if 语句

与大多数语言类似，Python 也使用 `if` 关键字创建分支语句。

```python
>>> x = int(input("输入一个整数: "))
输入一个整数: 42
>>> if x < 0:   # 这个冒号是必不可少的
...     x = 0
...     print("负数被修改为 0")
... elif x == 0:
...     print("零")
... elif x == 1:
...     print("壹")
... else:
...     print("更多")
...
更多
```

上述代码展示了 Python 中 `if` 语句的基本结构。关键字 `if` 后跟随一个 **条件表达式**，随后是一个冒号(`:`)。

> [!tip] 
> 
> 在 Python 中，任何需要建立语句块的位置都需要使用冒号(`:`)
> 

然后，另起一行并使用 $4$ 个空格作为缩进，表示随后的代码块属于 `if` 分支下的语句块。此外，`if` 还有两个可选的子句：`elif` 和 `else`，其中 `elif` 等价于 C/C++ 中的 `else if`

> [!important] 
> 
> `elif` 子句至少有 $0$，`else` 子句最多 $1$。
> 

换句话说，最简单的 `if` 语句如下

```python
x = int(input("输入一个数字: "))
if x % 2 == 0:
	print("偶数")
```

有时，我们想要测试一个条件，如果为真则采用一条路径，如果不为真则指定另一条路径。这是通过 `else` 子句完成的

```python
x = int(input("输入一个数字: "))
if x % 2 == 0:
	print("偶数")
else:
	print("奇数")
```

### 条件表达式

Python 支持一种额外的决策实体，称为 **条件表达式**。最简单的条件表达式的语法如下：

```python
<expr1> if <condition> else <expr2>
```

首先对 `<condition>` 进行逻辑值检测 。如果为 `True`，则表达式的计算结果为 `<expr1>` 。如果为 `False`，则表达式的计算结果为 `<expr2>` 

> [!tip] 
> 
> 即，**首先计算中间的表达式，然后根据该结果返回两端的表达式之一**
> 

条件表达式是 `if-else` 语句的简化。等价于:

```python
if <condition>:
	<expr1>
else:
	<expr2>
```

> [!attention] 
> 
> 显然，使用条件表达式要更简洁
> 

**条件表达式的行为在语法上类似于表达式**。它 **可以用作较长表达式的一部分**。条件表达式的优先级实际上低于所有其他运算符，因此需要括号将其单独分组

```python
>>> x = y = 40
>>> z = 1 + x if x > y else y + 2
>>> z
42
>>> m = (1 + x) if x > y else (y + 2)
>>> m
42
```

如果我们希望首先计算条件表达式，则需要用分组括号将其括起来

```python
>>> z = 1 + (x if x > y else y) + 2
>>> z
43
```

> [!attention] 
> 
> 条件表达式与逻辑表达式一样执行短路求值
> 
```python
>>> 1 / 0 if False else 2 # 首先计算中间的表达式，结果为 Fase，。表达式 1/0 没有被计算，所以不会触发除零异常
2
```

条件表达式也可以链接在一起，作为一种替代的 `if` / `elif` / `else` 结构

```python
>>> x = 40
>>> s = ( "foo" if x == 1 else
...     "bar" if x == 2 else
...     "baz" if x == 40 else
...     quz if x == 5 else "quux")  # quz 此处无定义，依旧不会报错，因为此时 `quz` 还没有开始执行
>>> s
'baz'
```

### pass 语句

有时，我们可能会发现想要编写所谓的代码存根(即，一个 **占位符**)，用于 **最终放置尚未实现的代码块**。由于 Python 使用缩进而不是分隔符，因此不可能指定空块。如果用 `if <condition>:` 引入 `if` 语句，则必须在其后面添加一些内容，可以在同一行上，也可以在下一行缩进

```python
if True:

print("foo")
```

上述代码存在语法错误，即 `IndentationError: expected an indented block`。为此，Python 提供了一个关键字 `pass`，它表示一个代码占位符，不会改变程序的行为。解释器在语法上需要，但是不会做任何事情

```python
if True:
	pass
	
print("foo")
```

### while 语句

`while` 语句用于在表达式保持为真的情况下重复地执行。例如，我们可以像下面这样写出 **斐波那契数列** 初始部分的子序列

> [!tip] 
> 
> 斐波拉契数列：第$0$ 项为 $0$，第 $1$ 项为 $1$，从第 $2$ 项开始为前两项的和
> 
> $$ f(n) = \begin{cases} 0 & i=0\\ 1 & i = 1 \\ f(n-2) + f(n-1) & i \ge 2 \end{cases} $$
> 

```python
>>> a = 0
>>> b = 1
>>> while a < 10:
...     print(b)
...     a, b = b, a + b
...
1
1
2
3
5
8
13
```

> [!tip] 
> 
> `while` 循环中，只要条件表达式（这里是 `a < 10`）为真就会一直执行
> 

注意语句 `a, b = b, a + b` 是一个多重赋值语句。等号右边的所有表达式的值，都是在这一语句对任何变量赋新值之前求出来的

`while` 例程：一张纸厚道为 0.01 mm，对折多少次可以超过珠穆朗玛峰 8884.84 m

```python
"""
一张纸厚道为 0.01 mm，对折多少次可以超过珠穆朗玛峰 8884.84 m
"""

HEIGHT = 8884.84E3  # 珠穆朗玛峰的高度，单位以转换为毫米

count = 0  # 统计折叠次数

thickness = 0.01
while thickness < HEIGHT:
    thickness *= 2
    count += 1
    print(f"第 {count} 次折叠后纸的厚度为 {thickness}")

print(f"对折 {count} 次后，纸的厚度为 {thickness} 超过珠穆朗玛峰的高度{HEIGHT}")
```

### for 循环

Python 的 `for` 语句不迭代算术递增数值，或是给予用户定义迭代步骤和结束条件的能力，而是 **在  _可迭代对象_  上，按它们在序列中出现的顺序**。目前，我们学习过的可迭代对象就只有字符串(`str`) 一种

> [!tip] 
> 
> 可迭代对象：在 Python 中，能够被用在 `for` 循环的对象都是可迭代对象
> 
> 在 Python 中使用 `for` 可以按照既定顺序获取容器中的元素，这种不重复的获取容器对象中的元素称为 **遍历**
> 

```python
>>> for char in "hello, world!":
...     print(char)
...
h
e
l
l
o
,

w
o
r
l
d
!
```

> [!tip] 
> 
> 请注意，这里的 `char` 是只有一个字符的字符串，并不是字符
> 

### range 对象

使用 `for` 循环时，我们可能会需要一个整数等差序列。Python 的内置函数 `range()` 返回一个产生这样序列的 `range` 对象。

> [!tip] 
> 
> `range` 对象是一个可迭代对象，每次迭代时才会生成数据，而不是一次性生成。这种对象称为 **惰性对象**
> 
> 这种惰性对象在 Python 中称为 **生成器对象**
> 

`range()` 函数最多接收 $3$ 个参数，第一个参数指定序列的 **起始值**，第二个参数指定序列的 **结束值**，第三个参数指定 **步长**。注意，生成的序列中 **不包含结束值**

> [!tip] 
> 
> 如果只提供了一个参数，例如 `range(10)`，起始值为 $0$，结束值为 $10$，步长为 $1$
> 
> 如果提供了两个参数，例如 `range(2, 10)`，起始值为 $2$，结束值为 $10$，步长为 $1$
> 
> 如果提供了三个参数，例如 `range(1, 10, 2)`，起始值为 $1$，结束值为 $10$，步长为 $2$
> 

```python
>>> for i in range(1, 21, 2):
...     print(i)
...
1
3
5
7
9
11
13
15
17
19
>>> for i in range(10):
...     if i & 0x1:  # 位与：奇数最低位一定是 1
...         print(i)
...
1
3
5
7
9
```

### enumerate 对象

内置函数 `enumerate(iterable, start=0)` 将可迭代对象 `iterable` 中的每一项与一个整数一起打包生成一个元组视图`(i, iterable[j])`

```python
>>> for i in enumerate("hello, world!"):
...     print(i)
...
(0, 'h')
(1, 'e')
(2, 'l')
(3, 'l')
(4, 'o')
(5, ',')
(6, ' ')
(7, 'w')
(8, 'o')
(9, 'r')
(10, 'l')
(11, 'd')
(12, '!')
```

### 循环中的 break continue 和 else

Python 中 `break` 和 `continue` 与 C/C++ 中的类似。`break` 跳出最近一层的 `for` 或 `while` 循环。而 `continue` 语句结束当前的 `for` 或 `while` 循环

> [!tip] 
> 
> `break` 和 `continue` 可以参考 [[C 语言：基本概念#break 语句]] 和 [[C 语言：基本概念#continue 语句]]
> 

在 Python 中，`for` 和 `while` 还有一个可选的 `else` 子句。`else` 子句只有在循环正常退出的时候才会执行，换句话说就是 **通过 break 子句结束的循环其 else 子句不会执行**

例如，下面的 `for` 循环用于搜索质数

```python
for n in range(2, 10):
    for x in range(2, n):
        if n % x == 0:
            print(n, "equals", x, "*", n // x)
            break  # 跳出内层 for 循环
    else:  # 属于内层 for 循环，当内层 for 被 break 结束后，该子句不执行
        print(n, "is a prime umber")
```
