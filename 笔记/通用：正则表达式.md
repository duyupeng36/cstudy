# 正则表达式

正则表达式是一种用于 **匹配文本模式** 的强大语言。Python 通过标准库 `re` 提供支持。在学习 `re` 模块之前，我们要先学习正则表达式的语法

正则表达式本质上就是一个字符串，这个字符串由 **普通字符** 和 **特殊字符** 组成。

> [!tip] 
> 
> 普通字符就只是单纯的字符，例如字符 `"A"` `"0"` ，它们在匹配的时候只与它们自己匹配。最简单的正则表达式就是由普通字符组成。因此 `"last"` 匹配字符串 `'last'`
> 

> [!tip] 
> 
> 特殊字符要么**代表一些普通字符**，要么 **影响其附近的正则表达式的解释方式**
> 

下面我们就详细介绍正则表达式中的特殊字符

## 定位

正则表达式中有 $4$ 个特殊字符用于定位，它们的函数在下表列出

| 特殊字符 | 含义                                |
| :--- | :-------------------------------- |
| `^`  | 匹配字符串的开头，`MULTILINE` 模式下匹配每行的首个符号 |
| `$`  | 匹配字符串尾，`MULTILINE` 模式下匹配每行结尾的位置   |
| `\b` | 匹配单词的边界，即字与空格间的位置。                |
| `\B` | 匹配非单词边界                           |


特殊字符 `^` 从字符串开头进行匹配，如果在 `MULTILINE` 模式下，此时会在每一行的开头进行匹配，如下图示例展示的情形

![[Pasted image 20250404234147.png]]

特殊字符 `$` 匹配到字符串末尾，如果在 `MULTILINE` 模式下，此时会在每一行的末尾进行匹配，如下图示例展示的情形

![[Pasted image 20250404234359.png]]

## 限制匹配次数

下表列出的特殊字符是用于限制匹配次数的

| 特殊字符 | 含义                   |
| :--- | :------------------- |
| `*`  | `*` 前的表达式至少匹配 $0$ 次  |
| `+`  | `+` 前面的表达式至少匹配 $1$ 次 |
| `?`  | `?` 前面的表达式至多匹配 $1$ 次 |
特殊字符 `*` 会让它前面的正则表达式匹配至少 $0$ 次。如下图展示了特殊字符 `*` 的执行规则

![[Pasted image 20250405163337.png]]

特殊字符 `+` 会让它前面的正则表达式至少匹配 $1$ 次。如下图展示了特殊字符 `+` 的执行规则

![[Pasted image 20250405163419.png]]

特殊字符 `?` 会让它前面的正则表达式至多匹配 $1$ 次。如下图展示了特殊字符 `?` 的执行规则

![[Pasted image 20250405163615.png]]

正则表达式还支持我们自定义匹配次数。如下表

| 特殊字符     | 描述                                  |
| :------- | :---------------------------------- |
| `{m}`    | `{m}` 前的表达式匹配 $m$ 次                 |
| `{m, n}` | `{m, n}` 前的表达式至少匹配 $m$ 次，最多匹配 $n$ 次 |
| `{m, }`  | `{m, n}` 前的表达式至少匹配 $m$ 次            |

特殊字符 `{m}` 会让它前面的正则表达式匹配 $m$ 次。如下图展示了特殊字符 `{m}` 的执行规则

![[Pasted image 20250405172036.png]]

特殊字符 `{m, n}` 会让它前面的真正表达式至少匹配 $m$ 次，经可能多的匹配，最多匹配 $n$ 次

![[Pasted image 20250405174442.png]]

特殊字符 `{m, }` 会让它前面的正则表达式至少匹配 $m$ 次

![[Pasted image 20250405180518.png]]

## 代表普通字符

正则表达式提供了一些特殊字符用于代表一些列的普通字符。

| 特殊字符       | 含义                                   |
| :--------- | :----------------------------------- |
| `.`        | 匹配除 `\n` 之外的任何字符                     |
| `[alpha]`  | 匹配 `alpha` 指定的字符                     |
| `[^alpha]` | 匹配 `alpha` 之外的字符                     |
| `\w`       | 匹配 Unicode 字母数字类字符以及下划线 `_`          |
| `\W`       | 匹配 Unicode 字母数字类字符以及下划线 `_` *之外* 的字符 |
| `\s`       | 匹配 Unicode 空白字                       |
| `\S`       | 匹配不属于空白字符的任意字符                       |
| `\d`       | 匹配任意 Unicode 十进制数码，                  |
| `\D`       | 匹配任何非 Unicode 十进制数字的字符               |

特殊字符 `.` 可以匹配除换行符之外的任意字符。请注意，如果使用 `DOTALL` 可以匹配包括换行符在内的任何字符

![[Pasted image 20250405202256.png]]

特殊字符 `[alpha]` 匹配 `alpha` 指定的字符；特殊字符 `[^alpha]` 匹配 `alpha` 指定字符之外的字符

![[Pasted image 20250405202738.png]]
![[Pasted image 20250405203019.png]]

特殊字符 `\w` 匹配 Unicode 字母数字类字符以及下划线 `_`；特殊字符 `\W` 就匹配字母或数字以及下划线之外的字符

![[Pasted image 20250405204811.png]]
![[Pasted image 20250405204953.png]]

特殊字符 `\s` 匹配 Unicode 的空白字符；特殊字符 `\S` 匹配空白字符之外的字符

![[Pasted image 20250405205126.png]]
![[Pasted image 20250405205207.png]]

特殊字符 `\d` 匹配 Unicode 十进制数码；特殊字符 `\D` 匹配非 Unicode 十进制数码
![[Pasted image 20250405205447.png]]
![[Pasted image 20250405211858.png]]

## 或

正则表达式 `A | B` 表示匹配 `A` 或者 `B1`，其中  `A` 和 `B` 可以是任意正则表达式

> [!tip] 
> 
> 任意个正则表达式可以用 `'|'` 连接。扫描目标字符串时， `'|'` 分隔开的正则表达式从左到右进行匹配，当一个正则表达式完全匹配时，这个分支就被接受。
> 
> 意思就是，**一旦 _A_ 匹配成功， _B_ 就不再进行匹配**，即便它能产生一个更好的匹配。或者说，`'|'` 操作符绝不贪婪。
> 
> 如果要匹配 `'|'` 字符，使用 `\|`， 或者把它包含在字符集里，比如 `[|]`.
> 

![[Pasted image 20250405231838.png]]

## 分组

| 特殊字符             | 含义                            |
| :--------------- | :---------------------------- |
| `(...)`          | 捕获组， 匹配括号内的正则表达式，组的内容可以被获取或引用 |
| `(?P<name>...)`  | 命名的捕获组，通过名字获取或引用组的内容          |
| `(?P=name)`      | 引用命名捕获组组                      |
| `\number`        | 引用编号为 `number` 的组，组编号从 $1$ 开始 |
| `(?:...)`        | 非捕获组，匹配括号内的正则表达式，组的内容不能被获取或引用 |
| `(?aiLmsux:...)` | 非捕获组，根据 `aiLmsux` 指定的模式进行匹配   |
| `(?>...)`        | 非捕获组，一旦匹配就会丢弃回溯位置             |
| `(?#...)`        | 注释                            |

> [!attention] 
> 
> 注意 `(?aiLmsux:...)` 会使用 `"a" "i" "L" "m" "s" "u" "x"` 设置正则表达式的额外匹配模式
> 
> `(?aiLmsux-imsx:...)` 可以设置或移除正则的匹配模式。
> 
> 字母 `'a'`, `'L'` 和 `'u'` 在用作内联旗标时是 **互斥** 的，所以它们不能相互组合或者带 `'-'`。 相反，当它们中的某一个出现于内联的分组时，它将覆盖外层分组中匹配的模式。
> 
> 在 Unicode 模式中 `(?a:...)` 将切换至仅限 ASCII 匹配，而 `(?u:...)` 将切换至 Unicode 匹配（默认）。 在字节串模式中 `(?L:...)` 将切换为基于语言区域的匹配，而 `(?a:...)` 将切换为仅限 ASCII 匹配（默认）。 这种覆盖将只在内联分组范围内生效，而在分组之外将恢复为原始的匹配模式
> 

| 模式  | 描述                 |
| :-- | :----------------- |
| `i` | 忽略大小写              |
| `g` | 全局匹配模式             |
| `m` | 多行匹配模式             |
| `s` | 特殊字符 `.` 可以匹配 `\n` |
|     |                    |
| `a` | 仅限 ASCII 匹配        |
| `u` | 执行 Unicode 匹配      |
| `L` | 依赖于语言区域，即本地字符集匹配   |
| `x` | 可以为正则表达式添加视觉上的注释   |

请注意，这些模式并非所有的正则表达式处理库都支持，不过前 $4$ 是大多数正则处理库都支持的额外模式

## 断言

 所谓的断言就是判断条件是否成立。在正则表达式中，断言分为两种：**前视断言** 和 **后视断言**，此外还有它们的否定形式

| 特殊字符       | 描述      |
| :--------- | :------ |
| `(?=...)`  | 前视断言    |
| `(?!...)`  | 否定的前视断言 |
| `(?<=...)` | 后视断言    |
| `(?<!...)` | 否定的后视断言 |

 
> [!tip] 
> 
> 前视断言：顾名思义，在当前匹配位置 **向前查看** 是否满足匹配条件。注意，此时 **不会消耗字符**
> 

![[Pasted image 20250406001331.png]]
![[Pasted image 20250406001624.png]]


> [!tip] 
> 
> 后视断言：顾名思义，就是在当前位置匹配位置 **向后查看** 是否满足匹配条件
> 
> 请注意：**后视会回退字符** 然后才检查内部的正则表达式，因此后视的内部表达式必须是固定长度的
> 

![[Pasted image 20250406001902.png]]

## 非贪婪匹配

特殊字符 `+` `*` 和 `?` 都是 **贪婪** 的 ，即 **匹配尽可能多的文本**。有时这种行为并不被需要；如果正则表达式 `<.*>` 针对 `'<a> b <c>'` 进行匹配，它将匹配整个字符串，而不只是 `'<a>'`

在数量限定符之后添加 `?` 将使其以 **非贪婪** 风格来执行匹配；也就是将匹配 **尽可能少的** 字符。 使用正则表达式`<.*?>` 针对 `'<a> b <c>'` 进行匹配时，将只匹配 `'<a>'`。

## 占有型贪婪匹配

特殊字符 `'*'`, `'+'` 和 `'?'` 后添加 `'+'` 的形式也将匹配尽可能多的次数。 但是，不同于真正的贪婪型数量限定符，这些形式在之后的表达式 **匹配失败时不允许回溯**。 这些形式被称为 **_占有型_ 贪婪匹配**。

> [!example] 
> 
> 例如，`a*a` 将匹配 `'aaaa'` 因为 `a*` 将匹配所有的 4 个 `'a'`，但是，当遇到最后一个 `'a'` 时，表达式将执行反向追溯以便最终 `a*` 最后变为匹配总计 3 个 `'a'`，而第四个 `'a'` 将由最后一个 `'a'` 来匹配。
> 
> 然而，当使用 `a*+a` 时如果要匹配 `'aaaa'`，`a*+` 将匹配所有的 4 个 `'a'`，但是在最后一个 `'a'` 无法找到更多字符来匹配时，表达式将无法被反向追溯并将因此匹配失败。 
> 

> [!tip] 
> 
> `x*+`, `x++` 和 `x?+` 分别等价于 `(?>x*)`, `(?>x+)` 和 `(?>x?)`
> 
