# 对象模型

## tracemalloc：跟踪内存分配

`tracemalloc` 模块是一个用于对 Python 已申请的内存块进行调试的工具。它能提供以下信息:

- 回溯对象分配内存的位置
- 按文件、按行统计 Python 的内存块分配情况: 内存块总大小、数量以及块平均大小
- 对比两个内存快照的差异，以便排查内存泄漏

下面我们来看看如何跟踪内存

```python
import tracemalloc


# 开始跟踪内存分配
tracemalloc.start()

# 创建 1000000 个字典，存储在一个列表中
d = [dict(zip('xy', (5, 6))) for _ in range(1000000)]
# 创建 1000000 个元组，存储在一个列表中
t = [tuple(zip('xy', (5, 6))) for _ in range(1000000)]

snapshot = tracemalloc.take_snapshot()    # 获取当前内存快照
top_stats = snapshot.statistics('lineno')  # 统计快照对象

for stat in top_stats:
    print(stat)
```

执行上述代码的输出结果如下

```
./test.py:7: size=184 MiB, count=1999983, average=96 B
./test.py:8: size=168 MiB, count=3000004, average=59 B
```

输出结果表面字典占用的内存要比元组占用的内存大。这是因为 **字典会提前分配一些额外内存**；而 **元组只会分配它需要的内存**

关于快照的统计选项可以有下面几种

| 统计            | 描述        |
| ------------- | --------- |
| `'filename'`  | 按文件名统计    |
| `'lineno'`    | 按文件名和行号统计 |
| `'traceback'` | 回溯内存分配    |

## `__slots__` 

我们知道，对象的属性是保存在对象的属性字典中，并且每个对象都有一个独立的属性字典。当进程中存在很多对象时，就会占用大量的内存空间。

```python
import tracemalloc


class A:

    def __init__(self, a, b):
        self.a = a
        self.b = b


tracemalloc.start()

d = [A(0, 1) for _ in range(1000000)]

snapshot = tracemalloc.take_snapshot()

for line in snapshot.statistics("lineno"):
    print(line)
```

执行上述代码的输出结果为

```
./test.py:13: size=92.0 MiB, count=1000001, average=96 B
```

可以发现创建 $100$ 万个对象占用了 $92 \text{MB}$ 的内存。

> [!tip] 
> 
> 对象的属性比较少的，使用字典存储属性会浪费许多空间。因为实例属性字典占用的额外内存没有被使用
> 

Python 提供了一个特殊属性 `__slots__`，这个特殊属性会将对象的属性字典替换掉为占用内存较小的元组对象。

```python
import tracemalloc


class A:

    __slots__ = ("a", "b")  # 指定实例的属性名

    def __init__(self, a, b):
        self.a = a
        self.b = b


tracemalloc.start()

d = [A(0, 1) for _ in range(1000000)]

snapshot = tracemalloc.take_snapshot()

for line in snapshot.statistics("lineno"):
    print(line)
```

在替换实例的属性字典为元组之后，创建 $100$ 万个对象占用的内存降低为了 $53.8 \text{MB}$

```
./test.py:15: size=53.8 MiB, count=1000001, average=56 B
```

> [!attention] 
> 
> 请注意，`__slots__` 是类属性，它会替代该类的实例的属性字典。换句话说，该类的实例的 `__dict__` 属性就不会存在了
> 

```python
class A:

    __slots__ = ("a", "b")  # 指定实例的属性名

    def __init__(self, a, b):
        self.a = a
        self.b = b


a = A(1, 2)

# AttributeError：属性字典被替换了，此时该属性就不会存在
print(a.__dict__)
```

> [!attention] 
> 
> 由于实例的 `__dict__` 属性不存在了，那么设置实例属性时就必须设置实例已经存在的属性。这是因为实例内部采用元组保存属性值，它与 `__slots__` 中的属性名按位置一一对应。因为元组是不可变的，显然不能添加新属性
> 

```python
class A:

    __slots__ = ("a", "b")  # 指定实例的属性名

    def __init__(self, a, b):
        self.a = a
        self.b = b


a = A(1, 2)

a.a = 10
a.b = 20

a.c = 30  # AttributeError：实例 a 没有属性 c
```

请注意：`__slots__` 不会替换派生类对象的属性字典。也就是说：`__slots__` 属性只会替换它所在类的实例的属性字段

```python
class A:

    __slots__ = ("a", "b")  # 指定实例的属性名

    def __init__(self, a, b):
        self.a = a
        self.b = b


class B(A):
    pass

b = B(1, 2)
b.c = 200
print(b.__dict__)  # {'c': 200}：派生类拥有自己的属性字典
```

## 对象模型

**对象** 是 Python 中对数据的抽象。 Python 程序中的所有数据都是由对象或对象间关系来表示的。 从某种意义上说，按照冯·诺依曼的“存储程序计算机”模型^[[[计算机组成：计算机模型]]]，**代码本身也是由对象来表示的**。

### 对象概念

每个对象都有相应的 **标识号**、**类型** 和 **值**。 **一个对象被创建后它的 标识号 就绝不会改变**；你可以将其理解为该对象在内存中的地址

> [!tip] 
> 
> `is` 运算符比较两个对象的标识号是否相同；`id()` 函数返回一个代表其标识号的整数
> 
> 在 CPython 中，`id(x)` 就是存放 `x` 的内存的地址
> 

---

对象的类型决定该对象所支持的操作 (例如 "对象是否有长度属性？") 并且定义了该类型的对象可能的取值。`type()` 函数能返回一个对象的类型 (类型本身也是对象)。与编号一样，**一个对象的 类型 也是不可改变的**

---

有些对象的 _值_ 可以改变。值可以改变的对象被称为 _可变对象_；值不可以改变的对象就被称为 _不可变对象_。

> [!important] 
> 
> 一个不可变容器对象如果包含对可变对象的引用，当后者的值改变时，前者的值也会改变；但是该容器仍属于不可变对象，因为它所包含的对象集是不会改变的
> 
> 因此，不可变并不严格等同于值不能改变，实际含义要更微妙。参考 [[Python：内建数据结构#Tuple]]
> 

一个对象的可变性是由其类型决定的；例如，数字、字符串和元组是不可变的，而字典和列表是可变的。

---

在 Python 中，对**象绝不会被显式地销毁**；然而，当无法访问时它们可能会被作为垃圾回收。允许具体的实现推迟垃圾回收或完全省略此机制 

> [!tip] 
> 
> 如何实现垃圾回收是实现的质量问题，只要可访问的对象不会被回收即可
> 

CPython 目前使用带有 (可选) 延迟检测循环链接垃圾的引用计数方案，会在对象不可访问时立即回收其中的大部分，但不保证回收包含循环引用的垃圾。其他实现会有不同的行为方式，CPython 现有方式也可能改变。不要依赖不可访问对象的立即终结机制 (所以你应当总是显式地关闭文件)

> [!seealso] 
> 
> 查看 `gc` 模块的文档了解如何控制循环垃圾的收集相关信息
> 

注意：使用实现的跟踪或调试功能可能令正常情况下会被回收的对象继续存活。还要注意通过 `try...except` 语句捕捉异常也可能令对象保持存活

有些对象包含对“外部”资源如打开的文件或窗口的引用。 当对象被作为垃圾回收时这些资源也应该会被释放，但由于垃圾回收并不确保发生，这些对象还提供了明确地释放外部资源的操作，通常为一个 `close()` 方法。 强烈推荐在程序中显式关闭此类对象。 `try...finally` 语句和 `with` 语句提供了进行此种操作的更便捷方式。

---

有些对象包含对其他对象的引用；它们被称为 **容器**。容器的例子有 _元组_、_列表_ 和 _字典_ 等。这些引用是容器对象值的组成部分
+ 在多数情况下，当谈论一个容器的值时，我们是指所包含对象的值而不是其标识号
+ 当我们谈论一个容器的可变性时，则仅指其直接包含的对象的编号

因此，如果一个不可变容器 (例如元组) 包含对一个可变对象的引用，则当该可变对象被改变时容器的值也会改变。

---

**类型会影响对象行为的几乎所有方面**。 甚至对象标识号的重要性也在某种程度上受到影响：对于不可变类型，计算新值的操作实际上可能返回一个指向具有相同类型和值的任何现存对象的引用，而对于可变对象来说这是不允许的

例如在 `a = 1; b = 1` 之后，`a` 和 `b` 可能会也可能不会指向同一个值为一的对象。 这是因为 `int` 是不可变对象，因此对 `1` 的引用可以被重用。 此行为依赖于所使用的具体实现，因此不应该依赖它，而在使用对象标识测试时需要注意。 不过，在 `c = []; d = []` 之后，`c` 和 `d` 保证会指向两个不同的、独特的、新创建的空列表

> [!attention] 
> 
> 注意 `e = f = []` 会将 **同一个** 对象同时赋值给 `e` 和 `f`
> 

### 类对象之间的关系

在 Python 中，任何对象都有类型，可以使用 `type()` 或者 `__class__` 查看。然而，类型也是对象，它也有自己的类型。

下图展示了 Python 中类对象之间的关系

![[Pasted image 20250421001557.png]]

默认情况下，所有类的类型都是 `type`。我们称 `type` 为 **元类**。在 Python 中，类都继承了 `object` 类

`type` 本质上也是一个类；派生自 `object` 类，并且 `type` 类的类型也是 `type`。

