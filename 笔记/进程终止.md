# 进程终止

进程终止有两种方式

> [!tip] 接收到某个信号，即异常退出
> 
> 进程接收到某个信号时，如果该信号的默认行为是终止当前进程并且捕获该信号，那么进程就会被终止，可能还会产生核心转储文件
> 
> 详细内容参考 [[信号]]
>

> [!tip] 调用退出函数，即正常退出
> 
> 进程调用 `_exit()` 系统调用可以正常终止
>


## \_exit() 和 exit()

`_exit()` 是终止进程的系统调用

```c
#include <unistd.h>

void _exit(int status);
```

> [!tip] 参数 `status`：指定进程退出的状态
> 
> 父进程可以通过 `wait()` 接收到进程退出的状态。`status` 参数虽然定义为 `int` 类型，但是仅有低 $8$ 位可以为父进程所有
> 
> 按照惯例，终止状态为 $0$ 表示进程正常退出，非 $0$ 表示进程异常退出
> 
> 非 $0$ 返回值没有特别规定：应用程序可以自行定义，并在文档中加以说明。SUSv3 标准中定义了两个常量 `EXIT_SUCCESS(0)` 和 `EXIT_FAILURE(1)`
> 

> [!important] 
> 
> 调用 `_exit()` 的程序总会成功终止，即 `_exit()` 不返回
> 

虽然可以将 $0\sim 255$ 之间的任意值传递给 `_exit()` 的 `status` 参数，并传递给父进程，但是取值大于 $128$ 将在 shell 脚本中引发混乱

> [!attention] 
> 
> 当以信号终止一个命令时，shell 会将变量 `$?` 置为 $128$ 与信号值之和，以表征这一事实。如果这与进程调用 `_exit()` 时所使用的 `status` 相同，将令 shell 无法区分
> 

程序一般不会直接调用 `_exit()`，而是调用 `exit()` 库函数，它会在调用 `_exit()`之前执行各种动作

```c
#include <stdlib.h>

void exit(int status);
```

> [!tip] `exit()` 会执行如下动作
> 
> + 调用退出处理程序，即通过 `atexit()` 和 `on_exit()` 注册的函数，执行顺序与注册顺序相反
> + 刷新 `stdio` 流缓冲
> + 使用 `status` 的值调用 `_exit()`
> 

程序从 `main()` 返回也是正常终止程序的一种方法。如果 `main()` 函数中没有 `return` 语句，在 C99 及之后的标准等价于 `exit(0)`

## 进程终止细节

无论进程是否正常终止，都会发生如下动作

> [!tip] 
> 
> 关闭所有打开文件描述符 目录流 信息目录描述符 字符集转换描述符 
> 
> 由于关闭了文件描述符，将释放该进程持有的任何 [[文件锁]]
> 
> 分离任何已连接的 [[System V 共享内存]] 段，且对应于各段的 `shm_nattch` 计数器值减小 $1$
> 
> 进程为每个 [[System V 信号量]] 所设置的 `semadj` 值将会被加到信号量值中
> 
> 如果该进程是一个管理终端的管理进程,那么系统会向该终端前台进程组中的每个进程发送 `SIGHUP` 信号，接着终端会与会话脱离
> 
> 将关闭该进程打开的任何 [[POSIX 信号量#命名信号量]]，类似于调用 `sem_close()`
> 
> 将关闭该进程打开的任何 [[POSIX 消息队列]]，类似于调用 mq_close()。
> 
> 作为进程退出的后果之一，如果某进程组成为孤儿，且该组中存在任何已停止进程则组中所有进程都将收到 `SIGHUP` 信号，随之为 `SIGCONT` 信号
> 
> 移除该进程通过 `mlock()` 或 `mlockall()` 所建立的任何内存锁
> 
> 取消该进程调用 `mmap()` 所创建的任何内存映射
> 

只要进程终止，无论是否终止成功，都会释放掉进程占用的所有资源

## 退出处理程序

有时程序需要 **在进程终止前自动执行一些动作**。例如，如果程序使用了程序库，那么在进程终止前该库需要自动执行一些清理动作。由于程序库对于进程何时以及如何退出并无控制权，也无法要求主程序在退出前调用库中特定的清理函数，故而也不能保证一定会执行清理动作

> [!tip] 为了解决程序库无法要求主程序在退出前调用库中特定的清理函数，可以使用 **退出处理程序**
> 

**退出处理程序是一个由程序设计者提供的函数**，可于进程生命周期的任意时点注册，并 **在该进程调用 `exit()` 正常终止时自动执行**

> [!attention] 
> 
> 如果程序直接调用 `_exit()` 或因信号而异常终止，则不会调用退出处理程序
> 

### 注册退出处理程序

GNU C 语言函数库提供两种方式来注册退出处理程序。第一种方法是使用 **由 SUSv3 定义的 `atexit()` 函数**

```c
#include <stdlib.h>

int atexit(void (*func)(void));
/* 成功返回 0；错误返回非零*/
```

函数 `atexit()` 将 `func` 加到一个函数列表中，进程终止时会调用该函数列表的所有函数。应将 **函数 `func` 定义为不接受任何参数，也无返回值**，一般格式如下

```c
void func(void)
{
	// 基础退出时的处理程序
}
```

> [!important] 
> 
> 退出处理程序是一个**无参数且无返回值**的函数
> 

**可以注册多个退出处理程序**，甚至 **可以将同一函数注册多次**。当应用程序调用 `exit()` 时这些函数的 **执行顺序与注册顺序相反**

> [!tip] 
> 
>  一般情况下 **较早注册的函数所执行的是更为基本的清理动作**，可能需要在调用后续注册的函数后再执行
> 

退出处理程序中可以执行任何操作，包括注册新的退出处理程序，甚至调用 `exit()` 或 `_exit()`。

> [!warning] 
> 
> SUSv3 规定，**若退出处理程序自身调用 `exit()`，其结果未定义**。为保障可移植性，应用程序应 **避免在退出处理程序内部调用 `exit()`**
> 

如果有任意一个退出处理程序无法返回，则尚未执行的退出处理函数均不会再被执行

SUSv3 要求系统实现应允许一个进程能够注册至少 $32$ 个退出处理程序。使用系统调用 `sysconf(_SC_ATEXIT_MAX)`，应用程序即可确定由实现所定义的可注册退出处理程序的数量上限

> [!attention] 
> 
> glibc 运行注册的退出处理程序数量近乎于无限
> 
> 对于 Linux，`sysonf(_SC_ATEXIT_MAX)`返回 $2147482647$（即，$32$ 位有符号整型数的最大值）。换言之，在触及可注册函数数量的这一上限前，总会有其他原因（例如，内存不足）导致程序崩溃
> 

> [!important] 
> 
>  通过 `fork()` 创建的子进程会 **继承** 父进程注册的退出处理函数
>  
>  而进程调用 `exec()`时，会 **移除** 所有已注册的退出处理程序。因为 `exec()` 会替换包括退出处理程序在内的所有原程序代码段
> 
> 
> 

**无法取消由` atexit()`或 `on_exit()`注册的退出处理程序**。不过，可以令退出处理程序在执行动作之前检查全局执行标志是否置位，或者清除该标志来屏蔽退出处理程序

---

`atexit()` 注册的退出处理程序有两个限制：**无法获知进程的退出状态** 和 **无法给退出处理程序指定参数**。为摆脱这些限制，`glibc` 提供了一个（非标准的）替代方法：`on_exit()

```c
#define _BSD_SOURCE  /* #define _SVID_SOURCE*/
#include <stdlib.h>

int on_exit(void(*func)(int, void*), void *arg);
/* 成功返回 0 ，错误返回 非零*/
```

函数 `on_exit()` 的参数 `func` 是一个指针，指向如下类型的函数

```c
void func(int status, void *arg)
{
	// 进程退出时的处理
}
```

函数 `on_exit()` 的参数 `arg` 是传递给 `func()` 的第二个参数。该参数可以由程序设计者自行定义

> [!tip] 
> 
> 虽然比 `atexit()` 更灵活，但对于要保障可移植性的程序来说，还是应避免使用 `on_exit()`。因为并无标准涵盖到它，并且几乎也没有其他 `UNIX` 实现支持这一用法
> 

## fork()  stdio 缓冲区和 \_exit() 的交互

编写例程

```c title:procexec/fork_stdio.c

#include <unistd.h>

#include "base.h"

int main() {
    printf("hello world\n");
    write(STDOUT_FILENO, "Ciao\n", 5);

    if(fork() == -1) {
        errExit("fork");
    }

    exit(EXIT_SUCCESS);
}
```

编译运行的结果为

```shell
# 标准输出
$ ./fork_stdio
hello world
Ciao

# 重定向文件
$ ./fork_stdio > a
$ cat a
Ciao
hello world
hello world
```

 stdio 缓冲区是在进程的用户空间内存中维护的。通过 `fork()` 创建子进程时会复制这些缓冲区

> [!tip] 
> 
> 当标准输出定向到终端时，因为缺省为行缓冲，所以会立即显示函数 `printf()` 输出的包含换行符的字符串
> 
> 当标准输出重定向到文件时，由于缺省为块缓冲，当调用 `fork()` 时，`printf()` 输出的字符串 **仍在父进程的 `stdio` 缓冲区中**，并 **随子进程的创建而产生一份副本**。父、子进程调用 `exit()` 时会刷新各自的 `stdio` 缓冲区，从而导致重复的输出结果
> 

可以采用以下任一方法来避免重复的输出结果

+ 作为针对 `stdio` 缓冲区问题的特定解决方案，在调用 `fork()` 之前使用函数 `fflush()`。也可以使用 `setvbuf()` 和 `setbuf()` 来关闭 `stdio` 流的缓冲功能

+ 子进程可以调用 `_exit()` 而非 `exit()`，以便不再刷新 `stdio` 缓冲区

`write()` 的输出并未出现两次，这是因为 `write()` 会将数据直接传给内核缓冲区，`fork()` 不会复制这一缓冲区
