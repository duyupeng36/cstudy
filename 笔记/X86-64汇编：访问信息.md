# 访问信息

一个 `x86-64` 的中央处理单元（`CPU`）包含一组 $16$ 个存储 64 位值的 **通用目的寄存器**（用于 **存储整数数据** 或 **存储指针**）

下图展示了 `x86-64` 的 $16$ 个通用寄存器的名字和长度

![[Pasted image 20241005204251.png]]

指令可以对这 $16$ 个寄存器的 **低位字节** 中存放的 **不同大小** 的数据进行操作

> [!tip] 
> 
> 字节级操作可以访问最低的字节， $16$ 位操作可以访问最低的 $2$ 个字节， $32$ 位操作可以访问最低的 $4$ 个字节，而 $64$ 位操作可以访问整个寄存器
> 

## 操作指示符

大多数指令有一个或多个 **操作数**，指示出执行一个操作中要使用的 **源数据值**，以及放置结果的 **目的位置**。

> [!tip]
> 
>  源数据值可以以 **常数** 形式给出，或是从 **寄存器** 或 **内存** 中读出。结果可以存放在 **寄存器** 或 **内存** 中
> 

x86-64 支持多种操作数格式，**各种不同的操作数的可能性被分为三种类型**

> [!tip] **立即数**：用来表示常数值，只能做源操作数
> 
> AT&T 格式的汇编代码中，立即数的书写方式是 `$` 后面跟一个用标准 C 表示法表示的整数。比如，`$-577` 或者 `$0x1f`
> 
> 不同的指令允许的立即数值范围不同，汇编器会自动选择最紧凑的方式进行数值编码
> 

> [!tip] **寄存器**：表示某个寄存器的内容
> 
>  $16$ 个寄存器的低位 $1$ 字节、 $2$ 字节、 $4$ 字节或 $8$ 字节中的一个作为操作数
> 
> 我们用符号 $r_{a}$ 来表示任意寄存器 $a$, 用引用 $R[r_a]$ 来表示它的值，这是将寄存器集合看成一个数组 $R$, 用寄存器标识符作为索引 
> 

> [!tip] **内存引用**：它会根据计算出来的 **地址**（通常称为有效地址）**访问某个内存位置** 
> 
> 将内存看成一个很大的字节数组，我们用符号 $M_b[Addr]$ 表示对存储在内存中从地址 $Addr$ 开始的 $b$ 个字节值的引用 
> 

有多种不同的 **寻址模式**，允许不同形式的内存引用。最基本的形式就是 $Imm(r_{b},r_{i},s)$。这样的引用有四个组成部分：一个**立即数**偏移 $Imm$, 一个**基址**寄存器 $r_b$， 一 个**变址**寄存器 $r_i$，和一个比例因子 $s$

> [!attention] 
> +  $s$ 必须是 $1$，$2$ ，  $4$  或者 $8$
> + 基址和变址寄存器都必须是 $64$ 位寄存器
> 

> [!important] 有效地址计算公式
> 
> $$
> Imm+R[r_{b}]+R[r_{i}]\cdot s
> $$
> 

下表列出了所有形式的操作数

| 类型  | 格式                    | 操作数值                               | 名称       |
| :-- | --------------------- | ---------------------------------- | -------- |
| 立即数 | $\$Imm$               | $Imm$                              | 立即数寻址    |
| 寄存器 | $r_{a}$               | $R[r_{a}]$                         | 寄存器寻址    |
| 存储器 | $Imm$                 | $M[Imm]$                           | 绝对寻址     |
| 存储器 | $(r_{a})$             | $M[R[r_{a}]]$                      | 间接寻址     |
| 存储器 | $Imm(r_{b})$          | $M[Imm + R[r_b]]$                  | 基址+偏移量寻址 |
| 存储器 | $(r_{b}, r_{i})$      | $M[R[r_{b}]+R[r_{i}]]$             | 变址寻址     |
| 存储器 | $Imm(r_{b}, r_{i})$   | $M[Imm + R[r_b]+R[r_i]]$           | 变址寻址     |
| 存储器 | $(,r_{i}, s)$         | $M[R[r_{i}]\cdot s]$               | 比例变址寻址   |
| 存储器 | $Imm(,r_{i}, s)$      | $M[Imm + R[r_{i}]\cdot s]$         | 比例变址寻址   |
| 存储器 | $(r_{b},r_{i}, s)$    | $M[R[r_{b}]+R[r_{i}]\cdot s]$      | 比例变址寻址   |
| 存储器 | $Imm(r_{b},r_{i}, s)$ | $M[Imm+ R[r_{b}]+R[r_{i}]\cdot s]$ | 比例变址寻址   |

练习题：假设下面的值存放在指明的内存地址和寄存器中

| 地址      | 值      |     | 寄存器    | 值       |
| :------ | ------ | --- | ------ | ------- |
| `0x100` | `0xff` |     | `%rax` | `0x100` |
| `0x104` | `0xab` |     | `%rcx` | `0x1`   |
| `0x108` | `0x13` |     | `%rdx` | `0x3`   |
| `0x10c` | `0x11` |     |        |         |

 填写下表，给出所示操作数的值：

| 操作数                                                | 值       |
| :------------------------------------------------- | :------ |
| `%rax` ：寄存器寻址，`R[%rax]`                            | `0x100` |
| `0x104`：绝对寻址；`M[0x104]`                            | `0xab`  |
| `$0x108`：立即数寻址                                     | `0x108` |
| `(%rax)`：间接寻址；`M[R[%rax]]`                         | `0xff`  |
| `4(%rax)`：基址+偏移寻址；`M[4 + R[%rax]]`                 | `0xab`  |
| `9(%rax, %rdx)`：比例变址寻址； `M[9+R[%rax] + R[%rdx]]`   | `0x11`  |
| `260(%rcx,%rdx)`：比例变址寻址；`M[260+R[%rcx] + R[%rdx]]` | `0x13`  |
| `0xfc(,%rcx,4)`：比例变址寻址；`M[0xfc+R[%rcx] * 4]`       | `0xff`  |
| `(%rax,%rdx,4)`：比例变址寻址；`M[R[%rax] + R[%rdx] * 4]`  | `0x11`  |

## 数据传送指令

数据传送指令的作用： **将数据从一个位置复制到另一个位置**。这是使用最为频繁的指令

它们或者 **源和目的类型不同**，或者 **执行的转换不同**，或者 **具有的一些副作用不同**。

> [!tip] 最简单形式的数据传送指令 － `MOV` 类：这些指令把数据从源位置复制到目的位置，不做任何变化 
> 

`MOV` 指令仅仅做数据传送，不对数据做任何修改。下表列出了 x86-64 支持的 `MOV` 指令，这些指令都执行同样的操作；主要区别在于它们操作的数据大小不同

| 指令               | 效果                        | 描述      |
| :--------------- | ------------------------- | ------- |
| 基本形式: `MOV S, D` | 将 `S` 中的值，复制到 `D` 中       | 传送数据    |
|                  |                           |         |
| `movb`           |                           | 传送字节    |
| `movw`           |                           | 传送字     |
| `movl`           |                           | 传送双字    |
| `movq`           |                           | 传送四字    |
| `movabsq I, R`   | 将 `I` 中的数据求绝对值，并复制到 `D` 中 | 传送绝对的四字 |

> [!tip] MOV 指令中源操作数指定的值或者是一个 **立即数**，或者是 **存储在寄存器**，或者 **存储在内存中**

> [!tip] MOV 指令的目的操作数指定一个位置，或者是 **寄存器**，或者是 **内存**

> [!warning] x86-64 加了一条限制，**传送指令的两个操作数不能都指向内存位置**
> 
> 将一个值从一个内存位置复制到另一个内存位置需要两条指令
> + 第一条指令将源值加载到寄存器中
> + 第二条将该寄存器值写入目的位置
> 

这些指令的寄存器操作数可以是 $16$ 个寄存器有标号部分中的任意一个，寄存器部分的大小必须与指令最后一个字符指定的大小匹配

> [!important] 
> 
> MOV 指令只会更新目的操作数指定的那些寄存器字节或内存位置。然而，**`movl` 指令以寄存器作为目的时 ， 它会把该寄存器的高位 $4$ 字节设置为 $0$**
> 

> [!attention]  x86-64 采用的惯例
> 
> 任何为寄存器生成 $32$ 位值的指令都会把该寄存器的高位部分置成 $0$ 
> 

在将较小的源值复制到较大的目的时，需要使用 **MOVZ** 或者 **MOVS** 指令，所有这些指令都把数据从源（在寄存器或内存中）复制到目的寄存器。

> [!tip]  MOVZ 类中的指令把目的中剩余的字节填充为 $0$，即 **零扩展**
> 

> [!tip] MOVS 类中的指令则是将目的中的剩余字节填充为源操作数的最高位，及 **符号扩展**

这两类指令名字最后两个字符都是大小指示符：第一个字符指定源的大小， 而第二个指明目的的大小

| 指令          | 效果                   | 描述                     |
| :---------- | -------------------- | ---------------------- |
| `MOVZ S, R` | `R <- 零扩展(S)`        | 以零扩展进行传送               |
|             |                      |                        |
| `movzbw`    |                      | 零扩展的字节传送到字             |
| `movzbl`    |                      | 零扩展的字节传送到双字            |
| `movzwl`    |                      | 零扩展的字传送到双字             |
| `movzbq`    |                      | 零扩展的字节传送到四字            |
| `movzwq`    |                      | 零扩展的字传送到四字             |
|             |                      |                        |
| `MOVS S, R` | `R <- 符号扩展(S)`       | 以符号扩展进行传送              |
|             |                      |                        |
| `movsbw`    |                      | 符号扩展的字节传送到字            |
| `movsbl`    |                      | 符号扩展的字节传送到双字           |
| `movswl`    |                      | 符号扩展的字传送到双字            |
| `movsbq`    |                      | 符号扩展的字节传送到四字           |
| `movswq`    |                      | 符号扩展的字到四字              |
| `movslq`    |                      | 符号扩展的双字到四字             |
| `cltq`      | `%rax <- 符号扩展(%eax)` | 把号 `%eax` 符号扩展到 `%rax` |
> [!attention] 注意：没有一条明确的指令把 $4$ 字节源值零扩展到 $8$ 字节目的
> 
> 这样的数据传送可以用以寄存器为目的的 `movl` 指令来实现。因为，`movl` 会把高 $4$ 字节设置为 $0$
> 

> [!tip] `cltq` 指令
> 
> 总是以寄存器 `％eax` 作为源，`％rax` 作为符号扩展结果的目的
> 

考虑下的数据交换函数，使用 GCC 产生会变代码

```c title:exchange.c
long exchange(long *xp, long y)
{
	long x = *xp;
	*xp = y;
	return x;
}
```

命令 `gcc -Og -S exchange.c` 产生的会变代码如下

```c title:exchange.s
// long exchange(long *xp, long y)
// xp in %rdi; y int %rsi
exchange:
	movq	(%rdi), %rax  // 将 xp 指向内存的值复制到 %rax 中
	movq	%rsi, (%rdi)  // 将 y 的复制到 xp 指向的内存
	ret
```

指令 `movq (%rdi), %rax` 就直接实现了 `long x = *xp` 这条语句。稍后，用寄存器 `％rax` 从这个函数返回一个值，因而返回值就是 `x` 

指令 `movq %rsi, (%rdi)` 直接实现了 `*xp = y` 这条语句

> [!summary] 上述这段汇编代码
> 
> 首先，我们看到 **C 语言中所谓的 ”指针“其实就是地址**。**间接引用** 指针就是将该 **指针放在一个寄存器中**，然后在 **内存引用** 中 **使用这个寄存器**
> 
> 其次，**像 `x`  这样的局部变量通常是保存在寄存器中，而不是内存中**。访问寄存器比访问内存要快得多
> 

## 压栈和出栈

最后两个数据传送操作可以 **将数据压入程序栈 中** ，以及 **从程序栈中弹出数据**

正如我们将看到的，栈在处理过程调用中起到至关重要的作用。**栈是一种数据结构**，可以添加或者删除值，不过要遵循 **”后进先出”** 的原则

通过 `push` 操作把数据压入栈中，通过 `pop` 操作删除数据；它具有一个属性：**弹出的值永远是最近被压入而且仍然在栈中的值**

栈可以实现为一个数组，总是从数组的一端插入和删除元素，这一端被称为栈顶。在 x86-64 中，程序栈存放在内存中某个区域 。 **栈向下增长**，这样一来， **栈顶元素的地址是所有栈中元素地址中最低的**

> [!tip] 
> 
> 栈指针`％rsp` 保存着栈顶元素的地址
> 

| 指令        | 效果                                        | 描述                |
| :-------- | ----------------------------------------- | ----------------- |
| `pushq S` | `R[%rsp] <- R[%rsp] - 8; M[R[%rsp]] <- S` | 将四字 `S` 压入栈中      |
| `popq D`  | `D <- M[R[%sp]]; R[%rsp] <- R[%rsp] + 8`  | 删除栈顶元素，并存储在 `D` 中 |

将一个四字值压入栈中 ， 首先要将栈指针减 $8$, 然后将值写到新的栈顶地址。因此，指令 `pushq %rbp` 的行为等价于

```c
subq $8, %rsp  // %rsp <- %rsp - 8
movq %rbp, (%rsp)  // M[R[%rsp]] <- R[%rbp]
```


弹出一个四字的操作包括从栈顶位置读出数据，然后将栈指针加 $8$ 。 因此，指令 `popq %rax` 等价于下面两条指令

```c
movq (%rsp), %rax  // 将栈顶数据读取到 %rax 中
addq $8, %rsp  // 栈指针 + 8
```


下图的前两栏给出的是入栈操作，而最后一栏给出的是出栈操作

![[Pasted image 20241006152516.png]]

