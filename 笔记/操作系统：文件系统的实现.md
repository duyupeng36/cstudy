# 文件系统的实现

## 文件系统结构

在 [[计算机组成：计算机组成原理#输入/输出子系统#存储设备#磁介质存储设备]] 中我们简单说明了了磁盘的结构

**磁盘** 是由一张一张的 **盘片** 堆叠而成的。盘片的两面都涂着 **磁介质** 材料。信息是通过悬浮在盘片表面的的 **读/写磁头** 读写磁介质表面来进行读取和存储的
 ![[Pasted image 20241010162938.png]]

> [!tip] 盘片
> 
> 盘片表面的每个同心圆被逻辑地分成 **磁道**，每个磁道又被细分为 **扇区** 
> 

> [!tip] 磁臂：读写磁头附着位置，**磁臂将所有磁头作为一个整体移动**
> 

> [!tip] 柱面：**同一磁臂位置的磁道集合** 称为柱面
> 

每个磁盘有数千个同心柱面，每个磁道可能包含数百个扇区。当使用磁盘时，驱动电机高速旋转磁盘，使用 **每分钟转速** 衡量驱动电机的性能。磁盘的读写速率由两部分组成：**传输速率** 和 **定位时间**

> [!tip] 每分钟转速(RPM)：驱动器每分钟旋转磁盘的圈数
> 
> 大多数驱动器每秒旋转 $60 \sim 250$ 次
> 

> [!tip] 传输速率：在驱动器和计算机内存之间的数据六速率

> [!tip] 定位时间：包括 **寻道时间** 和 **旋转延迟**
> 
> + 寻道时间：移动磁臂到所需柱面的时间
> 
> + 旋转延迟：盘片旋转到所需扇区的时间
> 

从磁盘的结构中，我可以了解磁盘的两个优势

> [!tip] 磁盘的优势
> 
> **原地重写**：可以从磁盘上读取一块，修改该块，然后写回原来的位置
> 
> **顺序访问** 和 **直接访问**：磁盘支持顺序访问和直接访问
> + 顺序访问：顺序读取文件的内容
> + 直接访问：随机读取文件某些部分的内容
> 
> 磁盘从一个文件切换到另一个文件只需移动读写磁头，并且等待磁盘旋转到文件所在位置
>

> [!seealso] 
> 
> [[计算机组成：存储器层次结构]] 
> 

为了提高 IO 效率，内存和磁盘之间的 IO 传输以 **块** 为执行单位。每个块具有一个或多个 **扇区**

> [!tip]
> 
> 扇区大小从 $32$ 字节到 $4906$ 字节不等，通常为 $512$ 字节
> 

文件系统提供高效和便捷的磁盘访问，以便允许轻松存储，定位，读取数据。文件系统的设计有两个不同的问题

> [!question] 文件系统设计的问题
> 
> 第一个问题：如何定义文件系统的用户接口
> + 涉及定义文件，文件属性，允许的操作，组织文件的目录结构
>   
>  第二个问题：创建算法和数据结构，以便映射逻辑文件系统到物理外存设备
> 

**文件系统的设计是分层的**，每层都利用更底层的功能，创建新功能，为更高层服务。下图是文件系统分层设计的一种

![[Pasted image 20241010135547.png]]

> [!tip] IO控制层
> 
> 包括 **设备驱动程序** 和 **中断处理程序**，以在主内存和磁盘系统之间进行信息传输
> 
> 设备驱动程序作为翻译器，将基本文件系统发送过来的指令翻译为底层硬件特定的指令，硬件控制器利用这些指令来使 IO 设备与系统的其他部分相连
> 
> + 设备驱动程序在 IO 控制器的特定位置写入特定格式，告诉控制器对设备的什么位置采取什么动作
> 

> [!tip] 基本文件系统
> 
> 基本文件系统向设备驱动程序送通用命令，以读取和写入磁盘的物理块。物理块由磁盘的 **数字地址** 标识。 `(驱动器号, 柱面号, 磁道号, 扇区号)`
> 
> 同时，该层也管理 **内存缓冲区** 和保存各种文件系统，目录和数据块的 **缓存**
> + 内存缓冲区：在进行磁盘传输之前，在内存中分配一块缓冲区。当缓冲区已满时，缓冲管理器必须找到更多缓冲内存或释放缓冲空间，以便于完成 IO 请求
> + 缓存：用于保存常用的文件系统元数据，以提高性能；因此管理它们的内容对于系统性能优化很重要
> 

> [!tip] 文件组织模块
> 
> 文件组织模块知道 **文件** 及其 **逻辑块** 以及 **物理块**。由于知道所用的文件分配类型和文件位置，**文件组织模块可以将逻辑块的地址转换为物理块地址**
> 
> 文件的逻辑块编号从 $0$ 到 $N$ ；而包含数据的物理块与逻辑块编号并不相同，因此需要通过转换来定位物理块
> 
> 该层还可以包括 **可用空间管理器**，用于跟踪未分配的块并根据要求提供给文件组织模块
> 

> [!tip] 逻辑文件系统
> 
> 逻辑文件系统用于管理 **元数据** 信息。元数据包括文件系统的所有结构，而不包括实际数据
> 
> 逻辑文件系统用于 **管理目录结构**，以便于根据给定文件名称为文件组织模块提供信息
> 
> 逻辑文件系统通过 **文件控制块(FCB)** 来维护文件结构。通过也负责文件保护
> + 文件控制块包含所有者，权限，文件内容的位置等文件相关信息。
> 

## 文件系统实现

文件系统的实现采用多个磁盘和内存的结构；文件系统存放在磁盘上，一些管理文件系统的数据结构存放在内存中

大多数磁盘被划分为一个或多个分区，每个分区都可以安装独立的文件系统。 **在磁盘上**，文件系统包括如下信息

> [!tip] 引导控制块，也称 **引导块**：包含从该卷引导操作系统的所需信息
> 
> 计算机加电启动时，BIOS 从这里读取可执行代码和数据，完成操作系统的自举
> 
> 如果磁盘不包含操作系统，则该块内容为空。通常是卷的第一块
> 

> [!tip] 卷控制块，也称 **超级快**：记录卷或分区的详细信息
> 
> + 分区的块数量，块大小
> + 空闲块的数量和指向空闲块的指针
> + 空闲的 FCB 数量和指向空闲 FCB 的指针
> 

> [!tip] **目录结构**：用于组织文件
> 
> 在 UFS 中，包含文件名和相关的 $\text{i-node}$ 号
> 

> [!tip] **每个文件的 FCB**：包括该文件的许多详细信息
> 
> 有一个唯一的标识号，以便于与目录条目管理
> 

**在内存中**，某些信息用于管理文件系统并通过缓存来提高性能。这些数据在安装文件系统是被加载，在文件系统操作期间被更新，在卸载时被丢弃。这些结构包括

> [!tip] **安装表**：每个安装卷的有关信息
> 

> [!tip] **目录结构的缓存**：最近访问的目录信息
> 
> 对于加载卷的目录，它可以包括一个执行卷表的指针
> 

> [!tip] **系统级的打开文件表**：包括每个打开文件的 FCB 的副本以及其他信息

> [!tip] **进程级的打开文件表**：指向系统打开文件表中的条目的指针
> 
> Linux 中成为进程 **文件描述符表**
> 

> [!tip] 对磁盘进行读取和写入时，缓冲区保存文件系统的块

为了创建新的文件，应用程序调用逻辑文件系统。逻辑文件系统知道目录结构的格式；它就会分配一个新的 FCB。然后，系统将相应的目录读到内存，使用新的文件名和 FCB 进行更新，并将目录写回磁盘。下图显示了一个典型的 FCB

![[Pasted image 20241010145054.png]]

> [!tip]
> 
> 不同的操作系统对目录的处理方式不同。例如，Unix/Linux 将目录当作文件处理，使用类型位区分是否为目录。Windows 为文件和目录提供不同的系统调用，对文件和目录采取不同的处理方式 
> 

一旦文件被创建，它就能用于 IO。不过，首先，文件应该被打开。系统调用 `open()` 将文件名传递到逻辑文件系统

> [!tip] 首先搜索系统级打开文件表
> 
> 系统调用 `open()` 首先搜索整个系统的打开文件表，以便于确定这个文件是否已经被其他进程使用
> + 如果文件已经被其他进程使用，则在进程级打开文件表(**文件描述符表**)中创建一个条目，并让其执行现有系统级打开文件表中对应的条目
> 
> + 如果文件尚未被其他进程使用，则根据给定的文件名来搜索目录结构(目录结构可能被缓存在内存中)。找到文件后，它的 FCB 就被被复制到系统级打开文件表中 
>   

> [!tip] 接下来，进程的打开文件表中新建条目
> 
> 接下来，进程的打开文件表中新建条目，存储指向系统级打开文件表中对应的条目的指针
> 
> 
> 在 Unix/Linux 中，进程级打开文件表也被称为 **文件描述符表**
> 

当进程关闭文件时，文件描述符表中的对应条目被删除，系统级打开文件表对应条目的引用计数减 $1$。当所有打开文件的进程关闭它时，任何更新的元数据会被复制到基于磁盘的目录结构，并且系统级打开文件表中对应的条目被删除

下图总结了文件系统实现的操作结构

![[Pasted image 20241010143917.png]]


### 虚拟文件系统

**现代操作系统必须同时支持多种文件系统**。但是，各种文件系统的实现细节均不相同，包括文件块的分配方式，目录的组织方式。

如果每个与文件打交道的程序都需要理解各种文件系统的具体细节，那么编写与各类文件系统交互的程序将近乎于不可能完成的任务。**虚拟文件系统**（VFS，有时也称为虚拟文件交换）是一种 **内核特性**，通过 **为文件系统操作创建抽象层** 来解决上述问题。VFS 的原理如下图

![[Pasted image 20241010194312.png]]

> [!tip] VFS 提供了两种重要的功能
> 
> **定义一个清晰的 VFS 接口**，将文件系统的通用操作和实现细节分开。所有与文件交互的程序都会按照这一接口来进行操作。**VFS 接口的多个实现可以在一台机器上共存**
> 
> 提供了一种以唯一表示网络上的文件的机制。VFS 基于称为 **虚拟节点** 的文件彼岸是结构，包含一个数字指示符以唯一表示网络上的文件
> 

> [!note] Linux VFS 定义的 $4$ 种主要对象
> 
> + $\text{i-node}$ 对象：表示单独一个文件
> + 文件对象：表示打开文件
> + 超级快对象：表示整个文件系统
> + 目录条目对象：表示单个目录条目
> 

程序只需理解 VFS 接口，而无需过问具体文件系统的实现细节。**VFS 接口的操作与涉及文件系统和目录的所有常规系统调用相对应**

## 目录实现

目录分配和目录管理的算法选择显著影响文件系统的效率

### 线性目录

采用 [[数据结构：线性表]] 实现目录，但是搜索目录条目非常耗时，不建议使用

### 哈希目录

采用 [[数据结构：散列表]] 实现目录。根据文件名称计算一个散列值，然后将目录条目插入到哈希表中

> [!attention] 
> 
> 需要采用一些规定避免哈希碰撞
> 
> 哈希表的主要困难是，它的固定大小和哈希函数对大小的依赖
> 

## 分配方法

磁盘直接访问的特点在文件实现四提供了灵活性。在几乎每种情况下，很多文件都存储在同一个磁盘上。现在最主要的问题就是 **如何为这些文件分配空间**，以便于高效的使用磁盘空间和快速访问文件

### 连续分配

连续分配要求每个文件 **在磁盘上占用一组连续的块**，类似于顺序表。磁盘地址为磁盘定义了一个线性排序。下图是连续分配的示例

![[Pasted image 20241010212306.png]]

> [!tip] 
> 
> 文件的连续分配可以使用 **首块地址** 和连续的 **块数** 来定义。如果文件有 $n$ 块并且从位置 $b$ 开始，则文件将占用位置 $b,b+1,\cdots, b+n-1$ 
> 

> [!success] 优点：文件访问容易
> 
> 对于顺序访问，文件系统会记录上次引用的块的磁盘地址，如需要可读入下一块
> 
> 对于直接访问，从块 $b$ 开始的第 $i$ 块，可以直接访问块 $b+i$
> 

> [!warning] 缺点
> 
> 文件的创建和删除，可能会找出 **磁盘碎片**。之后为一个新文件找到合适的空间将变得困难
> 

### 链接分配

采用链接分配，每个文件是磁盘块的链表；磁盘块可以散布在磁盘的任何地方。下图是链接分配的一个示例

![[Pasted image 20241010212400.png]]

> [!caution] 缺点：只能实现顺序访问；需要额外的空间存放指针
> 
> 文件只能从起始磁盘块依次访问；并且有一部分磁盘空间存储了下一个磁盘块的指针
> 

### 索引分配

为了解决链接分配不能直接访问的问题，通过 **将所有的指针放在一起** 形成一张索引表，即 **索引分配**

每个文件都有自己的索引块，这是一个磁盘块地址的数组。索引块的第 $i$ 个条目执行文件的第 $i$ 块。目录包含了索引块的地址。当查找和读取第 $i$ 块时，采用第 $i$ 各索引块条目的指针。下图展示了一个索引分配示例

![[Pasted image 20241010213003.png]]

Linux 的 EXT2 文件系统的文件分配就是采用这种索引分配方案

![[Pasted image 20241010213229.png]]

## 空闲空间管理

由于磁盘空间有限，如果有可能，需要将删除文件的空间重新用于新文件。为了跟踪空闲磁盘空间，文件系统需要维护一个 **空闲空间表**，记录了所有空闲磁盘空间

> [!tip] 
> 
> 创建文件时，搜索空闲空间列表得到所需要的空间数量，并分配该空间给新文件。然后，从空闲空间表中删除
> 
> 删除文件时，其磁盘空间会增加到空闲空间列表上，实际磁盘空间中可能依旧保存的是被删除文件的数据
> 

### 位向量

空闲空间列表采用 **位图** 或者 **位向量** 来实现。每个块用一个位来表示。如果块空闲，则位为 $1$；如果块是分配的，则位为 $0$

> [!tip] 
> 
> 空闲块：位为 $1$
> 
> 已分配：位为 $0$
> 

> [!example] 
> 
> 假设一个磁盘，其中块 $2,3,4,5,8,9,10,11,12,13,17,18,25,26,27$ 为空闲块，而且他块为已分配。空闲空间位图如下
> 
> ```
> 001111001111110001100000011100000....
> ```
>  

使用位图的可以高效的查找磁盘行的第 $1$ 个空闲块和 $n$ 连续的空闲块

> [!tip] 
> 
> 大多数计算机提供位操作，可以有效用于这一目的
> 

在采用位图的文件系统上查找第 $1$ 个空闲块来分配磁盘空间的一种方法是，按顺序检查字图的每个位是否为 $0$，因为一个值为 $0$ 的字只包含 $0$ 位且表示一组已分配的块。扫描第一个非 $0$ 的字，以查找值为 $1$ 的为，它对应低一个空闲块。计算块号码的公式如下

$$
(\text{每个字的位数}) \times (\text{值为} 0 \text{的字数}) + \text{第一个值为} 1 \text{的位的偏移}
$$

### 链表

将空闲块使用链表串联起来，将指向第一个空闲块的制作保持在磁盘的特殊位置。如下图所示

![[Pasted image 20241010221658.png]]

> [!tip]
> 
> 遍历空闲列表不是一个频繁的操作，而且分配文件只需要知道第一个空闲块，就能完成分配
> 

### 组

链表方式的一种改进。在第一个空闲块中存储 $n$ 个空闲块的地址。这些块的前 $n-1$ 个确实为空，第 $n$ 个块存储另外 $n$ 个空闲块的地址，依次类推，就可以将磁盘中的空闲块完全保存下来，并且还能快速搜索空闲块

## Linux 文件系统

我们以 Linux 文件系统为例，看一个具体的文件系统逻辑结构。文件系统存放在磁盘上。多数磁盘被划分为一个或多个分区，**每个分区中有一个独立的文件系统**。文件系统包含的内容和布局向如下图

![[Pasted image 20241010161332.png]]

**磁盘的 $0$ 号扇区称为主引导记录(MBR)**，用于引导计算机； **在 MBR 的结尾是分区表**，表中给出了每个分区的起始和结束地址

每个分区都可以安装独立的文件系统。 **在磁盘上**，文件系统包括如下信息

> [!tip] **引导块**：包含从该卷引导操作系统的所需信息
> 
> 计算机加电启动时，BIOS 从这里读取可执行代码和数据，完成操作系统的自举
> 
> 如果磁盘不包含操作系统，则该块内容为空。通常是卷的第一块
> 

> [!tip] **超级快**：记录文件系统整体信息
> + 文件系统的格式和大小
> + $\text{i-node}$ 和数据块的总量，使用量和剩余量
> 

超级块之后是若干 **柱面组**，其中每个柱面组包括

> [!tip] 超级块副本
> 
> 超级块的拷贝
> 

> [!tip] 柱面组信息
> 
> 柱面组的整体描述
> 

> [!tip] $\text{i-node}$ 映射表：$\text{i-node}$ 号与 $\text{i-node}$ 的关联
> 
> $\text{i-node}$ 号与 $\text{i-node}$ 在磁盘中的位置的对应表
> 

> [!tip] 块位图：标识数据块是否被占用，用于 **管理空闲空间**
> 
> 位图中的每个二进制位对应一个数据块，用 $1$ 和 $0$ 标识数据块处于占用或空闲状态
> + $1$ 代表占用
> + $0$ 代表空闲
> 

> [!tip] $\text{i-node}$ 表：若干 $\text{i-node}$
> 
> $\text{i-node}$ 中记录 **文件元数据** 和 **数据块索引表**
> 

> [!tip] 数据块集合：若干数据块
> 
> 存储文件的内容数据。数据块的大小或者为 $512$，或者 $1024$，或者为 $4096$ 字节
> 
> 数据块有两类：**直接块** 和 **间接块**
> + 直接块：存储文件的实际内容
> + 间接块：存储下一级文件数据块的索引表
> 

### i-node

针对驻留于文件系统上的 **每个文件**，文件系统的 **i-node表** 会包含一个 **i-node**，即 **索引节点**(index node，$\text{i-node}$)。每个 $\text{i-node}$ 都有一个唯一编号

> [!summary] 
> 
> + 每个文件对应一个 $\text{i-node}$
> 
> + 每个 $\text{i-node}$ 都有唯一编号
> 
> + 目录文件中记录了文件名和 $\text{i-node}$ 号的对应关系。目录文件中的一条记录($\text{文件名}$, $\text{i-node 号}$) 成为一个 *硬链接*
> 

> [!hint] 
> 
> 硬链接：文件名与 $\text{i-node}$ 号的对应关系
> 

如何通过 $\text{i-node}$ 号在磁盘上找到 $\text{i-node}$ 呢？答案就是 **$\text{i-node}$ 映射表**

> [!attention] 
> 
> 对于使用 $\text{i-node}$ 表的索引作为 $\text{i-node}$ 号的文件系统， $\text{i-node}$ 映射表不是必需的
> 

#### i-node 保存的信息

一个  $\text{i-node}$ 保存信息如下图

![[Pasted image 20241010190158.png]]

> [!summary] 
> 
> $\text{i-node}$ 保存了 **文件属性** 和 **文件数据块索引表**。因为文件系统存储文件数据时，数据块不一定是连续存储的，甚至不一定是顺序存放的；为了能够确定文件的数据，文件系统在 $\text{i-node}$ 中维护了一个数据块索引表，用于定位文件数据
> 
> 数据块索引表或者保存 **直接数据块的指针**，或者保存 **另一个数据块索引表的指针**
> 

### EXT2 文件系统

多年来，`ext2`（扩展文件系统二代）是 Linux 上使用最为广泛的文件系统，也是原始 Linux 文件系统——ext 的继任者。近来，随着各种日志文件系统的兴起，对 `ext2` 的使用也日趋减少

> [!seealso] 
> 
> ext2 文件系统的主页为 http://e2fsprogs.sourceforge.net/ext2.html 。该站点上有一篇概括 ext2 实现的优秀论文
> 

在文件系统中，**用来分配空间的基本单位是 _逻辑块_**，亦即 **文件系统所在磁盘设备上若干连续的 _物理块_**。在 ext2 文件系统上，逻辑块的大小为 `1024`、`2048` 或 `4096` 字节

下图显示了磁盘分区 和 EXT2 文件系统之间的关系：每个分区都可以装载不同的文件系统

![[Pasted image 20241010191259.png]]

> [!tip]
> 
> 驻留于同一物理设备上的不同文件系统，其类型、大小以及参数设置（比如，块大小）都可以有所不同。这也是将一块磁盘划分为多个分区的原因之一
> 

EXT2 中的 $\text{i-node}$ 和数据块指针

类似于大多数 UNIX 文件系统，EXT2 文件系统在存储文件时，**数据块不一定连续**，甚至 **不一定按顺序存放**（尽管 EXT2 会尝试将数据块彼此靠近存储）。**为了定位文件数据块，内核在 $\text{i-node}$ 内维护有一组指针**

EXT2 文件系统的 $\text{i-node}$ 中的数据块指针表长度为 $15$。其中，前 $12$ 个指针指向文件前 $12$ 个数据块；后 $3$ 个指针指向 **间接指针块**

![[Pasted image 20241010192816.png]]

> [!tip] 
> 
> 间接指针块中的指针数量取决于文件系统中块的大小。每个指针需占用 $4$ 字节，因此指针的数量可能在 $256$（块容量为 $1024$ 字节）～ $1024$（块容量为 $4096$ 字节）之间
> 
> 即便是对于巨型文件，第 $14$ 个指针是一个 **双重间接指针**：指向指针块，其块中指针进而指向指针块，此块中指针最终才指向文件的数据块
> 
> 只要有体量巨大的文件，就会随之产生更深一层的递进：$\text{i-node}$ 的最后一个指针属于 **三重间接指针**
> 

> [!attention] 
> 
> 无需连续存储数据块，使得文件系统 **对磁盘空间的利用更为高效**
> 
> 特别是，还能 **降低空闲磁盘空间的碎片化程度**，即因众多不连续空闲磁盘碎片（因其空间太小而无法使用）而导致的磁盘空间浪费
> 
> 换言之，**对空闲磁盘空间的高效利用，是以已分配磁盘空间中文件的碎片化为代价的**
> 

EXT2 文件系统的这种设计满足了多种需求:
+ 系统维护的 $\text{i-node}$ 结构大小固定，同时支持任意大小的文件
+ 文件系统可以 **不连续存储文件块**，同时又 **支持直接访问**
+ 对于小文件，可以通过 $\text{i-node}$ 中的直接指针快速访问到
+ 文件可以有空洞：文件系统 **只需将 $\text{i-node}$ 和间接指针块中的相应指针打上标记（值 $0$）**，表明这些指针并未指向实际的磁盘块即可，而无需为文件空洞分配空字节数据

> [!seealso] 
> 
> [[Linux 系统编程：文件 IO#直接访问#文件空洞]]
> 

### 文件访问流程

针对给定的文件名，从其所在目录中可以得到与之对应的 $\text{i-node}$ 号，通过 $\text{i-node}$ 映射表可以查到该 $\text{i-node}$ 在磁盘上的位置，读取 $\text{i-node}$ 信息并从中找到数据块索引，进而找到相应的数据块，最终获得文件的完整内容


![[Pasted image 20241010204809.png]]

## 效率与性能

我们学习了块分配和目录管理的各种方案，那么可以讨论它们对磁盘使用的性能和效率影响

> [!hint] 
> 
> 磁盘是计算机主要部件中最慢的，磁盘往往成为系统的性能瓶颈。缓冲作为提高磁盘性能的一种手段，在 [[计算机组成：存储器层次结构]] 介绍
> 

### 效率

磁盘空间的有效使用取决于磁盘分配和目录管理算法。例如，UNIX $\text{i-node}$ 是预先分配在卷上，即使是空磁盘也有一定百分比的空间，用于存储 $\text{i-node}$ 

> [!tip] 预先分配 $\text{i-node}$ 并将他们分散在整个卷上，可以改进文件系统性能
> 
> UNIX 文件系统的分配和空闲空间管理算法试图保持一个文件的数据块考究文件的 $\text{i-node}$ 块，以便于减少寻道时间
> 

### 性能

大多数的 **磁盘控制器都包含本地内存**，形成足够大的板载高速缓存来 **同时存储整个磁道**。一旦寻道完成，就从磁头处的扇区开始将整个磁道读到磁盘缓存。然后，磁盘控制器将任何扇区请求传递给操作系统

> [!tip] 
> 
> 数据块从磁盘控制器调到内存后，操作系统可以缓存它
> 

有些系统有一块独立内存用作 **缓冲区缓存**，缓冲区中的 **块将很快再次使用**。其他系统采用 **页面缓存** 来缓存文件数据

> [!tip] 页面缓存：采用 [[操作系统：虚拟内存]] 技术，文件数据 **按页面** 缓存，而不是按文件块缓存
> 采用虚拟地址来缓存文件数据，与采用物理磁盘块来缓存相比，更为高效，因为访问接口是通过虚拟内存而不是文件系统
>  

像 Linux 和 Winodows 采用页面缓存来缓存进程页面和文件数据，这称为 **统一虚拟内存**

> [!seealso] 
> 
> [[计算机组成：存储器层次结构]] -> [[操作系统：虚拟内存]]
> 


