# 进程概念

早期的计算机一次只能执行一个程序。这种程序完全控制系统，并且访问所有资源。而现代计算机允许加载多个程序到内存中，以便于 **并发** 执行

> [!tip] 并发 Concurrency
> **一段时间内** 发生了很多事情；在这段时间的 **某个时刻**，可能只有一件事情发生

为了实现程序的并发执行，需要对程序提供 **更严格的控制** 和 **更好的划分**。这些需求促使 **_进程_** 概念的产生，即 **_进程为执行的程序_**

## 概念

在讨论操作系统时，有个问题是关于 **如何称呼所有CPU活动？**

+ 批处理系统执行 **作业**( job)
+ 分时系统使用 **用户程序**( user program) 或**任务**( task)

> [!tip] 操作系统中任何时刻都有多个正在运行的程序
> 
>即使单用户系统，用户也能同时运行多个程序：文字处理、网页浏览和电子邮件处理等
>
>即使用户一次只能执行一个程序，操作系统也需要支持本身的内部活动，如内存管理

所有这些活动在许多方面都相似，因此称为 **_进程_**(process)

关于进程的一种非正式说法：**进程是执行的程序**。现代操作系统中的 **进程不仅仅只是程序代码**，程序代码只是进程的一部分，还包含内核的数据结构。其中对于程序开发者而言最为重要的便是 **内存结构**。而现代操作系统使用 **虚拟内存** 作为内存管理工具，我们现在只需要考虑虚拟内存即可

> [!tip] 进程内存结构
> 
> 程序存储在在进程的内存结构中称为 **文本段** 的区域，该区域是 **只读的**
> 
> 在文本段之上是程序中显示初始化的数据，称为 **初始化数据段**，该部分存储了 **显示初始化** 的 _全局变量_ 和 _静态变量_
> 
> 紧接着就是成长未初始化的数据，称为 **未初始化数据段(BSS段)**，该部分存储了 **未显示初始化** 的全局变量和静态变量
> 
> 紧接着就是进程的 **堆** 区域，这个区域是在运行时为对象动态进行内存分配的一块区域，需要我们手动管理
> 
> 在间隔一片连续的内存空间之后，就是进程的 **栈**，它是一块动态增长和收缩的段，由 **_栈帧_** 组成。每当一个函数调用就会在进程的栈区域分配一个栈帧，其中存储了函数的 **局部变量**，**实参** 和 **返回值**
> 
> 栈之后又以小段区域用于存储 **命令行参数** 和 **环境变量** 区域
> 
> 最顶端的内存区域被系统 **内核** 管理，称为 **内核区域**，用户程序无法直接访问该区域的内存
> 

下图展示一个典型的进程的内存结构

![Pasted image 20241013130418|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755700888676-0975388a1ad74852b746c12312df74c1.png)

> [!tip] 程序和进程：**_程序本身不是进程_**
> 
> **程序** 只是 **被动(passive)实体**，如存储在磁盘上包含一系列指令的 **文件**(经常称为可执行文件( executable file))
> 
> **进程** 是 **活动( active)实体**，具有一个 **程序计数器** 用于表示下个执行命令和 **一组相关资源**

**当一个可执行文件被加载到内存时，这个程序就成为进程**。两个进程可以是同一个程序创建的进程。每个进程都是独立的，除了 **文本段相同** 外，**其余段均不相同**

**进程在运行时还可以创建许多进程**。进程本身可以作为一个环境，用于执行其他代码

> [!example] 进程作为执行环境
> 可执行的 Java 程序在 Java 虚拟机(JVM) 中执行。**JVM 就是一个单独的进程**，它会解释其加载的 Java 程序，并根据 Java 代码生成本机的可执行指令

**进程** 是由内核定义的抽象的实体，并为该实体 **分配用以执行程序的各项系统资源**

> [!tip] 内核眼中的进程
> 
>从内核角度看，进程由 **用户内存空间** 和 **一系列内核数据结构** 组成
>
>+ **用户内存空间** 包含了 **_程序代码_** 及 **_代码所使用的变量_**
>+ **内核数据结构** 则用于维护 _进程状态信息_
>
> 用于表示进程的内核数据结构称为 **进程控制块**(Process Control Block, **PCB**)，通常包含下面几类数据
> + **进程标识(PID)**：程序中控制进程使用的标识符，一个整数
> + **虚拟内存表(内存管理信息)**：系统使用的内存系统信息。这类信息可以包括 _基地址_ 和 _界限寄存器的值_、_页表_ 或 _段表_
> + **进程资源使用及其限制**
> + **当前工作目录**
> + **信号传递及其处理的信息**
> + **程序计数器**：指向进程下一条要执行的指令
> + **CPU 寄存器**：进程使用的寄存器中的指
> + **CPU 调度信息(进程状态)**：包括进程优先级、调度队列的指针及其他调度参数
> + **程序的记账**：CPU时间、实际时间、进程数量等
> + **IO状态**：分配给进程的 _IO 设备列表_ 和 _打开文件列表_
> 
>**内核眼中进就是 PCB 和用户内存空间的合集**
>

## 状态

进程在执行时会改变 **状态**。进程状态，部分取决于进程的当前活动。每个进程可能处于以下状态:

+ **新的**(new)：进程正在创建

+ **运行**(running)： 指令正在执行

+ **等待(阻塞)**(waiting)： 进程等待发生某个事件(如I/O完成或收到信号)

+ **就绪**(ready)：进程等待分配处理器

+ **终止**(terminated)： 进程已经完成执行

这些状态名称比较随意，而且随着操作系统的不同而有所不同。不过，它们表示的状态在所有系统上都会出现。有的系统对进程状态定义的更细。重要的是要认识到: 一次只有一个进程可在一个处理器上 **运行**；但是许多进程可处于 **就绪** 或 **等待** 状态。下图显示了一个进程的状态图

![[Pasted image 20241022001020.png]]

> [!tip] 理解进程状态变化：以小车过桥为例
> 假设有许多小车需要过一条单车道的桥梁。这个 **桥梁就相当于 CPU**，**车就相当于进程**。只有进程获得 CPU 它才能处于运行状态。
> 
> 在桥的两端，有工作人员，控制车何时到桥上。这个 **工作人员就相当于调度器**
> 
> 当车到达桥梁口，此时车(进程)就处于就绪状态
> 
> 当工作人员(调度器)放车上桥(进程被调度)，此时车(进程)就处于运行状态
> 
> 当车离开桥之后，此时车通过桥梁完成(进程结束)，此时进程就处于终止状态
> 
> 如果车在桥上发生车祸或者故障(IO等状态)，此时车(进程)需要等待被救援，此时就处于等待状态。如果等待状态的进程占用 CPU ，此时整个进程被阻塞，从而影响其他进程的执行。因此，需要调度器帮助，让进程让出 CPU。这里，可以理解为工作人员将故障的车移出了桥梁
> 
> 工作人员(调度器)完成对车的救援之后，车又可以进行到桥梁上通行，此时车又处于就绪状态，等待工作人员放行
> 
