# 文件系统

## 文件概念

**文件** 是内核对 **存储设备** 的物理属性加以抽象，从而定义 **逻辑存储单位**

> [!tip]
> 
> 计算机在各种存储介质上存储信息，为了便于使用这些信息，**内核提供了信息存储的统一逻辑视图**，即 **文件**
> 
> 文件由内核映射到物理存储设备上，这些存储设备是非易失性的，因此这些信息可以持久化
> 

从用户角度来看，文件是逻辑外存的最小分配单元；也就是说，数据只能通过文件才能写入外存

> [!tip] 现代计算机中的文件表示 **程序** 和 **数据**
> 
> 数据文件可以是任意形式的。通常，文件是字节序列，起含义由文件创建者和用户定义
> 

文件信息由创建者定义。文件可以存储许多不同的类型信息。根据文件具有某种定义的结构，可以为文件进行分类

| 文件类型  | 描述                    |
| :---- | :-------------------- |
| 文本文件  | 按行组织的字节序列，这些字节序列是字符编码 |
| 源文件   | 函数序列                  |
| 可执行文件 | 可以在到内存并执行             |

### 文件属性

文件被命名以方便人类用户，并通过文件名引用。**文件名通常是字符串**，例如 `example.c`。**当文件被命名后，它就独立于进程和用户**，甚至是创建它的系统

> [!tip] 文件名是否区分大小写取决于系统
> 
> 有些系统区分名称的大小写字符，例如，Linux
> 
> 有些系统则不区分，例如，Windows
> 

> [!example] 文件命名后就独立了出来
> 
> + 一个用户创建文件 `example.c`，另一个用户可以通过 `example.c` 编辑该文件
> + 文件所有者可以将文件拷贝到其他设备上，甚至通过网络发送出去
> 

文件的属性因操作系统不同而不同，但是通常都包括

> [!tip] 通用文件属性
> + **名称**：符号文件名，以人类可读保存的唯一信息
> + **标识符**：唯一标记，标识文件系统的文件
> + **类型**：文件内容的结构
> + **位置**：指向设备与设备上文件位置的指针
> + **尺寸**：当前文件大小以及可能的最大值
> + **保护**：访问控制信息
> + **时间**：创建时间，访问时间，修改时间
> + **用户标识**：UID GID 等
> 

### 文件操作

文件为抽象数据类型，为了正确定义文件，需要考虑对文件执行的操作

> [!tip] 内核提供的文件操作
> + **创建文件**：首先，在文件系统中为文件找到空间；其次，在目录中创建新文件的条目
> + **写文件**：将信息写入文件。系统应该保留 **写指针**，即下一次写操作的文件位置
> + **读文件**：将信息从文件读入到进程。系统应该保留 **读指针**，即下一次读操作的文件位置 
> + **重新定位文件**：搜索目录寻找适当的条目，并将当前文件位置指针重新定位到给定值
> + **删除文件**：通过文件名找到关联的目录条目后，释放所有文件空间
> + **截断文件**：删除内容，但是保留属性
>
> 这 $6$ 个操作是文件的基本操作。由于进程通常从文件读取或写入，所以当前操作位置可以作为 **进程的 _当前文件指针_**，读写操作都使用同样的指针，可以节省空间并降低系统复杂性
> 

上述文件操作涉及搜索目录，以得到命名文件的相关条目。为了避免这种不断的搜索，内核要求在首次使用文件之前进行系统调用 `open()`。操作系统有一个 **打开文件表** 用于维护所有打开文件的信息

> [!tip] 
> 
> 当请求文件操作是，通过 **打开文件表的索引** 指定文件，而不是搜索目录
> 
> 当文件不再使用是，进程关闭它，操作系统从打开文件表中删除它的条目
> 

某些操作系统在首次引用文件时，会自动打开文件；当打开文件的进程结束时，会自动关闭文件

对于 **多个进程可以同时打开文件** 的环境，操作 `open()` 和 `close()` 的实现更加复杂。通常，操作系统采用 **两级内部表**：**文件描述符表** 和 **打开文件表**

> [!tip] 文件描述符表
> 
> 文件描述符表也称 **每个进程表**，它跟踪进程打开的所有文件； **存储进程对文件的使用信息**
> 
> + 每个文件的当前文件指针
> + 文件访问权限
> + 记账信息
> 

> [!tip] 打开文件表
> 
> 内核维护了一个管理所有打开文件的表。进程的文件描述符表中的每个条目相应的指向内核中的打开文件表
> 
> 打开文件表 **存储量与进程无关的信息**
> + 文件在磁盘上的为位置
> + 访问时间
> + 尺寸
> + ....
> 
> 一旦有个进程打开了一个文件，打开文件表就包含了该文件的条目。当另一个进程指向 `open()` 系统调用时，只需要简单的在其进程的文件描述符表中增加一个条目，并指向相应的打开文件表中的条目
> 
> 打开文件表会为每个文件关联一个 **打开计数**，用于表示有多少个进程打开了这个文件
> 
> 调用 `close()` 时，递减打开计数；当打开计数为 $0$ 时，表示不再需要该文件，此时内核才会从打开文件表中删除该文件的条目
> 

由于多个进程可以同时打开文件，如果有多个进程打开同一个文件，那么文件的访问和写入就会出现 **竞争**，从而导致数据出现混乱。有些操作系统提供了 **文件锁**，允许进程锁定文件，防止其他进程访问它

### 文件类型

下表列出了文件系统支持的常见文件类型

![Pasted image 20241009233259|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755705373155-203840ce4e30427f9408f3b0430df86a.png)

> [!tip] 文件类型可用于指示文件结构

## 访问方法

文件存储信息。当需要使用时，就必须访问文件中的内容，并将其读入计算机内存中。文件信息可以按照多种方式访问

### 顺序访问

**顺序访问** 文件是最简单的访问方法。文件信息按顺序处理，即：一个记录接着一个记录处理

读写操作构成了文件的大部分操作

> [!tip] 读操作：`read_next()`
> 
> 读取文件的下一部分，并自动前移进程的当前文件指针以便于跟踪 IO
> 

> [!tip] 写操作：`write_next()`
> 
> 在文件末尾附加内容，并将进程的当前文件指针移动到新的文件末尾
> 

下图描述了顺序访问：这是基于磁带模型；不但适用于顺序访问设备，也适用于随机访问设备

![Pasted image 20241009234052|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755705373157-3bd871e24b824216a9f4ffc63f9b9f0e.png)

### 直接访问

直接访问，也称相对访问。为了支持随机访问，文件由 **固定长度的块** 组成，以允许程序按任意顺序进行快速的读取和写入

对于直接访问，必须修改文件操作以便于包括 **块号** 作为参数

> [!tip] 读操作：`read(n)`
> 
> 从块号 $n$ 开始读取数据
> 

> [!tip] 写操作：`write(n)`
> 
> 将数据写入块号 $n$ 
> 

直接访问也可能保留 `read_next()` 和 `write_next()` 支持顺序访问；并增加 `position_file(n)` 操作将指针移动到块号 $n$ 的位置，从而实现 `read(n)` 和 `write(n)`

> [!hint] 
> 
> 现代操作系统大多数都是采用 `position_file(n)` 的方式实现直接访问
> 

用户给内核提供的块号通常为 **相对块号**，即 **相对于文件开头的索引**

## 目录

### 树形目录

**树形目录是最常见的目录结构**，有一个根目录，系内的每个文件都有唯一的路径名。如下图所示，就是树形目录的一个示例

![Pasted image 20241009234757|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755705373157-fc5c689125ef47c49ec4a340c7c5f671.png)

> [!important] **目录包括一组文件或子目录**
> 
> 目录本质上也是一个文件，只是他的处理方式不同罢了。所有的目录具有相同的内部格式。每个目录条目都对应有一位来将条目定义为 文件($0$) 或 子目录($1$)
> 

每个进程都有一个 **当前目录**，即进程运行时的工作目录，包括了进程当前感兴趣的绝大分文件

> [!tip] 
> 
> 引用一个文件时，就搜索当前目录。如果需要的文件不再当前目录中，那么用户需要指定文件所在的 **路径名**
> 

路径名有两种形式：**绝对路径** 和 **相对路径**。绝对路径从根开始，遵循一个路径到指定文件，并给出路径上的目录名。相对路径从当前目录开始，定义一个路径

> [!example] **绝对路径** 和 **相对路径**
> 
> 如果当前目录为 `root/spell/mail`，则相对路径 `ptr/first`与绝对路径`root/spell/mail/prt/first` 指向同一个文件
> 

### 无环图目录


**树形目录是 _禁止共享_ 文件或目录**。为了共享文件和目录，采用下图所示的 **无环图目录**

![Pasted image 20241009235914|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755705373158-fe1841e1865c43d5b7f4b8e5cfb07aed.png)

> [!tip] 
> 
> 对于一个共享文件，只存在一个实际文件，因此其他用户对文件的操作，另外的用户都能看见
> 

共享文件和目录的实现方法之一就是 **链接**，本质上是另一个文件或子目录的指针

> [!tip] 链接可以使用相对路径，也可以使用绝对路径
> 
> 当应用一个文件时，搜索目录，如果目录条目标记为链接，则真是文件名称包括在链接信息中。通过链接的路径名来 **解析** 链接，定位真实文件
> 

如何删除共享文件呢？如果 **有用户删除就删除它**；则会留下悬空指针，以指向现在不存在的文件。当被删除的空间重新分配给其他文件是，悬空指针可能指向其他文件

通过链接实现的共享，删除链接不会影响原始文件；如果原始文件被删除，文件空间就被释放量，链接悬空

> [!tip] 悬空链接不会有任何影响
> 
> 链接保存的只是另一个文件的路径名，原始文件被删除后，它的路径名处于无效状态
> 

另一种删除文件的方式是保留原始文件，直到他的引用都被删除。通常，为每个文件保留一个 **引用列表**。当创目录条目的链接或者副本时，就会向文件引用列表添加一个新条目。当删除链接或目录条目时，会从列表中删除它。当文件引用列表为空时，就会删除该文件

一种更简单的实现就是采用 **引用计数** 。添加新的链接或目录条目，就会增加引用技术。删除链接或目录条目，就会减少引用计数。当引用计数为 $0$ 时，就会删除文件

> [!example] 
> 
> 引用计数机制是 Unix/Linux 系统中的 **硬链接** 采用的机制，在 **i-node** 中有引用计数
> 

## 保护

信息存储在计算机系统中时，需要保护它的安全，以避免 **物理损坏** 和 **非法访问**

> [!tip] 避免物理损坏：可靠性问题
> 
> 通常，通过 **创建文件副本** 来提供文件的可靠性
> 

> [!tip] 避免非法访问：保护文件内容
> 
### 访问类型

需要保护文件是能访问文件的直接结果。不允许访问其他用户文件的系统是不需要保护的

> [!tip] 
> 
> 禁止访问提供完全保护；不加任何保护提供完全自由访问
> 

通过限制可以进行的文件访问类型，提供受控访问的保护机制。访问的允许和拒绝取决于多个因素，其中之一就是 **访问类型**

> [!tip] 访问类型
> 
> + **读**：从文件中读取
> 	+ 获取文件属性
> + **写**：写入或重写文件
> 	+ 追加
> 	+ 删除
> + **执行**：加载文件到内存并执行它
> 

最基本的访问类型分为三种：**读** **写** 和 **执行**

### 访问控制

最常见的访问控制方法是，**根据用户身份控制访问**。不同的用户需要不同类型的文件或目录访问。基于身份访问的最为普通的实现方法是，为每个文件和目录管理一个 **访问控制列表**，以指定每个用户的名称及其允许的访问类型

为了精简访问列表，许多系统为每个文件采用三种用户类型：**所有者** **组** **其他**

> [!tip] 
> 
> 所有者：创建文件的用户
> 
> 组：需要类似访问的一组用户，通常与所有者一组的用户
> 
> 其他：系统内的所有其他用户
> 
