# 数据结构

数据结构的概念我们在之前就已经介绍过来。这里我们不会在多做赘述，只会进行简单介绍后就开始实现各种数据结构。

## 线性表

在 [[数据结构：线性表]] 中我们详细介绍了线性表的概念，并且使用 C 语言实现了一个简单单链表。下面我们复习一下线性表的核心概念并使用 Go 语言实现

**线性表**，顾名思义，就是 **具有像线一样的性质的序列**。数学符号的记法如下：线性表记为 $(a_1,a_2,\cdots, a_n)$，则表中 $a_{i-1}$ 领先于 $a_i$，称 $a_{i-1}$ 是 $a_i$ 的 **直接前驱元素**，当然，$a_i$ 领先于 $a_{i+1}$ ，称 $a_{i+1}$ 是 $_{i}$ 的 **直接后继元素**

![[Pasted image 20240930214647.png]]

> [!tip] 
> 
> 线性表的元素个数 $n(n \ge 0)$ 称为 **线性表的长度**，当 $n=0$ 是称为 **空表**。在 **非空表中的每个元素都有一个确定的位置**
> 

> [!important] 逻辑结构 与 物理结构
> 
> 线性表是一种 **逻辑结构**。后续我们所谓的数据结构都是逻辑结构。当线性表中的元素存储在物理内存上时，在内存上存储的结构称为 **物理结构**。有两种常用的物理结构
> + 顺序结构：元素存储在一片连续的内存空间中
> + 链式结构：元素以结点的形式在内存中分散存储，每个结点可以找到它之后的结点
> 

线性表的顺序存储结构实现，即 **顺序表**，其插入和删除都需要找到插入位置和删除的位置，这是无法避免的开销。然而，**插入之前需要移动元素**，将插入位置空出来；**删除之后需要移动元素填充被移出的元素空闲位置**。这些开销是不必要的

为了避免插入之前和删除之后移动元素带来的开销，我们允许表的数据元素可以 **不连续存储**，这样就避免插入之前和删除之后带来的元素移动性能损耗。下图是 **链表** 的描述

![[Pasted image 20240930215041.png]]

### 单向链表

下面我以单向链表为例，探究线性表的实现。回忆一下我们介绍的数组

```go
var arr [5]int  // 数组 [5]int 代表数组类型，而 int 代表元素类型
```

> [!tip] 
> 
> 数组就一个容器，容纳指定类型的元素
> 

链表需要将元素和下一个元素的地址存储在一起，这种包含元素和下一个元素的结构称为 **节点**。

```go
type Node struct {
	value *Type
	next *Node
}
```

> [!attention] 
> 
> 注意：`Type` 只是一个标记，
> 

我们实现一个单向链表时，链表需要 **记录开始节点** 的位置(`head`)；为了方便尾部操作，我们还需要 **记录尾部节点** 的位置(`tail`)；最后，我们需要记录容器中 **元素的个数**(`size`)。

```go
type List struct {
	head *Node  // 指向头节点
	tail *Node  // 指向尾节点
	size int    // 元素的个数
}
```

如下图，展示了链表 `list` 的结构

![[Pasted image 20241001075640.png]]

做容器的链表应该支持下表列出来的基本操作，并且将一一实现这些操作

| 操作  | 描述             |
| :-- | :------------- |
| 插入  | 将元素放入容器中       |
| 删除  | 将元素从容器中移除      |
| 修改  | 将某个位置的元素修改为指定值 |
| 查找  | 找到元素所在容器中的位置   |
| 遍历  | 访问容器中的所有元素     |

> [!attention] 
> 
> 为了让链表可以存储任意类型的数据，我们采用泛型实现
> 

为了隐藏具体实现，我们还需要定义一个接口，这些接口定义了链表需要实现的方法

```go
// List is a generic linked list interface.
// It defines the methods that a linked list should implement.
type List[T any] interface {
}
```

#### 构造函数

为了让其他代码使用链表，我们需要定义一个构造函数 `New[T any]()`，这个函数返回一个 `List[T]` 类型的指针

```go
package list

type node[T any] struct {
	value T
	next  *node[T]
}

// List is a generic linked list interface.
// It defines the methods that a linked list should implement.
type List[T any] interface {
}

type list[T any] struct {
	head *node[T]
	tail *node[T]
	size int
}

func New[T any]() List[T] {
	return &list[T]{
		head: nil,
		tail: nil,
		size: 0,
	}
}
```

#### 插入

为了将元素插入链表，我们需要指定插入位置和插入的元素，即方法 `Insert(index, value)` 将 `value` 插入到 `index` 指定的位置。为了方便链式调用，我们让 `Insert()` 将容器的指针返回

为了需要从第一个结点开始遍历，找到指定索引的位置。这里，需要记录前一个结点(`pre`)。当找到插入位置后

> [!tip] 插入操作
> + 首先，让新结点(`new`) 的 `next` 指向当前结点(`cur`)
> + 然后，让`pre` 的 `next` 指向新结点

![[Pasted image 20241001082400.png]]

> [!attention] 
> 
> 特殊情况：**插入结点时链表为空**
> 
> ![[Pasted image 20241001080057.png]]
> 

> [!attention] 
> 
> 特殊情况：**插入结点作为新的尾节点**
> 
> ![[Pasted image 20241001081144.png]]
> 

> [!attention] 
> 
> 特殊情况：**插入结点作为新的第一个结点**
> 
> ![[Pasted image 20241001082450.png]]
> 

```go
func (l *list[T]) Len() int {
	return l.size
}

func (l *list[T]) Insert(index int, value T) List[T] {
	newNode := &node[T]{
		value: value,
		next:  nil,
	}

	// 如果链表为空
	if l.size == 0 {
		l.head = newNode
		l.tail = newNode
	} else {
		// 插入位置小于或等于 0，即在链表头部插入
		if index <= 0 {
			newNode.next = l.head
			l.head = newNode
		} else if index >= l.Len() {
			// 插入位置大于或等于链表长度，即在链表末尾插入
			l.tail.next = newNode
			l.tail = newNode
		} else {
			// 在链表中间位置插入
			current := l.head
			previous := (*node[T])(nil)
			for i := 0; i < index && current != nil; i++ {
				previous = current
				current = current.next
			}
			newNode.next = current
			previous.next = newNode
		}
	}
	l.size++
	return l
}
```

链表表的一种常用的操作就是在链表末尾添加一个元素，由于我们记录最后一个节点的位置，因此这个操作实现起来就会非常简单

```go
func (l *list[T]) Append(value T) List[T] {
	newNode := &node[T]{
		value: value,
		next:  nil,
	}

	// 如果链表为空，直接将新节点设置为头和尾
	if l.size == 0 {
		l.head = newNode
		l.tail = newNode
	} else {
		// 将新节点添加到链表末尾
		l.tail.next = newNode
		l.tail = newNode
	}
	l.size++
	return l
}
```

#### 遍历

遍历链表也是一种常用操作，这里我们以 **迭代模式** 实现。Go1.23 开始支持迭代器

```go
func (l *list[T]) Iter() iter.Seq[T] {
	return func(yield func(value T) bool) {
		current := l.head
		for current != nil {
			if !yield(current.value) {
				return
			}
			current = current.next
		}
	}
}
```

#### 删除

删除元素有两种方式：按元素删除和按索引删除。但是，删除操作却是一样的

![[Pasted image 20241001094209.png]]

当需要删除元素时，需要从头开始遍历，比较每个结点的 `value`，需要记录上一个结点，当找到 `value` 所在的结点，即可直接删除。注意特殊位置：删除第一个结点需要修改 `head`；删除最后一个结点需要修改 `tail`

```go
func (l *list[T]) Remove(value T) List[T] {
	if l.size == 0 {
		return l
	}

	var previous *node[T]
	current := l.head

	for current != nil {
		if reflect.DeepEqual(current.value, value) {
			// 如果是头节点
			if previous == nil {
				l.head = current.next
				if l.head == nil { // 如果链表变为空
					l.tail = nil
				}
			} else {
				previous.next = current.next
				if previous.next == nil { // 如果删除的是尾节点
					l.tail = previous
				}
			}
			l.size--
			return l // 找到并删除后，返回链表
		}
		previous = current
		current = current.next
	}
	return l // 如果没有找到值，则返回原链表
}
```

### 双链表

在实现链表的 `Pop` 和 `Remove` 函数时，我们发现了一个问题：当我们需要删除最后一个结点时，需要从第一个结点开始遍历，查找到最后一个结点的前一个结点。这个问题导致我们在链表尾部删除元素时的时间复杂度变为 $O(n)$。为了解决该问题，我们让每个结点多存储一个**指针**，这个指针 **指向了该结点的上一个结点**

![[Pasted image 20241001103742.png]]

## 栈和队列

在 [[数据结构：栈和队列]] 中介绍了栈和队列的概念。下面我们复习一下，然后使用 Go 语言实现

> [!tip] 
> 
> 栈和队列本身就是一个线性表，只是操作受到了限制
> 
> + **_栈_**：_插入_ 和 _删除_ 操作被限制 **_在同一端_**
> + **_队列_**：_插入_ 和 _删除_ 操作分别被限制 **_在不同的两端_**

### 栈

栈的插入操作被称为 **入栈**；删除操作被称为 **出栈**。下图描述了栈的这两个基本操作

![[Pasted image 20241001140104.png]]

> [!tip] 栈顶和栈底
> 
> + 允许插入和删除的一端称为 **栈顶**(`top`)
> + 不允许插入和删除的一端称为 **栈底**
> 

### 队列

队列也是线性表，然而，使用队列时 **_插入在一端进行_** 而 **_删除则在另一端进行_**

> [!tip] 
> 插入也成为 **入队**；删除称为 **出队**

队列由于其插入在一端而删除在另一端，中导致了先进入的元素会先被删除。所以 **队列** 是一个 **_先进先出(First In First Out, FIFO)_** 线性表
    
> [!tip]
> 允许插入的一端称为 **队尾**；允许删除的一端称为 **队头**

![[Pasted image 20241001140341.png]]

#### 环形队列

使用顺序存储结构实现队列时，为了避免移动元素，我们 **只是改变队头和队尾指针** 的指向。开始时，队尾指针(`rear`) 和队头指针(`front`) 指向第一个插入位置。如下图，这是一个空队列

![[Pasted image 20241001140433.png]]

> [!tip] 队列为空的条件
> 
> 当 **队尾指针与队头指针相等** 时，队列为空：
> 
> $$
> \text{rear} == \text{front}
> $$

首先，连续有 $3$ 元素入队之后的状态图

![[Pasted image 20241001140456.png]]


> [!tip] 队列中的元素个数的计算
> 
> 显然，队列元素个数计算方法如下：
> 
> $$
> \text{rear} - \text{front} 
> $$

> [!tip] 队列为满队的条件
> 
> 显然，当 `rear-front == size` 时，队列就是满队的情形
> 

然后，连续出队 $2$ 个元素之后的状态图

![[Pasted image 20241001140532.png]]

> [!hint] 
> 
> 队尾指针(`rear`)始终指向**待插入位置**，队头指针(`front`)始终指向 **待删除位置**
> 

现在，再连续入队 $5$ 个元素之后的状态图

![[Pasted image 20241001140607.png]]

> [!tip] 假溢出
> 
> 显然，此时队列尚未被填满，但是无法再次入队，因为 `rear` 指向的位置不再队列管理的区域内了，即底层数组会产生越界访问错误。这种现象被称为 **假溢出**
> 

为了解决队列的假溢出现象，当 `rear` 指向了最后一个位置时，让指向第一个插入位置。这种首尾相接的队列成为 **环形队列**

![[Pasted image 20241001140651.png]]

> [!tip] 环形队列
> 
> 我们让队尾指针和队头指针再次回到起始位置，这样就形成了一个环形队列：如何回到起始位置呢？
> + 模运算：`rear = (rear + 1) % size`。`front` 作同样的操作
> + 重置：如果 `rear + 1 >= size`，则 `rear` 重置为 `0`。`front` 作同样的操作
> 
> 模运算相比于加法更耗时，建议选择重置方案
> 
> 如果 `size` 的为 $2^n$，我们可以使用位与替换模运算，以提高执行效率，`rear` 和 `front` 的修改改为
> + `rear = (rear + 1) & (size - 1)`
> + `front = (front + 1) & (size - 1)`

> [!hint] 使用 **位与** 替代模运算
> 使用 _位与_ 替代取模运算效率高，但位与 _只能在特定场景下_ 才能替代 `%` 运算
> 
> 正常情况下 
> 
> ```go
> a % b = a - (a / b) * b
> ```
> 
> 但是，如果 $b=2^n$ 时，就可以使用位与替代模运算
> 
> ```go
> a % b = a & (b-1)
> ```
> $2^n$ 的位模式只有第 `n` 位上才为 `1`。例如，$2^3$ 的位模式为 `1000`。因为 `0 <= a % b <= b-1`，如果 $b=2^n$，那么就可以使用为位与(`&`)替换，模运算 `%`
> 
> ```go
> 11 % 8 = 11 & (8-1)
> ```
> 
> `11` 的位模式为 `1011`，而 `7` 的位模式为 `0111`，所以 `11 & 7 = 1011 & 0111 = 0011 = 3`  
> 

将队列变为环形队列之后，判定为空的条件是不变，即 `rear == front` 时，队列为空。然而，队列和时是满队的呢？

让我们继续入队两个元素，此时队列处于满队状态，`rear == front`。然而，队空也是 `rear == front`，这导致我们无法区分满队和队空状态。

![[Pasted image 20241001140839.png]]

> [!tip] 标志位法：**标志位** 记录上一次执行的是 **入队** 还是 **出队** 操作
> 
> 为了判断队列处于满队状态，设置一个标识 `flag`，用于记录上一次执行的操作是入队还是出队：`true` 表示上一次执行入队；`false` 表示上一次执行的操作是出队
> + 队列为空队的检查条件为 `rear == front && flag == false` 
> + 队列为满队的检查条件为 `rear == front && flag == true`
> 
> 标志位法可以保证底层数组完全用于存放数据元素
> 

不引入其他的变量，可以 **让底层数组留出一个空位**。空队条件不变，即 `rear == front`。由于留出了一个空位，当 `(rear + 1) % szie == front` 时，队列就时满队状态了

![[Pasted image 20241001140944.png]]

> [!tip] 
> 底层数组留出一个空位：队列处于满队状态时，底层数组还存在一个空闲位置
> 

队列中元素的个数如何计算呢？由于指针会绕行一周，因此队列元素个数的计算规则有所改变：`(rear-front + size) % size` 就算队列的元素个数。这个公式是通用的

> [!question] 特殊问题：在使用标志位判断队列状态时，这个公式在满队情形下失效
> 
> 由于 `rear == front`，所以 `size & (size - 1) == 0`。对于满队情形，应该进行特殊判定
> 

## 树

对于大量的输入数据，链表的线性访问效率太低了，不宜使用。下面我们将学习的数据结构是 **树**，它的大部分操作的平均运行时间为 $O(\log N)$

**树** 最常见的定义方式采用 **递归** 定义：一棵树就是一些节点的 **集合**。
+ 集合可以是空集，称树为 **空树**
+ 集合非空，则一棵树由称作 **根(root)** 的节点，以及 $0$ 个或多个非空子树组成。这些子树的根被来自 **root** 的有向边连接

子树的根称为 **root** 的 **儿子(_子节点_)**，**root** 称为子树的 **父亲(_父节点_)**

> [!tip]
> 
> 一棵树是由 $N$ 各节点和 $N-1$ 条边的集合，其中一个节点叫作根
> 
> 存在 $N-1$ 条边，这是因为每条边都将某个节点连接到它的父节点，只有 **root** 节点没有父节点
> 

下图就是一个典型的树。节点 A 是 **root 节点**。节点 F 的父节点是 A 并且有子节点 K L M。**每个结点 _至少有零个子节点_**，没有子节点的结点称为 **树叶(_叶子节点_)**。

![[Pasted image 20241001193706.png]]

具有相同父节点的节点称为 **兄弟节点**。从节点 $n_1$ 到 $n_k$ 的 **路径** 定义为节点序列: $n_1, n_2, \cdots, n_k$，其中 $n_i$ 是 $n_{i+1}$ 的父节点。**路径长** 为 _该路径上边的条数_，即 $k-1$。节点 $n_i$ 的 **深度** 为从 _root节点 到 $n_i$ 的唯一路径长_。节点 $n_i$ 的 **高度** 是 _从 $n_i$ 到叶子节点的最长路径长_

实现树的一种方法可以在每个节点中存储它子树的指针。然而，节点的子树数量是 **不固定** 的且事先 **不可知** 的，可能会造成空间的浪费。解决方法：**将每个结点的所有儿子都放在树结点链表中**。也就是说，按照如下方式存储

![[Pasted image 20241001193948.png]]

> [!tip]
> + `firstChild`：表示第一个孩子
> + `nextSibling`：表示下一个兄弟
> 

上图中表示的树可以按照如下方式存储

![[Pasted image 20241001194027.png]]

## 二叉树

**二叉树** 是一棵树，其中 **每个节点的 _子节点至多两个_**。下图是一个典型的二叉树

![[Pasted image 20241001194327.png]]

> [!tip] 
> 
> 二叉树要求 **节点的左右子树是有顺序的**，次序不能任意颠倒。树中的某节点只有一棵子树，也要区分子树是左子树还是右子树
> 

### 满二叉树

所谓 **满二叉树** 是指所有 **_叶子节点都在同一层_**，即 **所有叶子节点的深度相同**
+ 叶子节点只出现在最下面一层
+ 非叶子节点一定有两棵子树

![[Pasted image 20241001194412.png]]

### 完全二叉树

所谓 **完全二叉树** 是指所有 **_叶子节点只能出现在最后两层_**，并且 **如果节点 _只有一棵子树_，那么这棵子树 _一定是左子树_

![[Pasted image 20241001194428.png]]

### 二叉树的存储

#### 顺序存储

二叉树的顺序存储就是将二叉树的节点按 **从上到下**，**从左到右**，依次存放在一片连续的存储空间中（即：使用 **顺序表存储**），如果一个 _内部节点_ 的子树少于 $2$，则空缺的子树在顺序表需要存储一个哑节点。

下图展示了一般二叉树的顺序存储

![[Pasted image 20241001194503.png]]

这样每个节点都会有一个索引，这个索引将作为节点编号使用。显然，**一般二叉树采用顺序存储会造成严重的空间浪费**

> [!tip] 二叉树顺序存储通常用于存储 **完全二叉树**
> 

![[Pasted image 20241001194533.png]]

通过编号，我们就可以很容易找到节点的父节点和子节点。

> [!tip] 完全二叉树顺序存储的重要结论。这里将是实现 **[[数据结构：优先队列#二叉堆]]** 的基础
> 如果一棵完全二叉树有 $n$ 个节点。每个节点按从上到下，从左到右进行编号。任意一个节点的编号为 $i, 1 \le i]\le n$，则
> + 如果 $i=1$，则节点 $i$ 是 **root节点**
> + 如果 $i \gt 1$，则节点 $i$ 的父节点是节点 $\lfloor \frac{i}{2} \rfloor$
> + 如果 $2i \gt n$，则节点 $i$ 无左孩子；否则其左孩子是节点 $2i$
> + 如果 $2i+1 \gt n$，则节点 $i$ 无右孩子；否则其右孩子是节点 $2i+1$
> 

#### 链式存储

一棵二叉树最多有两个儿子，所以我们可以使用指针直接指向它们。也就是说，每个树节点的类似于双链表

![[Pasted image 20241001194636.png]]

> [!tip]
> + `left` 指向该节点的左子树
> + `right` 只想该节点的右子树

### 遍历

二叉树的遍历就是从根出发，按照某种 **次序** 依次访问二叉树中的所有节点，使得每个节点被访问且只访问一次

> [!tip] 二叉树的遍历有两个方面内容：**访问** 和 **次序**
> + 访问：根据需求确定要对节点中的数据做什么操作。例如，计算，输出
> + 次序：访问根节点、左子节点、有子节点的顺序

二叉树的遍历方法有很多种，这里介绍主要使用的 $3$ 种，它们 **根据 root 节点的访问次序** 进行划分的。通过遍历下图所示的二叉树，介绍这三种算法

![[Pasted image 20241001195641.png]]

#### 前序变量

二叉树的前序遍历按照如下顺序进行
+ 如果二叉树为空，则直接返回
+ 否则，先访问 root节点，再访问左子树，最后访问右子树

> [!tip] 前序遍历的节点访问顺序：**root ==> 左子树 ==> 右子树**

下图虚线箭头显示该二叉树的前序遍历：`ABDGHICEJF`

![[Pasted image 20241001195706.png]]

#### 中序遍历

二叉树的中序遍历按照如下顺序进行
+ 如果二叉树为空，则直接返回
+ 否则，先访问左子树 ，再访问root节点，最后访问右子树

> [!tip] 中序遍历的节点访问顺序：**左子树 ==> root ==> 右子树**

下图虚线箭头显示该二叉树的前序遍历：`GDIHBAEJCF`

![[Pasted image 20241001195758.png]]

#### 后序遍历

二叉树的后序遍历按照如下顺序进行
+ 如果二叉树为空，则直接返回
+ 否则，先访问左子树 ，再访问右子树，最后访问root节点

> [!tip] 中序遍历的节点访问顺序：**左子树 ==> 右子树 ==> root**

下图虚线箭头显示该二叉树的前序遍历：`GIHDBJEFCA`

![[Pasted image 20241001195817.png]]

#### 层序遍历

该技术 **使用队列** 数据结构来 **记住探索下一个顶点或节点**，并且将探索通向该顶点的每一条边，这确保了发现从源可到达的每个顶点。下图虚线箭头描述了层序遍历的访问顺序

![[Pasted image 20241001195903.png]]

## 优先队列

让我们来看一个新的数据结构，它被称为 **_优先队列_**，也叫 **_堆_**。堆的应用有多种，比如，多用户系统环境中，操作系统调度程序必须决定在若干进程中运行那个进程。有些进程非常短，能够迅速执行完毕，那么调度器就应该优先处理这样的程序

优先队列至少运行 `Insert()` 和 `DeleteMin()` 两个操作

> [!tip]
> 
> + `Insert()` 插入一个元素。类似于队列的入队
> + `DeleteMin()` 删除优先队列中的最小值，类似与队列的出队
> 

![[Pasted image 20241002204320.png]]

> [!attention] 
> 
> 详细内容参考 [[数据结构：优先队列]]
> 

### 二叉堆

优先队列的最为简单的实现就是 **_二叉堆_**，这是优先队列的最常用实现，以至于不加任何说明时，术语 **堆** 都指代的是 **二叉堆**

> [!tip] 
> 
> 二叉堆是堆数据结构的最常用实现。术语 **堆** 不加任何修饰时一般都是指代二叉堆
> 

堆和二叉查找树一样具有两个性质，**结构性** 和 **堆序性**。

#### 结构性

堆被设计称一颗 [[数据结构：树与二叉树#满二叉树与完全二叉树|完全二叉树]]。一颗高度为 $h$ 的完全二叉树最多有 $2^{h+1}-1$ 个节点，最少有 $2^h$ 个 节点。这意味着，安全二叉树的高度是 $\lfloor \log N \rfloor$，显然他是 $O(\log N)$。我们在 [[数据结构：树与二叉树]] 中分析，完全二叉树可以方便的存储在一个序列中

下图显示了一颗高度为 $3$ 的完全二叉树就可以如下存储

![[Pasted image 20241002204423.png]]

> [!tip] 节点之间的关系
> 对于序列中的任意位置 $i$ 上的元素，其左儿子在位置 $2i$，右儿子在左儿子后的单元 $(2i+1)$ 中，它的父亲则在位置 $\lfloor i/2 \rfloor$
> 

> [!tip] 
> 
> 采用序列实现避免使用指针，并且遍历树时需要的操作及其简单，在大部分计算机上可以运行的非常快
> 
> 缺点：**需要预估节点的数目**
> 

> [!tip]
> 
> 显然，一个典型的堆是由一个**序列**、一个代表 **序列容量** 的整数以及 **当前堆的大小**
> 

#### 堆序性

使堆操作快速执行的性质是堆序性。

> [!tip] 小根堆
> 如果想要快速找出最小值，那么最小元应该在根上。如果我们将任意子树也视为一个堆，那么 **任意节点就应该小于它的所有后裔**
> 
> 在一个堆中，对于每一个节点 $X$，$X$ 的父亲中的关键字小于或等于 $X$ 中的关键字

> [!tip] 大根堆
> 
> 如果想要快速找出最大值，那么最大元应该在根上。在一个堆中，对于每一个节点 $X$，$X$ 的父亲中的关键大于或等于 $X$ 中的关键字
> 

我们以小根堆为例。下图左边是一个堆，右边则不是

![[Pasted image 20241002204531.png]]

> [!warning]  
> $6 < 21$ 不满足小根堆的定义
> 

