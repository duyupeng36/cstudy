# 网络：传输层协议

传输层协议用于 **在两台设备之间提供 _可靠_ 或 _高效_ 的数据传输服务**。它建立 **在网络层之上**，向上 **为应用层提供服务**，向下 **利用网络层完成数据传递**。

传输层最重要的协议是 **传输控制协议(Transmission Control Protocol，TCP)** 和 用户数据报协议(User Datagram Protocol，UDP)

> [!tip] TCP: 面向连接且可靠传输
> 
> **连接建立**：通过三次握手建立连接
> 
> **数据传输**：保证数据按顺序传输且无丢失
> 
> **流量控制**：使用窗口机制调整传输速度
> 
> **拥塞控制**：通过慢启动等算法防止网络拥塞
> 

> [!tip] UDP: 无连接且不可靠的传输
> 
> **无连接**：不需要建立或维护连接
> 
> **快速高效**：低开销，数据直接发送，无需确认
> 
> **无序传输**：数据可能乱序到达，接收方需自行处理
> 

下表列出了 TCP 和 UDP 的特性对比

| 特性     | TCP              | UDP           |
| ------ | ---------------- | ------------- |
| 是否面向连接 | 是                | 否             |
| 可靠性    | 提供可靠性（确认机制、重传机制） | 不提供，可能丢失数据    |
| 数据顺序   | 保证按顺序接收          | 无序            |
| 开销     | 高（需要维护连接状态）      | 低             |
| 速度     | 较慢（可靠性优先）        | 较快（实时性优先）     |
| 适用场景   | 文件传输、电子邮件、网页访问   | 实时通信、视频流、广播通信 |

## 用户数据报协议 UDP

UDP 是一种 **保留消息边界** 的简单的 **面向数据报** 的传输层协议。除了提供了差错检测外，不提供任何额外功能

> [!tip] 
> 
> UDP 提供最小功能，想要保证数据被可靠投递或正确排序，需要应用程序自己实现这些保护功能
> 

UDP 不提供差错纠正：它把应用程序传给 IP 层的数据发送出去，单不保证它们能够到达目的地。此外，没有协议机制防止高速 UDP 流量对其他网络用户的消极影响。考虑可靠性缺失和保护性缺失，通常可能会认为使用 UDP 没有好处

> [!hint] 
> 
> UDP 无连接的特性，要比其他传输协议使用更少的开销。广播和组播操通常使用 UDP 这样的无连接传输
> 
> 此外，应用程序可以选择自己重传单元的能力是一项重要的考虑
> 

下图展示 UDP 数据报作为 IPv4 数据报的载荷是如何进行封装的。

![Pasted image 20241118193924|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784517493-cc1c839370de44548f132b68ab946524.png)

#### UDP 头部

下图展示了一个包含 UDP 头部和有效载荷的 UDP 数据报

![Pasted image 20241118202244|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784517494-930bb00b046e4be5b962dfeca0eece82.png)

> [!tip] 源端口号和目的端口号：帮助协议辨认发送和接收进程
> 
> 端口号是一个抽象概念，不与主机上的任何物理实体相关
> 

> [!tip] 长度：UDP 头部和 UDP 数据的总长度，以字节为单位
> 
> 最小值是 $8$，即只包含头部，不包含负载数据。这是一个 **冗余字段**，因为 IPv4 头部包含了数据报的总长度，IPv6 头部包含了负载长度
> 
> 因此，一个 UDP/IPv4 数据报的长度等于 IPv4 数据报的总长度减去 IPv4 头部长度；一个 UDP/IPv6 数据报的长度等于 IPv6 头部中的负载长度
> 

> [!tip] 校验和
> 
> UDP 校验和是一个端到端的传输层校验和。它覆盖了 UDP 头部、UDP 数据和 UDP 伪头部
> 

### UDP 校验和

UDP 校验和由初始发送方计算得到，由最终的目的方校验。在传输过程中不会被改变。回想 IPv4 的校验和，它只覆盖了 IPv4 头部，并且每个 IP 跳都要被重新计算，因为 IPv4 的 TTL 字段的值在数据报转发时会被路由器减少。**传输层协议，包括 TCP 和 UDP，使用校验和覆盖它们的头部和数据**。

> [!tip] 
> 
> UDP 协议中校验和是可选的，而其他的则是强制的。UDP 在 IPv6 中使用时，校验和的计算与使用时强制的，因为在 IPv6 层没有头部校验和
> 

UDP 校验和的计算规则与 [[#Internet 校验和]] 中的就算方法类似。但是，需要注意两个细节

> [!tip] 细节 $1$: UDP 数据报长度可以是奇数个字节
> 
> 由于校验和只相加 $16$ 位字，总是偶数个字节。如果 UDP 数据报长度是奇数个字节，则在 UDP 数据报最后追加一个字节的 $0$
> 

> [!tip] 细节 $2$：包含了一个 UDP 伪头
> 
> UDP 伪头是衍生自 IP 头部，可能是 IPv4 头部字段，也可能是 IPv6 头部字段
> 

下图展示了计算 UDP/IPv4 校验和覆盖的字段，包含了伪头部以及 UDP 头和有效负载

![Pasted image 20241118212347|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784517494-47d24a27c86e48549af0781952335a75.png)

## 传输控制协议 TCP

对于IP 和 UDP ，它们使用了校验和这样的数学函数来 **检测接收到的数据是否有错误**，但是它们 **不尝试区纠正错误**。对于以太网和基于其上的其他协议，提供了一定次数的重试，如果还是不成功则放弃

通信媒介可能会 **丢失** 或 **改变** 被传递的消息，在这种环境下的通信问题可以使用 **差错纠正码** 或者 **尝试重新发送** 来解决

> [!tip] 差错纠正码：添加一些额外的位，使得即使某些位被毁，真实信息也可以被恢复过来
> 
> 常见差错纠正码有 **奇偶校验码** **海明码** 等
> 

> [!tip] 尝试重新发送：这是一种简单的要求发送端自动重传信息，直到信息最终被接收
> 
> 尝试重新发送信息的方法称为 **自动重复请求(Automatic Repeat Request, ARQ)**，它构成了许多通信协议的基础
> 

### ARQ 和重传

处理分组丢失和比特差错的方法就是重新发送分组直到它被正确接收。需要一种方法来判断：**接收方是否已收到分组**；接收方 **收到的分组是否与之前发送方发送的一样**

> [!tip] 确认(ACK) 机制
> 
> 接收方给发送方发信号已确定自己已经收到分组，这种方法称为 **确认(acknowledgment)**，称为 **ACK**。最基本的形式如下
> + 发送方发送一个分组，然后等待接收方的一个 ACK
> + 当接收方收到这个分组，它发送对应的 ACK
> + 当发送方收到这个 ACK，它再发送另一个分组
> 
> 上述过程就这样持续进行
> 

> [!question] 然而，确认机制存在一些问题
> + 发送方 **对一个 ACK 应该等待多长时间**？确定等待时间目前比较困难，后续在 **超时和重传** 中介绍
> + 如果 **ACK 丢失了怎么办**？发送方不能与分组丢失进行区分，所以简单地 **再次发送原分组**，这可能多次收到原分组
> + 如果分组被接收到，但是里面 **有差错怎么办**？使用校验和或 CRC 检查到差错，就**不发送 ACK**，**等待发送方重发**完整到达的无差错分组
> 

为了解决 ACK 丢失的问题，我们要求发送方再次发送分组，这会导致接收方收到分组的重复副本。使用 **序列号** 处理分组重复的问题

> [!tip] 序列号：在被源端发送时，**每个唯一的分组都有一个全新的序列号**
> 
> 序列号被分组一直携带。接收方可以使用这个序列号来判断它是否已经接收过这个分组了
> 
> 如果接收方已经接收了这个分组，则丢弃它
> 

然而，这种方式的效率不高。发送方注入一个分组到通信路径，然后停下来等待直到它收到 ACK。假设没有分组在传输中丢失和无可挽回地损害，该协议的吞吐量性能与 $\frac{\text{分组大小}}{\text{往返时间}}$ 成正比。如果分组丢失和损害，情况甚至更糟糕。

**如果允许同一时间有多个分组进入通信路径，就可以使得通信路径更繁忙，从而得到更高的吞吐量**。然而，允许多个分组同时注入网络使得情况变得复杂起来

> [!tip] 发送方
> 
> 发送方不经要考虑什么时间注入一个分组到网络，还要考虑注入多少个分组
> 
> 并且必须要指出等待 ACK 时，怎样维持计时，同时还必须保存没有确认的分组以防需要重传
> 

> [!tip] 接收方
> 
> 接收方需要有一个更复杂的 ACK 机制：区分哪些分组已经收到，那么些还没有
> 
> 接收方可能需要一个更复杂的缓存机制，允许维护次序杂乱的分组
> 

**如果接收方的接收速率比发送方的发送速率慢要怎么办？** 如果发送方简单地以很高的速率发送很多分组，接收方可能会因处理或内存限制而丢失这些分组。中间路由器也会有相同的问题。**如果网络基础设施处理不了发送方和接收方想要的数据发送率怎么办？**

### 分组窗口和滑动窗口

正如前面所述，当运行发送方同一时间向网络中注入多个分组时，会产生一些列的问题
+ 发送方什么时候注入分组，注入多少个？
+ 发送方如何维持计时器等待 ACK？
+ 发送方如何保存未确认的分组以防重传？
+ 接收方如何区分哪些分组已收到，哪些还没有？
+ 接收方如何维护次序杂乱的分组？

上述几个问题可以通过定义一个 **分组窗口** 作为 **已被发送方注入但还没有完成确定** 的分组的集合

> [!tip] 窗口大小：分组窗口的数量
> 

> [!tip] 窗口：来自这样的想法
> 
> 如果把在一个通信对话中发送的所有分组排成长长的一行，只通过一个小孔来观察它们，就只能看到它们的子集
> 

发送方的窗口可以描述为下图：显示了哪些分组被发送，哪些尚未发送，以及哪些已发送但未确认

![Pasted image 20241118225941|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784517495-46b852a03e834a0bbd2d89c75017a54e.png)

上图显示了当前 $3$ 个分组的窗口，整个窗口大小是 $3$。$3$ 号分组已被发送并确认，所以发送方可以释放它的副本了。$7$ 号分组在发送方已经被准备好了，但是还没有被发送，因为它没进入窗口

现在，如果我们想象数据开始从发送方流到接收方，ACK 开始以相反方向流动，发送方可能下一步就接收到 $4$ 号分组的 ACK。当这种情况发生时，窗口向右 **滑动** 一个分组，意味着 $4$ 号分组的副本可以被释放了，而 $7$ 号分组可以被发送了

> [!tip] 窗口的折中滑动给这种类型的协议增加了一个名字，**滑动窗口协议**

这个窗口结构在发送方和接收方都会有。在发送方，它记录了哪些分组可以被释放，哪些分组正在等待 ACK，哪些分组正在等待被发送。在接收方，它记录着哪些分组已经被接收和确认，哪些分组时下一步期望的，已经哪些分组即使被接收也将会因为内存限制而被丢弃

> [!warning] 
> 
> 尽管滑动窗口结构便于记录在发送方和接收方之间流动的数据，但是关于 **窗口应该多大**，如果接收方或者网络 **处理不过来发送方的数据率时会发生什么**？
> 

### 变量窗口：流量控制和拥塞控制

滑动窗口解决了允许多个分组同时注入网络中的大部分问题。但是还有少部分问题没有解决
+ 如果接收方的接收速率比发送方的发送速率慢要怎么办？
+ 如果网络基础设施处理不了发送方和接收方想要的数据发送率怎么办？

为了解决上述两个问题，在接收方跟不上发送方的速率时，**强迫发送方慢下来**。这称为 **流量控制**。流量控制有两中方式：**基于速率的流量控制** 和 **基于窗口的流量控制**

> [!tip] 基于速率的流量控制：给发送方指定某个速率，同时确保数据永远不超过这个速率发送
> 
> 非常适合流应用程序，可被用于广播和组播发现
> 

> [!tip] 基于窗口的流量控制：使用滑动窗口时最流行的方法。这里窗口大小不是固定的，而是随时间变动的。
> 

使用基于窗口的流量控制时，必须使用一种方法**让接收方通知发送方使用多大的窗口**。这种方法称为 **窗口通告** 或 **窗口更新**。发送方使用该值调整窗口大小。逻辑上，窗口更新和 ACK 应该分开；实际上，窗口更新和 ACK 是由同一个分组携带的

> [!tip] 
> 
> 发送方往往会在向右滑动窗口的同时调整窗口大小
> 

### 设置超时

基于重传的可靠协议面临一个重要的性能问题：**重传超时应该多大？**

> [!tip] 重复分组之前等待时间应该是下面时间的总和
> + 发送分组所用的时间
> + 接收方处理分组和发送 ACK 所用时间
> + ACK 返回到发送方所用时间
> + 发送方处理 ACK 所用时间

然而，上述时间没有一个是可以确切知道的。它们之中的某些会随着终端主机或路由器的额外负载增加或减少。让用户告知协议实现超时时间是不现实的，更好的策略是 **让协议实现尝试估计它们**。协议估计的时间称为 **往返估计时间**，这是一个统计过程

> [!tip] 往返估计时间：使用 **一组往返时间的平均值** 作为往返估计时间
> 
> 这个平均值会随时间变化而变化，因为通信穿过网络的路径可能发生改变
> 

### TCP 头部和封装

通过上述内容，我们知道了一个可靠传输需要怎样去实现。现在，我们讨论 TCP 头部和封装的问题

下图显示了 TCP 在 IP 数据报中的封装

![Pasted image 20241118234147|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784517496-eb595ba8ee3e447a92c86557db70f0f0.png)

TCP 头部明显要比之前学习的 UDP 头部复杂。因为 TCP 是一个明显要更复杂的协议，它必须保持连接的每一端知道最新状态。下图展示了 TCP 头部信息

![Pasted image 20241119003045|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784517496-f83ea0f63cdd44b49152ddf822b2ca08.png)


> [!tip] **源端⼝号(16 位)** 和 **目的端⼝号(16 位)**: 这两个值与 IP 头部中的源和目的 IP 地址一起，唯一标识了每个连接
> 
> 在 TCP 术语中，一个 IP 地址和一个端口号组合被称为 **端点** 或 **套接字**。每个 TCP 连接由一对套接字，即 $4$ 元组 `(客户机 IP, 客户机 port, 服务器 IP, 服务器 port)` 唯一地标识
> 

> [!tip] **序列号(SYN)(32 位)**: 标识了 TCP 发送端到 TCP 接收端的数据流的一个字节
> 
> 该字节代表着包含该序列号的 **报文段的数据中的第一个字节**。
> 

> [!tip] **确认号(ACK)(32 位)**: 该确认号是发送方期待接收的下一个序列号，即被成功接收的数据字节的序列号加 $1$
> 
> 该字段只有在 `ACK` 标志位被置位时有效，`ACK` 标志位用于初始和末尾报文之外的所有报文
> 

> [!tip] **头部长度(4 位)**：表示 TCP 头部的长度，以 $32$ 位为单位
> 
> 这是必须的，因为选项字段长度是可变的。由于头部长度字段只占 $4$ 位，因此 TCP 被限制为只能携带 $15 \times 32 \div 8= 60$ 字节的头部
> 
> 不带选项的 TCP 头部大小是 $20$ 字节
> 

> [!tip] **保留位(4 位)**：该字段为保留，现在未使用
> 
> 忽视该字段
> 

> [!tip] **控制位(8 位)**：该字段中的每个比特分别表示以下通信控制含义。一些老的实现只理解最后 $6$ 位
> + `CWR`：拥塞窗口减，发送方降低它的发送速率
> + `ECE`：`ECN` 回显，发送方接收到了一个更早的拥塞通告
> + `URG`：紧急，紧急指针字段有效
> + `ACK`：确认，确认号字段有效，连接建立后一般都是启用状态
> + `PSH`：推送，接收方应尽快的给应用程序传送这个数据，它没有被可靠的实现或用到
> + `RST`：重置连接，连接被取消，用于异常中断的情况
> + `SYN`：用于初始化一个连接的同步序号
> + `FIN`：该报文段的发送方已经结束向接收方发送数据

> [!tip] **窗口大小(16 位)**: 用于 TCP 的流量控制，通过每个端点使用窗口大小字段通告一个窗口大小
> 
> 窗口大小是字节数，从 ACK 号指定的，也是接收方想要接收的那个字节开始
> 
> 窗口大小占 $16$ 位，限制窗口大小最大为 $65535$ 字节，从而限制了 TCP 的吞吐量性能
> 
> 窗口缩放选项可以对这个值进行缩放，给高速和大延迟网络提供了更大的窗口和改进性能
> 

> [!tip] **校验和(16 位)**：用来检查是否出现错误
> 
> 覆盖了 TCP 头部和 TCP 数据，以及头部中的一些字段，使用与 UDP 相类似的伪头部进行计算
> 
> **该字段是强制的**，由发送方计算和保存，然后接收方验证。采用 [[网络：网络层协议#Internet 校验和]] 中的算法
> 

>[!tip] **紧急指针(16位)**：表示应紧急处理的数据位置
>
> 只有在 `URG` 标志位置位时才有效。这个 **紧急指针的值** 加上报文段中的 **序列号** 字段上的正偏移，以产生 **紧急数据的最后一个字节的序列号**
>

> [!tip] 选项：最大段尺寸(Maximum segment size, MSS)，用于防止 IP 分片
> 
> MSS 的计算公式为：$\text{MSS} = \text{MTU} - \text{IHL} - \text{THL}(\text{或} \text{UHL})$
> + $\text{MTU}$：通常是 $1500$ 字节
> + $\text{IHL}$：通常是 $20$ 字节
> + $\text{THL}$：通常是 $20$ 字节
> 

数据会被以 `MSS`  的长度为单位进行拆分，拆分出来的每⼀块数据都会被放进单独的 IP数据包中。也就是在 **每个被拆分的数据加上 TCP 头信息，然后交给 IP 模块来发送数据**。如下图所示

![Pasted image 20241119231900|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784517497-88666677e42148dea70ab04b68be4257.png)

## TCP 连接管理

**TCP 是一种面向连接的单播协议**。在发送数据前，通信双方必须在彼此间建立一条连接。在建立连接过程中，通信双方需要交换一些选项。这些选项被认为是连接的参数

> [!tip] 
> 
> 某些选项只允许在连接建立时发送，而其他一些选项可以稍后发送
> 

#### TCP 连接和终止

一个 TCP 连接由 $4$ 元组标识，即 `(客户机 IP, 客户机 port, 服务器 IP, 服务器 port)`。显然，TCP 连接是由一对套接字构成，其中通信的每一端都由 `(IP 地址, 端口)` 唯一标识

> [!tip] TCP 连接标识符：`(客户机 IP, 客户机 port, 服务器 IP, 服务器 port)`
> 
> 只要 $4$ 元祖中的任何一个不同，就能区分一个 TCP 连接
> 

TCP 连接分为 $3$ 个阶段: **启动**、**数据传输**、**退出**。下图显示了一个典型的 TCP 连接的建立与关闭过程

![Pasted image 20241119110900|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784517497-501ebdabc99245d28aec3c83156bf02f.png)

> [!tip] 连接建立：三次握手过程
> 
> **SYN 报文段**：TCP 头部的 SYN 位字段置位的 TCP/IP 数据包 
> 
> 首先，**客户端** 向服务器发送一个 **SYN 报文段**
> + 指明了想要连接的端口(**目标端口**)和 **客户端的初始序列号** ($\text{ISN(c)}$)
> 
> 然后，**服务器** 在接收到客户端的 SYN 报文段后，就 **发送自己的 SYN 报文段作为响应**
> + 同时指明 **服务端的初始序列号** ($\text{ISN(s)}$)
> + 为了 **确认** 客户端的 SYN 报文段，服务器将 **客户端的序列号加 $1$**，即 ($\text{ISN(c)} + 1$) 作为 **ACK 号**
> 
> 最后，客户端为了 **确认** 服务器的 SYN 报文段
> + 客户端将 **服务器的序列号加 $1$**，即 $\text{ISN(s)} + 1$  作为 ACK 号
> + 同时将自己的序列号加 $1$，即 $\text{ISN(c)} + 1$， 并发送给服务器
> 
> 每发送一个 SYN 报文段，序列号就会自动加 $1$，即使出现丢失情况，该 SYN 报文段就会重传
> 

通过上述 $3$ 个 TCP/IP 报文段就能完成一个 TCP 连接的建立。通常被称为 **三次握手**。它不仅让通信双方了解一个连接正在建立，还利用数据包的选项来承载特殊信息，交换 **初始序列号(Initial Sequence Number, ISN)**

数据传输完成之后，任何一方都可以发起一个关闭操作，甚至是双方同时关闭连接的操作。传统情况下，**负责发起关闭连接的通常是客户端**。TCP 协议规定通过发送一个 **FIN 报文段** 来发起关闭操作。**只有当连接双方都完成关闭操作后，才构成完整的关闭**

> [!tip] 断开连接：四次挥手
> 
> 首先，连接的 **主动关闭者** 发送一个 **FIN 报文段** 指明接收者希望看到自己的 **当前序列号 $L$ (接收者希望看到的)**。
> + FIN 段还包含了一个 `ACK` 段($L$)用于确认对方最近一次发来的数据 
> 
> 然后，连接的 **被动关闭者** 将 $K + 1$ 作为响应的 `ACK` 值(确认号)
> + 表明它已成功接收到主动关闭者发送的 `FIN`
> 
> 此时，**上层应用程序会被告知连接的另一端已经提出关闭的请求**
> + 此时，导致 **应用程序发起自己的关闭操作**
> + 接着，被动关闭者的身份将转变为主动关闭者，**发送自己的 `FIN` 段**，该段的序号为 $L$
> 
> 最后，为了完成连接的关闭，客户端最后发送的报文段还包含一个 `ACK` 用于确认上一个 `FIN`
> + 如果 `FIN` 出现丢失的情况，发送方还将重新传输直到接收到一个 `ACK` 确认为止
> 

综上所述，建立一个 TCP 连接需要 $3$ 个报文段，而关闭一个连接需要 $4$ 个报文段。TCP 协议支持连接处于 **半开启** 状态

> [!tip] 
> 
> TCP 存在半开启状态的原因是 **TCP 通信模型是双向的**，意味着在两个方向中可能会出现 **只有一个方向正在传输数据**
> 

#### TCP 半关闭

TCP 半关闭操作是指 **仅关闭数据流的一个传输方向**，而两个半关闭操作合在一起才能关闭整个连接。TCP 协议规定通信的任何一方在完成数据发送任务之后都能发送一个 FIN 报文段。当通信的另一方接收到这个 FIN 报文段时就会告知应用程序对方已终止对应方向的数据传输

> [!tip] 
> 
> 当程序发布关闭操作请求后，**通信双方往往通过发送 FIN 报文段关闭双向的数据传输**
> 

下图展示了一个正在使用半关闭的示例

![Pasted image 20241119160916|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784517498-cb8229374749417ebfc42b039fffab58.png)

> [!tip] 
> 
> 上图例子中，客户端负责发起半关闭操作，实际上任何一端均可以发起半关闭操作
> 

发起半关闭的前两个报文段与正常关闭完成相同：**客户端发送 FIN**，接着是 **服务器回应 FIN 的 ACK** 。此时，接收到半关闭的一方仍然能发送数据，当接收半关闭的一方数据发送完毕后，它将发送一个 FIN 来关闭本方的连接，同时向发起半关闭的应用程序发出一个 EOF。直到第二个 FIN 被 ACK 之后，整个连接完全关闭

### TCP 的状态转换

下图展示了 TCP 的状态转换图。状态使用椭圆表示，状态之间的转换利用箭头表示

> [!tip] TCP 连接的每一端都可以在上图状态中进行转换
> + 有些转换是由于 **接收到某个控制位字段置位的报文** 
> + 有些转换会要求 **发送一些控制位字段置位的报文段**
> 


![Pasted image 20241119201151|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784517499-890840957a6541a9a5f4dcbdb6955659.png)

当初始化时 TCP 从 **CLOSED(已关闭)** 启动。根据不同的 `open()` 操作(**主动打开** 或 **被动打开**)，TCP 将分别快速转换到 **SYN_SENT(请求连接)** 和 **LISTEN(监听)**

客户端在 CLOSED 状态时，主动打并发送 SYN ，等到收到 SYN+ACK 之后，状态转换为 **ESTABLISHED(已连接)** 状态

服务端在 LISTEN 状态时，收到 SYN 并发送 SYN+ACK 之后，状态转换为 **SYN_RCVD(半连接)** 状态。此后，如果服务端收到 ACK 之后，状态转换为 **ESTABLISHED(已连接)** 状态

> [!tip] **ESTABLISHED(已连接)**：通信双方传输数据的状态

客户端在 ESTABLISHED 状态时，执行 `close()` 并发送 FIN 后，客户端状态转换为 **FIN_WAIT_1(终止等待)** 状态。此后，如果收到 ACK，状态转为为 **FIN_WAIT_2(半关闭)** 状态。此时，如果收到 FIN 时，状态转换为 **TIME_WAIT(等待关闭)**。客户端在等待 2MSL 后，状态转换为 CLOSED

> [!tip] 客户端的 TIME_WAIT 状态存在的必要性
> 
> **可靠地实现 TCP 全双工连接的终止**。如果被动方没有收到主动方发送的 ACK，被动方会重传 FIN，主动方需要等待一段时间。
> + 等待时间是两倍的 **最大生存期(Maximum Segment Lifetime, MSL)**。先发送一次 ACK，在等待一次 FIN，共 2MSL
> 
> **允许老的分段在网络中消逝**。有可能两端建立了不止一条连接，在新的连接建立前，老的连接中正在传递的分组就已经在网络中消失了
> 

> [!warning] 
> 
> 如果不加特殊的处理，在处于 `TIME_WAIT` 状态下，用户无法对同样的四元组建立新的连接。我们可以使用命令来查看 `TIME_WAIT` 的时长
> 
> ```shell
> $ cat /proc/sys/net/ipv4/tcp_fin_timeout
> 60
> ```
> 
> 我的机器设置的是 $60 s$ 
> 

服务端在 ESTABLISHED 状态时，接收到 FIN 并发送 ACK 之后，服务端状态转换为 **CLOSE_WAIT(等待关闭)**。此时，当发送完最后一个 FIN 后，状态转换为 **LAST_ACK(最后确认)** 状态。此时，接收到 ACK 之后，状态转换为 CLOSED

下图给出了 TCP 连接的建立和终止过程中的客户端与服务器经历的各种状态

![Pasted image 20241119211141|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784517500-7b1ab6275cee4ee2ac3e57aaa055f992.png)
