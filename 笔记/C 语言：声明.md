# 声明

**声明在 C 语言编程中起着核心的作用**。通过声明变量和函数，可以在两方面为编译器提供至关重要的信息：**检查程序潜在的错误**，以及 **把程序翻译成目标代码**

我们以及学习过变量和函数的声明了，但是没有完整地描述。下面，我们将详细介绍声明语法

## 声明语法

一般地，声明具有下列形式

```c
存储类型 类型限定符 类型指定符 对齐指定符 声明符 = 初始化器;
```

下表列出了 $4$ 种 **存储类型**

| 存储类型       | 描述                     |
| :--------- | :--------------------- |
| `auto`     | 自动存储类型，局部变量默认存储类型      |
| `static`   | 静态存储类型，外部变量默认存储类型      |
| `extern`   | 静态存储类型                 |
| `register` | 寄存器存储类型，建议编译器将变量放在寄存器中 |

> [!tip]
> 
> 在声明中最多可以出现一种存储类型
> 

下表列出了 $5$ 种 **类型限定符**

| 类型限定符       | 描述          |
| :---------- | ----------- |
| `const`     | 只读类型        |
| `constexpr` | 常量表达式，C23 起 |
| `volatile`  | 易变类型        |
| `restrict`  | 受限类型，C99 起  |
| `_Atomic`   | 原子类型，C11 起  |

在一些计算机中，一部分内存空间是 **“易变”的**，保存在这种内存空间的值可能会在程序运行期间发生改变，即使程序自身并未试图存放新值

**`volatile` 类型限定符** 使我们可以通知编译器，程序中的某些数据是“易变”的。例如如下声明

```c
volatile BYTE *p;   /* p will point to a volatile byte */
```

> [!tip] 
> 
> **`volatile` 限定符通常用于指向易变内存空间的指针的声明中**
> 

> [!tip]
> 
> 声明可以包含零个或多个限定符
> 

下表列出了大部分 **类型指定符**

| 类型指定符      | 描述      |
| :--------- | ------- |
| `void`     | 空类型     |
| `char`     | 字符类型    |
| `short`    | 短整型     |
| `int`      | 整型      |
| `long`     | 长整性     |
| `float`    | 单精度浮点类型 |
| `double`   | 双精度浮点类型 |
| `signed`   | 有符号     |
| `unsigned` | 无符号     |
| `struct`   | 结构      |
| `union`    | 联合      |
| `enum`     | 枚举      |
> [!tip] 
> 
> 某些类型指定符可以组合使用，出现的顺序并不重要
> + 例如，`int unsigned long` 和 `long unsigned int` 完全一样
> 
> 用 `typedef` 创建的类型名也是类型指定符
> 

C11 开始可以指定对象的 **对齐边界**

| 对齐指定符                | 描述                  |
| :------------------- | ------------------- |
| `_Alignas(类型/常量表达式)` | 按照 `类型/常量表达式` 对齐    |
| `alignas(类型/常量表达式)`  | C23 起 `alignas` 关键字 |

**声明符** 可以只是一个标识符，也可能是标识符和 `[]` `()` 以及 `*` 的各种组合，用来表示 _指针_ _数组_ 或者 _函数_。声明符之间用逗号分隔。**表示变量的声明符后边可以跟随初始化器**

下面是一个带有存储类型和 $3$ 个声明符的声明

![Pasted image 20240930161248|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755702430988-5b854c4b53c14939ba46dc982a136523.png)

下列声明有类型限定符但是没有存储类型。此外，它还有初始化器

![Pasted image 20240930160534|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755702440580-0f43356e06a948569e051593c7eb5614.png)

下列声明既有存储类型也有类型限定符。此外，它还有 $3$ 个类型指定符，当然它们的顺序并不重要

![[Pasted image 20240930161027.png]]


和变量声明一样，**函数声明也有存储类型、类型限定符和类型指定符**。下列声明具有存储类型和类型指定符

![[Pasted image 20240930161210.png]]

## 存储类型

C 程序中的每个变量都具有以下 3 个性质

| 变量的性值 | 描述                         |
| :---- | :------------------------- |
| 存储期   | 储期决定了为变量预留的内存被释放的时间        |
| 作用域   | 可以通过名字引用变量的那部分程序文本         |
| 链接    | 确定了程序的不同部分可以通过变量名字共享此变量的范围 |

> [!tip]
> 
> 存储期和作用域在 [[C 语言：函数#程序结构]] 中详细介绍过
> 

这里我们详细介绍 **链接** 属性。下表列出了 $3$ 中链接属性

| 链接属性 | 描述                          |
| :--- | :-------------------------- |
| 外部链接 | 变量可以被程序中的几个文件共享             |
| 内部链接 | 变量只能属于单独一个文件，文件中的函数可以共享这个变量 |
| 无链接  | 变量属于单独一个函数且不能被共享            |

> [!tip] 默认的存储期、作用域和链接都依赖于变量声明的位置
> 
> 在 **块（包括函数体）内部声明** 的变量通常具有 **自动存储期**，它的名字具有 **块作用域**，并且 **无链接**
> 
> 在程序的 **最外层（任意块外部）声明** 的变量具有 **静态存储期**，它的名字具有 **文件作用域** 和 **外部链接**
> 


**`auto` 存储类型** 只对属于块的变量有效。`auto` 变量具有自动存储期，它的名字具有块作用域，并且无链接

> [!tip]
>  `auto` 存储类型 **在块内部声明的变量，它是默认的**

**static 存储类型** 可以用于全部变量，而无须考虑变量声明的位置。作用于块外部声明的变量和块内部声明的变量时会有不同的效果

| 位置   | 含义                      |
| ---- | ----------------------- |
| 块内   | `static` 将变量的存储期从自动改为静态 |
| 任意块外 | `static` 将变量的外部链接改为内部链接 |

```c
static int i; // 静态存储期，文件作用域，(内部链接)

void f(void)
{
	static int j; // (静态存储期)，块作用域，无连接
}
```

> [!tip] `static` 变量具有以下一些有趣的性质
> + 块内的 `static` 变量只在程序执行前进行一次初始化
> + 如果函数含有 `static` 变量，那么此函数的递归调用都可以共享这个 `static` 变量
> + 函数返回指向 `static` 变量的指针是没有错误的

**`extern` 存储类型** 使几个源文件可以共享同一个 **外部变量**。关于如何共享同一个外部变量，我们在 [[C 语言：程序的结构]] 中已经介绍。**`extern` 声明中的变量始终具有静态存储期**。变量的作用域依赖于声明的位置。如果声明在块内部，那么它的名字具有块作用域；否则，具有文件作用域

```c
extern int i; // 静态存储期，文件作用域，链接不确定

void f(void)
{
	extern int j; // 静态存储期，块作用域，链接不确定
}
```

**`register` 存储类型** 请求编译器把变量存储在寄存器中，而不是像其他变量一样保留在内存中

> [!tip] `register` 存储类型的注意事项
> + **只对声明在块内的变量有效**
> + 具有与 `auto` 变量一样的属性
> + **不能对 `register` 类型的变量取地址**，即使编译器没有将其放入寄存器中
> 

**函数可以声明的存储类型有 `extern` 和 `static`**

> [!tip]
> 
> 在函数声明开始处的单词 `extern` 说明函数的名字具有外部链接，也就是允许其他文件调用此函数
> 
> `static` 说明函数具有内部链接，也就是说只能在定义函数的文件内部调用此函数
> 

## 声明符

声明符包含标识符(声明的变量或函数的名字)。标识符的前边可能有符号`*`，后边可能有 `[]` 或 `()`

通过把`*`、`[]` 和 `()`组合在一起，可以创建复杂声明符。现在复习一下之前学习的声明符

> [!tip] 
> + `*` 开头的声明符表示指针
> + `[]` 结尾的声明符表示数组
> + `()` 结尾的声明符表示函数
> 

分析声明的时候，首先找到标识符，然后根据这三个符号(`*, [], ()`) 遵循从高到底的优先级为: `[] == () > *` 和结合性进行分析
- `[], ()` 有相同的优先级，都是左结合的
- `*` 的优先级低于 `[], ()`，是右结合的

根据上面的描述，现在我们来解释如下声明

```c
void (*pf)(int);
```

> [!tip] 分析
> 找到 `pf`，在 `pf` 前面有 `*`，说明 `pf` 是指针
> 
> 接着发现 `(*pf)` 后面又个 `()`，说明 `*pf` 是函数。这个函数没有返回值，且需要一个 `int` 类型的参数

继续分析如下更复杂的声明

```c
int *(*x[10])(void);
```

 > [!tip] 分析
 > 
 > 首先，定位标识符 `x`。在 `x` 前面有 `*`，后面有 `[]`。因为 `[]` 的优先级高于 `*`，所以 `x` 是数组
 > 
 > 接下来，`x[10]` 前面的 `*` 表示它们是指针
 > 
 > 再接下来，`(*x[10])` 后面有 `()`，表示 `(*x[10])` 是函数
 > 
 > 最后，该函数返回类型是 `int *`，不需要任何参数
 > 

## 初始化器

为了方便，C 语言 允许在声明变量时为它们指定初始值。为了初始化变量，可以在声明符的后边书写符号 `=`，然后在其后加上初始化器

**简单变量的初始化器 就是一个与变量类型一样的表达式**

```c
int i = 5 / 2;  /* i 被初始化为 2*/
```

**指针变量** 的初始化器 **必须是具有和变量相同类型** 或 **`void*` 类型的指针表达式**

```c
int i;
int *p = &i;
```

**数组**、**结构** 或 **联合** 的初始化器 **通常是带有花括号的一串值**

```c
int a[5] = {1, 2, 3, 4, 5};
```

> [!tip] 
> 
>  C99 开始，指示器语法的出现初始化器可以有其他形式
> 

> [!important] 
> 
> **具有静态存储期的变量的初始化器必须是常量**
>  

```c
#define FIRST 1 
#define LAST 100 
 
static int i = LAST – FIRST + 1;
```

包含在花括号中的 **数组**、**结构**或 **联合** 的 **初始化器** 必须 **只包含常量表达式**，不允许有变量或函数调用

```c
#define N 2 
 
int powers[5] = {1, N, N * N, N * N * N, N * N * N * N};
```

**自动类型的结构或联合变量的初始化器可以是另外一个结构或联合**

```c
void g(struct part part1) 
{ 
  struct part part2 = part1; 
  ... 
}
```

### 未初始化的值

**未初始化变量有未定义的值**，但并不总是这样的，**变量的初始化值依赖于变量的存储期**

具有 **自动存储期** 的变量 **没有默认的初始值**：具体自动存储期的变量没有被初始化时，其值是随机的

具有 **静态存储期** 的变量 **默认情况下的值为 0**；静态变量是基于类型的正确初始化
- 整型变量初始化为 0
- 浮点变量初始化为 0.0
- 指针初始化为空指针

## 内联函数

函数可以被定义成 `inline` 的

```cpp
inline int fac(int n)
{
	return (n < 2) ? 1 : n * fac(n-1);
}
```

`inline` 限定符告诉编译器，它 **应该尝试** 为 `fac()` 的调用生成内联代码。`inline` 并不是强制编译器将代码内联编译，只是建议编译器应该时函数调用尽可能快

**“内联”** 表明编译器把函数的 **每一次调用都用函数的机器指令来代替**。使被编译程序的大小增加一些，节省了函数调用创建栈帧的时间

**内联函数它具有外部链接**。其他文件也可以调用 `fac` 函数，因为函数是内敛的，试图在别的文件中调用 `fac` 函数将被当作错误

> [!tip] 两种方法避免上述错误
> 
> 修改它的链接属性。使用 `static` 将其链接改为内部链接。通常不用该方法
> 
> 为内联函数 `fac` 提供外部定义。首先将 `fac` 函数地内联定义放入头文件中，然后再创建与之匹配地 `.c` 文件
> 

首先，在 `fac.h` 头文件中

```c title:fac.h
#ifndef FAC
#define FAC
inline int fac(int n)
{
	return (n < 2) ? 1 : n * fac(n-1);
}
#endif
```

然后，创建与之匹配地 `fac.c`

```c title:fac.c
#include "fac" 
 
extern int fac(int n);
```

> [!warning] 对内联函数的限制
> 
> 函数中不能定义可改变的 `static` 变量
> 
> 函数中不能引用具有内部链接的变量
> 

## 属性

C23 标准对类型、对象、表达式等引入实现定义的 **属性**。属性为各种由实现定义的语言扩展（例如 GNU 与 IBM 的语言扩展 `__attribute__((...))`，微软的语言扩展 `__declspec()` 等）提供了统一化的语法。

属性可用在 C 程序中的几乎所有位置，而且可应用于几乎所有事物：类型、变量、函数、名字、代码块、整个翻译单元，不过每个特定的属性都仅在实现所容许之处有效

> [!example] 虚构的例子
> 
> `[[expect_true]]` 可能是只能与 if，而非与类声明一同使用的属性，`[[omp::parallel()]]` 可能是应用到代码块或 for 循环，而非到类型 `int` 等的属性
>

在声明中，属性可以同时出现在整个声明之前，以及紧跟在被声明实体的名字之后，这些情况下它们被组合起来

两个连续的左方括号记号（`[[`）只能出现于引入属性说明符之处，或在属性实参之内

除了标准属性之外，实现还可能支持任意拥有由实现定义的行为的非标准属性。所有实现所未知的属性均被忽略，且不产生错误。

每个 **标准属性** 均为标准化保留。即每个 **非标准属性** 均由实现提供的 **属性前缀** 冠以前缀，例如 `[[gnu::may_alias]]` 与 `[[clang::no_sanitize]]`。

### 标准属性

| 标准属性                                     | 描述                  |
| :--------------------------------------- | :------------------ |
| `[[deprecated]]` `[[deprecated(字符串字面值]]` | 名字或实体被弃用            |
| `[[fallthrough]]`                        | 从前一个 case 标号发生直落    |
| `[[nodiscard]]` `[[nodiscard(字符串字面值]]`   | 鼓励编译器在返回值被丢弃时发出警告   |
| `[[maybe_unused]]`                       | 抑制编译器对未使用实体的警告      |
| `[[noreturn]]`                           | 指示函数不会返回            |
| `[[unsequenced]]`                        | 指定函数无状态、无副作用、幂等且无依赖 |
| `[[reproducible ]]`                      | 指定函数无副作用且为幂等        |

#### deprecated 属性

指示声明 **有此属性的名字或实体被弃用**，即允许但因故不鼓励使用。

下列名字或实体的声明中允许使用这个属性

```c
struct [[deprecated]] S;  // 结构或联合
[[deprecated]] typedef S* PS;， // typedef
[[deprecated]] int x; // 变量声明
union U { [[deprecated]] int n; }; // 结构或联合的成员
[[deprecated]] void f(void); // 函数
enum [[deprecated]] E {}; // 枚举
enum { A [[deprecated]], B [[deprecated]] = 42 }; // 枚举项
```

#### fallthrough 属性

仅可用于属性声明以创建 **直落** 声明(`[[fallthrough]]`;)。**直落声明仅可用于 `switch` 语句中**，其中要遇到的下个块项（语句、声明或标号）是该 `switch` 语句的带 `case` 或 `default` 标号的语句。

> [!tip]
> 指示从前一标号直落是有意的，而在发生直落时给出警告的编译器不应诊断它
> 

```c
#include <stdbool.h>
 
void g(void) {}
void h(void) {}
void i(void) {}
 
void f(int n) {
  switch (n) {
    case 1:
    case 2:
      g();
     [[fallthrough]];
    case 3: // 直落时不警告
      h();
    case 4: // 编译器可在发生直落时警告
      if(n < 3) {
          i();
          [[fallthrough]]; // OK
      }
      else {
          return;
      }
    case 5:
      while (false) {
        [[fallthrough]]; // 谬构：下一语句不是同一迭代的一部分
      }
    case 6:
      [[fallthrough]]; // 谬构：下一语句不是同一迭代的一部分
  }
}
 
int main(void) {}
```

#### nodiscard 属性

鼓励编译器在返回值被丢弃时发出警告。出现于函数声明、枚举声明或结构体/联合体声明。

```c
struct [[nodiscard]] error_info { int status; /*...*/ };

struct error_info enable_missile_safety_mode() { /*...*/ return (struct error_info){0}; }

void test_missiles() {
   enable_missile_safety_mode(); // 编译器可能在舍弃 nodiscard 值时警告
}
```

#### maybe_unused 属性

抑制对未使用实体的警告。此属性能出现在下列实体的声明中

```c
struct [[maybe_unused]] S; 
[[maybe_unused]] typedef S* PS;
[[maybe_unused]] int x;
union U { [[maybe_unused]] int n; };
[[maybe_unused]] void f(void);
enum [[maybe_unused]] E {};
enum { A [[maybe_unused]], B [[maybe_unused]] = 42 };
```

> [!tip] 
> 
> 若编译器对未使用实体发布警告，则对任何声明为 `maybe_unused` 的实体抑制该警告。
> 

#### noreturn  属性

指示函数不会返回。**这个属性适用于函数名**，指示函数不会由于执行返回语句或由于抵达函数体结尾而返回（它可以通过执行 `longjmp` 返回）。如果有此属性的函数实际返回，则其行为未定义。如果可以检测这种情况，建议编译器予以诊断。

```c
[[noreturn]] void longjmp( jmp_buf env, int status );
```

#### unsequenced 和 reproducible 属性

指定函数 **无状态**、**无副作用**、**幂等**且 **无依赖**。

> [!tip] 无作用
> 
> 如果 **函数调用** 过程中编入序列的 **任何存储操作**，都是 **对某对象的同步于此次调用的修改**，则该调用的执行是无作用的；如果这种存储操作还是可观察的，则对该对象的所有访问必须都基于函数的一个唯一指针形参进行
> 

> [!tip] 幂等：多次计算并且最终结果不变
> 
> 对于某个求值 `E`，若 `E` 的第二次求值可以紧跟第一次求值编入序列而不改变结果值（如果有）或执行的可观察状态，则它是幂等的。
> 

> [!tip] 无状态
> 
> 如果函数 `F` 或其所调用的任何函数中，具有 **静态** 或 **线程存储期** 的任意对象的定义均为 `const` 但无 `volatile` 限定，则 `F` 是无状态的。
> 

> [!tip] 无关联
> 
> 对于函数 `F`，如果 `F` 的调用中可以通过并非该调用的形参的左值而观察到任何对象 `X`，而在同一次程序执行中所有对 `F` 的调用中，对 `X` 的所有访问都观察到相同的值，则 `F` 无关联；或者如果访问是通过某个指针形参进行，则应当有一个唯一的这种指针形参 `P`，使得对 `X` 的任何访问都应当是基于 `P` 的左值访问
> 

## 静态断言

从 C11 开始引入的静态断言 `_Static_assert` 可以把检查和诊断工作放在程序编译期间进行

```c
_Static_assert(整数常量表达式, 字面串);
_Static_assert (整数常量表达式 )
```

例如

```c
# include <limits.h> 
 
int main(void) 
{ 
    _Static_assert(UINT_MAX >= 32767, "Not support this platform."); 
    // 其他代码 
 r
```

C23 开始，`_Static_assert` 被弃用，改用关键字 `static_assert `


