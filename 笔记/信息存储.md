# 信息存储

现代计算机存储和处理的信息以 **二值信号** 表示

> [!tip] 二值信号也称为 **位**(bit)
> 

对于有 $10$ 个手指的人类来说，使用 [[数字系统#十进制系统：以 $10$ 为底|十进制]] 表示法是很自然的事情，但是当构造存储和处理信息的机器时， [[数字系统#二进制系统：以 $2$ 为底|二进制]] 工作得更好。**二值信号能够很容易地被表示、存储和传输**

> [!example] 
> 
> + 穿孔卡片上有洞或无洞
> + 导线上的高电压或低电压
> + 顺时针或逆时针的磁场
> 

二值信号的存储和计算的电子电路非常可靠，制造商能够在一个单独的硅片上集成数百万甚至数十亿个这样的电路。

孤立的位是没有太多的作用。然而，**把为组合在一起，形成 _位模式_，再辅以某种 _解释_**，我们就能够表示任何有限集合的元素

> [!tip] 所谓的 **解释**，就是 **赋予不同的可能位模式以含意**
> 
> + 使用一个二进制数字系统，能够 **用位组来编码非负数**
> + 使用标准的 **字符码**，能够 **对文档中的字母和符号进行编码**
> 

在 [[整数的表示与运算]] 中介绍 **无符号编码** 和 **补码编码**；在 [[浮点数表示与运算]] 中介绍 **浮点数** 编码。计算机用这些不同的表示方法实现算术运算

> [!tip]
> 
> + **无符号编码** 基于传统的二进制表示法，表示大于或者等于零的数字
> 
> + **补码编码** 是表示有符号整数的最常见的方式，有符号整数就是可以为正或者为负的数字
> 
> + **浮点数编码** 是表示实数的科学记数法的以 $2$ 为基数的版本
>

计算机的表示法是用 **有限数量的位** 来对一个数字编码，因此，当 **结果太大以至不能表示** 时，某些运算就会 **溢出**。浮点运算有完全不同的数学属性。虽然溢出会产生特殊的值 $\pm \infty$，但是一组正数的乘积总是正的

大多数计算机使用 $8$ 位的块，或者 **字节** (byte) ，作为 **最小的可寻址的内存单位**，而不是访问内存中单独的位

> [!tip] 机器级程序将内存视为一个非常大的字节数组，称为 **虚拟内存**
> 
> 内存的每个字节都由一个唯一的数字来标识，称为它的 **地址**。所有可能地址的集合就称为 **虚拟地址空间**
> 
> 虚拟地址空间只是一个展现 给 机器级程序的概念性映像。实际实现在 [[虚拟内存]] 中介绍
> 

## 十六进制表示法

一 个字节由 $8$ 位组成。在二进制表示法中，它的值域是 $00000000_2 \sim 11111111_2$。十进制就是 $0_{10} \sim 255_{10}$

> [!tip] 二进制和十进制对于描述位模式都不方便
> + 二进制表示法太长冗长
> + 十进制不能有效的表示位模式中的值，需要进行复杂的转换
> 

以 $16$ 为基数( [[数字系统#十六进制系统：以 $16$ 为底|十六进制]]数)表示位模式，可以减小表示的长度，同时也能清晰的展示位模式中的值。下表展示十六进制数对应的十进制和二进制值

| 十六进制数字 | 十进制值 | 二进制值   |
| :----- | ---- | ------ |
| `0`    | `0`  | `0000` |
| `1`    | `1`  | `0001` |
| `2`    | `2`  | `0010` |
| `3`    | `3`  | `0011` |
| `4`    | `4`  | `0100` |
| `5`    | `5`  | `0101` |
| `6`    | `6`  | `0110` |
| `7`    | `7`  | `0111` |
| `8`    | `8`  | `1000` |
| `9`    | `9`  | `1001` |
| `A`    | `10` | `1010` |
| `B`    | `11` | `1011` |
| `C`    | `12` | `1100` |
| `D`    | `13` | `1101` |
| `E`    | `14` | `1110` |
| `F`    | `15` | `1111` |

> [!tip] 用十六进制书写，一个字节的值域为 $00_{16}  \sim FF_{16}$

在 C 语言中，以 `0x` 或 `0X` 开头的数字常量被认为是十六进制的值。字符 `'A' ~ 'F'` 既可以是大写，也可以是小写

> [!tip] 
> 
> 后面，我将采用 C 语言风格表示十六进制值
> 

关于进制转换的问题，我们在 [[数字系统#转换规则]] 中已经详细介绍过了，这里不再赘述了

## 字数据大小

每台计算机都有一个 **字长**，指明指针数据的标称大小。虚拟地址是以这样的一个字来编码的。也就是说，**字长决定虚拟地址空间的大小**

> [!tip]
> 
> 对于一个字长为 $w$ 位的机器而言，虚拟地址的范围为 $0 \sim 2^w — 1$，程序最多访问 $2^w$ 个字节
> 

现代计算机的机器字长为 $32$ 位 或 $64$ 位，但是目前出现来大规模的从 $32$ 位字长的机器迁移到 $64$ 位字长的机器

> [!tip]
> 
> $32$ 位字长限制虚拟地址空间为 4 GB
> 
> $6$ 为字长使得虚拟地址空间为 16 EB
> 

大多数 $64$ 位机器也可以运行为 $32$ 位机器编译的程序，这是一种向后兼容。

> [!tip]
> 
> 我们将为 $32$ 位机器编译的程序称为 $32$ 位程序，为 $64$ 位机器编译的程序称为 $64$ 位程序
> 
> $32$ 位程序和 $64$ 位程序主要是区别在于该程序是如何编译的，而不是其运行的机器类型。

## 寻址和字节序

现代计算机中，**最小的寻址单位是字节**。对于 **多字节对象**，必须建立两个规则：**对象的地址是什么**？以及 **在内存中如何排列这些字节**

> [!tip] 多字节对象的地址
> 
> 在几乎所有的机器上，多字节对象都被存储为 **_连续的字节序列_**，对象的 _地址_ 为所使用字节中的 **_最小地址_**

排列表示一个对象的字节有两个通用的规则

> [!tip] 
> 
> 假设一个 $w$ 为的整数，其位模式为 $[x_{w-1},x_{w-2}, \cdots., x_{1}, x_{0}]$，其中 $x_{w-1}$ 是 **最高有效位**；$x_0$ 是 **最低有效位**
> 
> 假设 $w=8 \cdots 8k$ 其中 $k=1,2,\cdots$，这些为就能分组成为字节，其中 **最高有效字节** 包含 $[x_{w-1},x_{w-2},\cdots,x_{w-8}]$；**最低有效字节** 包含 $[x_{7},x_{6}, \cdots,x_{0}]$
> 

某些机器（采用 **小端法**）在内存中按照 **从最低有效字节到最高有效字节的顺序** 存储对象。另一些机器则（采用 **大端法**）在内存中按照 **从最高有效字节到最低有效字节的顺序** 存储对象

> [!tip] 在内存中如何排序多字节对象
> 
> 假设变量 $x$ 的类型为 `int`，位于地址 `0x100` 处，它的十六进制值为 `0x01234567`。地址范围 `0x100 ~ 0x103` 的字节序依赖于机器的类型
> 
> ![[Pasted image 20241004232052.png]]
> 

理解字节序有时候时必须的。例如，在不同类型的机器之间通过网络传送二进制数据时，当小端法机器产生的数据被发送到大端法机器或者反过来时，接收程序会发现，字里的字节成了反序的

> [!tip]
> 
> 网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则，以确保发送方机器将它的内部表示转换成网络标准，而接收方机器则将网络标准转换为它的内部表示
> 

下面的一段 C 代码用于显示不同程序对象的字节表示

```c
#include <stdio.h>

typedef unsigned char *byte_pointer;

void show_bytes(byte_pointer start, size_t len)
{
    size_t i;
    for(i = 0; i < len; i++)
    {
        // "%.2x" 整数最少使用 2 位数字以十六进制输出
        printf(" %#.2x", start[i]);
    }
    printf("\n");
}

void show_int(int x)
{
    show_bytes((byte_pointer)&x, sizeof(int));
}

void show_float(float x)
{
    show_bytes((byte_pointer)&x, sizeof(float));
}

void show_pointer(void *p)
{
    show_bytes((byte_pointer)p, sizeof(void *));
}

void test_show_bytes(int val)
{
    int ival = val;
    float fval = (float) val;
    int *pval = &ival;
    show_int(ival);
    show_float(fval);
    show_pointer(pval);
}

int main()
{
    test_show_bytes(12345);
}
```

## 表示字符

C 语言中字符串被编码为一个以 `null` （其值为 $0$) 字符结尾的字符数组。每个字符都由某个标准编码来表示，最常见的是 ASCII 字符码。如下方式调用 `show_bytes`


```c
int main()
{
    const char * s = "abcdef";
    show_bytes((byte_pointer)s, strlen(s)); // 0x61 0x62 0x63 0x64 0x65 0x66
}
```

在使用 ASCII 码作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小规则无关。因而，**文本数据比二进制数据具有更强的平台独立性** 。

## 表示代码

现代计算机都是基于冯诺依曼模型构建的计算机，冯诺依曼模型最重要的就是 **存储程序**。程序被编码为机器代码(位模式)，存储在内存中

**不同的机器类型使用不同的且不兼容的指令和编码方式** 。 即使是完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此 **二进制代码是不兼容的**

> [!tip]
> 
> 二进制代码很少能在不同机器和操作系统组合之间移植
> 

计算机系统的一个基本概念就是，从机器的角度来 看 ，**程序仅仅只是字节序列** 。 **机器没有关于原始源程序的任何信息**，除了可能有些用来帮助调试的辅助表以外 
