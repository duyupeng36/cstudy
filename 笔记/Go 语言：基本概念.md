# 基本概念

## 注释

**注释用于解释说明代码**，提供程序可读性。在编写程序时，我们应该尽量的书写注释。方便后续维护我们的代码。Go 语言提供了两种注释风格：**块注释**  和  **行注释**

> [!tip] 
> 
> **块注释**：与 C 语言的注释风格相同，即使用符号 `/*` 标记注释起始位置，使用 `*/
`  符号标记注释结束位置。
>
> 在使用块注释时，需要注意， 在 `/* ... */` 之间，不能嵌入 `*/` 这样连续的符号。除此之外，没有其他任何要求
> 

```go
/* 
第一行
第二行
*/
```

> [!tip] 
> 
> **行注释**：与 C++ 的注释风格相同。即使用 `//` 标记注释起始位置，随后直到该物理行整行都是注释内容
> 

```go
// 行注释
// 行注释
```

在 Go 语言中 **行注释是常态**。但在 _表达式内_ 或要 _禁用大量代码_ 时，块注释也很有用。对函数、结构体进行注释时，习惯把注释写在上面；对包进行注释会写在 `package` 之上

```go
// main 包注释，解释包的作用
package main

import "fmt"

// add takes two integers and returns the sum of them
// 这是函数的说明文档
func add(a, b int) int {
	// This is a comment
	return a + b
}

func main() {
	/* this is also a comment */
	result := add(1, 2) // Call function add
	fmt.Println(result) // Print result (3)
}
```

此外，Go 语言可以使用一些提示词进行注释，方便进行文档生成

```go
// TODO: 将来完成，推荐
// NOTE: 请注意
// Deprecated: 告知已经过期，建议不要使用。未来某个版本可能移除
```

## 标识符

**标识符**(`identifier`) 是一个用来 **标识对象的名字**。通俗的来说，就是程序员自行定义的具有特殊含义的单词

Go 语言规定的标识符的命名规则有下面三条
+ 标识符只能由 **数字**、**Unicode 字母** 以及 **下划线** 组成
+ 并且 **数字不能作为标识符的开头**
+ 标识符 **区分字母大小写**
+ 标识符不能是 **关键字**
+ 标识符不建议是 **预定义标识符**

> [!important] 
> 
> 注意，通常我们只使用 ASCII 字符集中的 $26$ 个英文字母的大小写
> 

下面是一些标识符命名的示例

```go
// 正确的命名

name
age
_sys

// 错误的命名
&age  // 错误：& 表示取地址
*age  // 错误：* 表示解引用
1name  // 错误：数字不能开头
```

### 关键字

Go 语言只提供 $25$ 个关键字，极大的减少了初学者的记忆负担。请注意，下面列出的是 Go 语言中的 **关键字**。所谓关键字就是语言本身使用了的标识符，不允许程序员再使用

```go
break        default      func         interface    select
case         defer        go           map          struct
chan         else         goto         package      switch
const        fallthrough  if           range        type
continue     for          import       return       var
```

### 预定义标识符

预定义标识符是语言提供的具有默认含义的标识符。**不建议使用这些预定义标识符** 作为自定义标识符

```go
Types:  // 预定义类型
	any bool byte comparable
	complex64 complex128 error float32 float64
	int int8 int16 int32 int64 rune string
	uint uint8 uint16 uint32 uint64 uintptr
	
Constants:  // 预定义常量
	true false iota
	
Zero value:  // 零值常量
	nil
	
Functions:  // 内置函数
	append cap close complex copy delete imag len
	make new panic print println real recover
```

这些内部预先定义的名字并不是关键字，可以在定义中重新使用它们。在一些特殊的场景中重新定义它们也是有意义的，但是也要注意避免过度而引起语义混乱

## 变量

在计算机科学中，我们通常将一块 **内存区域** 称为 **对象**，内存中存储了一串 **位模式**；所谓的位模式就是指由 $0$ 或者 $1$ 组成的序列。程序执行环境中执行时，会通过这个 **对象的地址** 引用这个对象，此时，执行环境就会按照程序指定 **类型** 解释这个对象中保存的位模式

在高级编程语言中，为了方便我们访问内存区域中的值，高级编程语言提供了一个称为 **变量** 的抽象概念用于表示一个对象

> [!important] 
> 
> 换句话说，变量本质上就是一块 **数据存储区域**，其中存储的 **位模式** 可用于表示 **值**。变量 **被引用** 时，会根据特定的 **类型** 解释其内容(位模式)
> 

如何引用一个变量呢？在大部分程序设计语言中，采用 **变量名** 引用一块内存区域(对象)。下图形象的表示一个变量

![[Pasted image 20241004004409.png]]

### 声明变量

**变量需要声明后才能使用**，在 Go 语言中，声明变量的语法如下

```go
var identifier Type
```

其中 `var` 是声明变量的关键字；`identifier` 是标识符；`Type` 是变量的类型

```go
package main

func main() {
	var name string
	var age int
}
```

>[!tip]
> 
> 这里，我们只需要知道三中类型即可，分别是
> + 字符串 `string`
> + 整数 `int`
> + 浮点数 `float64`
>   
>  其他类型，我们后续会介绍
> 

此外，`var` 关键字还可以进行 **批量变量声明**，只需要在将 `var` 关键字之后使用括号 `()` 

```go
package main

func main() {
	var (
		name string
		age  int
	)
}
```

### 初始化

Go 语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的 **零值**。这种机制称为 **零值初始化**，确保每个声明的变量总是有一个良好定义的值，因此 **在 Go 语言中不存在未初始化的变量**
+ 整型和浮点型变量的默认值为 $0$
+ 字符串变量的默认值为空字符串`""`
+ 布尔型变量默认为`false`
+ 切片、函数、指针变量的默认为`nil`

变量初始化的语法使用 ` = 表达式` 的方式进行。例如，

```go
package main

func main() {
	var (
		name string = "张珊"
		age  int    = 20
	)
}
```

### 类型推导

在声明变量时，如果提供了初始值，Go 编译器可以根据初始化表达式的类型自行推导变量的类型

```go
package main

func main() {
	var (
		name = "张珊"  // 推导类型为 string
		age  = 20      // 推导类型为 int
	)
}
```

### 短变量声明

如果在 **函数内部** 声明变量，可以使用 `:=` 形式的短变量声明语句

```go
package main

func main() {
	name := "张珊"
	age  := 20
}
```

使用 `:=` 也可以同时声明多个变量。例如

```go
package main

func main() {
	name, age := "张珊", 20
}
```

> [!attention] 
> 
> 请注意：使用短变量声明语句声明多个变量时，只需要创建一个新变量即可
> 

```go
package main

func main() {
	name, age := "张珊", 20
	// name, age := "张三", 20  // ERROR:重复定义
	name, gender := "张三", "男" // OK: 新声明了变量 gender
}
```

### 匿名变量

如果我们接收到多个变量，有一些变量使用不到，可以使用 **下划线`_`表示变量名称**，这种变量叫做 **匿名变量**。例如：标准包 `os` 中有一个函数 `Openfile()` 会返回一个文件对象和错误。如果不关心错误，就可以使用匿名变量

```go
package main

import "os"

func main() {
	f, _ := os.Openfile("test.txt")
}
```

## 常量

**常量**，就是在程序 **编译时** 就确定下来的值，而程序在 **运行时** 则不能改变值。与变量一样，常量也需要先声明，并且在声明时就应该为常量赋值。

在 Go 语言中，声明常量使用 `const` 关键字，除此之外，与声明变量无任何差异

```go
const PI float64 = 3.14

const (
	width  int = 100
	height int = 200
)
```

### 常量种类

Go 语言中的常量分为两种：**类型化常量(typed constant)** 和 **非类型化常量(untype constant)**

Go 将常量分为两种类型：**类型化常量**(`typed constant`)和**非类型化常量**(`untyped constant`)

> **类型化常量**：使用 `const` 关键字定义常量时，明确说明了这个常量的类型

例如，常量 `age` 如下声明，明确了 `age` 是 `int` 类型

```go
const age int = 10        // age 是类型化常量
```

> **非类型化常量**：使用 `const` 关键字定义常量是，没有说明这个常量的类型

例如，常量 `name` 如下声明，没有指定 `name` 是什么类型。

```go
const name = "dyp"        // name 是非类型化的常量
```

> [!important] 
> 
> **重要**： 所有的字面值都是非类型化常量，非类型化常量具有一个 **默认类型**。后续会介绍各种字面值的默认类型。
> 

非类型化常量可以赋值给类型化常量或变量，因为在需要的时候，**非类型化常量可以被 Go 编译器 _自动转换_ 为当前上下文需要的类型**。如下示例，说明了非类型化常量可以自动进行类型转换

```go
const a = 10
var b float64 = 10

result := a + b // 非类型化常量 a 被编译器自动转换为了 float64
fmt.Println(result)  // 20
```

如果 `a` 是类型化常量，`a + b` 则会报错

```go
const a int = 10  // 类型化常量
var a float64 = 10

result := a + age 
// invalid operation: a + age (mismatched types float64 and int)
fmt.Println(result)
```

> [!warning] 
> 
> **警告**：并非所有非类型化常量都能自动转换完成。Go 自动类型转换是 **禁止窄化类型转换**
> 

```go
const PI = 3.1415926535
var r = 10
result := PI * r * r
// 错误 PI (untyped float constant 3.14159) truncated to int
```

这里 `PI` 是非类型化常量，在执行类转换时，将 `float64` 类型转换为 `int` 类型发生截断。Go 不允许这样的自动类型转换

### iota 常量

在声明常量时，编译器会在 `const` 关键字出现的时候，将预定义常量 `iota` 初始化为 $0$；然后每增加一行常量声明，`iota` 的值就会被编译器加 $1$

下列程序验证了每次 `const` 已出现，预定义常量 `iota` 的值就被编译器设置为了 $0$ 

```go
package main

import "fmt"

func main() {
	const iota1 = iota 
	// iota 是一个特殊的常量，可以被编译器修改的常量
	const iota2 = iota
	fmt.Println(iota1, iota2) // 0 0
}
```

通常，要在批量常量声明时，才会使用预定义常量 `iota`。`const` 中每新增一行常量声明将使 `iota` 计数一次(加`1`) 

```go
const (
	a, b = iota + 1, iota + 2 // 1, 2
	c, d                      // 2, 3
	e, f                      // 3, 4
)
```

> [!tip] 
> 
> 可以将 `iota` 理解为常量批量声明中的 **行索引**。与在同一行声明的常量个数无关，只与行数有关
> 

```go
// iota 从 0 开始，即使第一行没有写 iota，iota 也从第一行开始从 0 开始增加
const (
	a = iota // 0
	b        // 1
	c        // 2
	_        // 按道理是3，但是丢弃了
	d        // 4
	e = 10   // 10
	f        // 10
	g = iota // 6
	h        // 7
)
// 可以认为 Go 的 const 批量定义实现了一种重复上一行机制的能力
```

Go 语言的 `const` 批量声明实现了一种重复上一行表达式的能力。应用这个能力，我们可以声明一批符合我们期望的常量。例如，声明一批偶数

```go
// 批量写iota从0开始，智能重复上一行公式
const (
	a = 2 * iota // 0
	b            // 2
	c            // 4
	d            // 6
)
```

利用 `iota` **智能重复计算上一行表达式的值**，可以用于定义一些枚举值。例如，**定义数量级**

```go
package main

import "fmt"

func main() {
	const (
		_  = iota
		KB = 1 << (10 * iota) // 1 << (10 * 1)
		MB                    // 1 << (10 * 2)
		GB                    // 1 << (10 * 3)
		TB                    // 1 << (10 * 4)
		PB                    // 1 << (10 * 5)
	)
	fmt.Println(KB, MB, GB, TB, PB)
}
```

## 基本数据类型

Go 语言内建了丰富的数据类型，在介绍数据类型之前，我们需要明白 **什么是类型？**

我们知道计算机中能够存储的只能是 $0$ 或 $1$，即 **二进制序列**，也称 **位模式**。然而，位模式并没有特殊的含义。换句话说，计算机中相同的位模式可能在表示含义不同。给位模式赋予含义的就是我们所说的类型

> [!tip] 
> 
> 简单来说，**类型就是明确位模式如何解释的**
> 

在计算机中，位模式通常按照 $8$ 位进行分组，称为 **字节**。不同类型可能占用不同长度的位模式。下面我们就介绍 Go 语言中的 **基本数据类型**

### 整数类型

由于计算机中只能存储位模式，整数也需要使用位模式表示。有两种方式解释用于表示整数位模式：**无符号编码** 和 **补码编码**

出现这两编码方式的原因就是整数既有正数又有负数。无符号编码只能表示非负数，补码编码为了表示负数而诞生的

> [!tip] 
> 
> 由于计算机中只能存储 $0$ 或 $1$，对于负整数的负号，通常使用位模式的最高位表示
> + 最高位为 $1$ 表示负数
> + 最高位为 $0$ 表示正数
> 
> 除了最高位以为，其余位表示数值，这种编码方式称为 **原码**。原码编码存在一个缺点，就是整数 $0$ 的编码方式有两种。以长度为 $1$ 字节的位模式为例：
> 
> + $+0$ 的原码为 `00000000`
> + $-0$ 的原码为 `10000000`
> 
> 无论是 $+0$ 还是 $-0$ 都是同一个整数。显然，这样做是不合理的。然而，这不是最大的问题。最大的问题是使用原码表示会让 CPU 中加法器设计变复杂。因此，我们引入了另一种编码方式 **反码**。
> 
> 在反码编码方式中，对于正数而言，**表示方式与原码相同**；然而，对于负数，**符号位保持不变，数值位是按位取反**
> + `+0` 的反码为 `00000000`
> + `-0` 的反码为 `11111111`
> 
> 这虽然没有解决同一个整数有两种编码的缺陷。但是，使用反码会简化 CPU 加法器的设计。因为，**减去一个数等于加上这个数的负数**
> 
 
关于原码和反码，我们只需要了解即可。因为，计算机中并不是这两种编码方式

#### 无符号编码

位模式 $[w_{n-1}, w_{6}, \cdots, w_{1}, w_{0}]$ 表示的整数为

$$
B2U_n([w_{n-1}, w_{6}, \cdots, w_{1}, w_{0}])=\sum_{i=0}^{n-1}w_i2^{i}
$$

其中 $B2U_n$ 是一个函数，表示将 $n$ 位的位模式映射到一个无符号整数上。例如

$$
\begin{aligned}
&B2U_4([0001]) = 0 \cdot 2^3 + 0 \cdot 2^2 + 0 \cdot 2^1 + 1 \cdot 2^0 = 0 + 0 + 0 + 1 = 1  \\ 
&B2U_4([0101]) = 0 \cdot 2^3 + 1 \cdot 2^2 + 0 \cdot 2^1 + 1 \cdot 2^0 = 0 + 4 + 0 + 1 = 5\\
&B2U_4([1011]) = 1 \cdot 2^3 + 0 \cdot 2^2 + 1 \cdot 2^1 + 1 \cdot 2^0 = 8 + 0 + 2 + 1 = 11 \\
&B2U_4([1111]) =1 \cdot 2^3 + 1 \cdot 2^2 + 1 \cdot 2^1 + 1 \cdot 2^0 = 8 + 4 + 2 + 1 = 15 
\end{aligned}
$$

> [!tip] 
> 
> 一个长度为  $w$ 位的位模式能表示的无符号数值的范围
> +  **最小值** 使用位向量 $[0,0,\cdots, 0,0]$ 表示，也就是整数 $0$
> + **最大值** 使用位向量 $[1,1,\cdots,1,1]$ 表示，也就是整数 $UMax_{w}=\sum_{i=0}^{w-1}2^i=2^w-1$
> 

无符号数的二进制表示有一个很重要的属性，也就是每个介于 $0 \sim 2^w - 1$ 之间的数都有唯一一个 $w$ 位的编码

#### 补码编码

最常见的有符号数的计算机表示方式就是 **补码**。在这个定义中，**将字的最高有效位解释为负权**。也就是说，位模式$\left[w_{n-1}, w_{n-2} \cdots, w_2,w_1,w_0\right]$ 表示的整数为

$$
B2T_{w}(\vec{x}) = -x_{w-1}\cdot 2^{w-1} + \sum_{i=0}^{w-2}x_{i}\cdot 2^{i}
$$

最高有效位 $x_{w-1}$ 也称为 **符号位**，它的 **权重** 为 $—2^{w-1}$ 。这样，如果符号位被设置为 $1$ 时，则为负整数；符号位被设置为 $0$ 时，则为非负整数。例如

$$
\begin{aligned}
&B2T_4([0001]) = - 0 \cdot 2^3 + 0 \cdot 2^2 + 0 \cdot 2^1 + 1 \cdot 2^0 = 0 + 0 + 0 + 1 = 1  \\ 
&B2T_4([0101]) = - 0 \cdot 2^3 + 1 \cdot 2^2 + 0 \cdot 2^1 + 1 \cdot 2^0 = 0 + 4 + 0 + 1 = 5\\
&B2T_4([1011]) = -1 \cdot 2^3 + 0 \cdot 2^2 + 1 \cdot 2^1 + 1 \cdot 2^0 = -8 + 0 + 2 + 1 = -5 \\
&B2T_4([1111]) =-1 \cdot 2^3 + 1 \cdot 2^2 + 1 \cdot 2^1 + 1 \cdot 2^0 = -8 + 4 + 2 + 1 = -1 
\end{aligned}
$$

> [!tip] 
> 让我们来考虑一下长度为 $w$ 的位模式采用补码编码时能表示的值的范围
> +  **最小值**：补码编码能表示的最小值的位向量为 $[1,0,\cdots,0,0]$，也就是设置这个位为负权，但是清除其他所有的位；其整数值为 $TMin_{w} = -2^{w}-1$
> + **最大值**： 补码编码能表示的最大值的位向量为 $[0,1,\cdots,1,1]$，也就是清除具有负权的位，而设置其他所有的位；其整数值为 $TMax_{w} = 2^{w-1}-1$

那么如何获将十进制负整数转换为二进制补码表示？这里我们需要补充两个概念：**补数** 与 **减补数**

> [!tip] 
> 
> 自然数 $a$ 在给定进制 $N$ 下的 **补数** 定义为：对于给定的 **进制 $N$**，与自然数 $a$ 相加后使得 **位数** 增加 $1$ 的最小的数
> 
> + $b$ 进制数 $a$ 关于 **基数的补数** ($b$ 的补数): $b^n−a$
> 
> + $b$ 进制数 $a$ 关于 **减基数的补数** ($b - 1$ 的补数)，简称 **减补数**、侪补数): $b^n-a-1$
> 
> 其中 $n$ 为当前 $b$ 进制数 $a$ 的位数
> <br/>
> 例如，在 $10$ 进制下，$79$ 的补数就是 $10^2 - 79=21$
> 
> 用数学语言描述补数的定义：对于 $N$ 进制的自然数 $a=a^ra^{r−1}a^{r−2} \cdots a^1a^0$ 规定数 $b$ 的各位为 $b_i=(N+1)+a_i$。称数$b$ 为 $a$ 关于 $N+1$ 的 **补数**
> 

在二进制下，求 $1$ 补数只需简单地将 $0$ 与 $1$ 相互替换。求 **2 补数** (即 **补码**)，只需要将 $1$ 补数加 $1$。所以，为了求一个二进制数的 $2$ 补数，只需要先求 $1$ 补数，然后在加 $1$ 即可

求十进制负整数的二进制补码表示，需要将该十进制负整数的绝对值转换为二进制表示，然后先对该二进制表示求 $1$ 补数，然后加 $1$ 即可得到该负数的二进制补码表示

例如，对于 $-1$ 采用 $8$ 位位模式表示时，其绝对值 $1$ 的二进制表示为 $00000001$，求 $1$ 补数之后为 $11111110$，在加 $1$ 得到 $11111111$

```
-1 的绝对值 1 的 8 位二进制表示为

0000 0001

其 1 补数为

1111 1110

2补数等于 1补数加1

1111 1111
```

#### 整数类型

Go 语言根据是否有符号以及位模式的大小提供了 $8$ 种与机器无关的整数类型

| 类型       | 描述                                                            |
| :------- | :------------------------------------------------------------ |
| `uint8`  | 长度为 $8$ 位的无符号整数，表示的整数范围为 $[0, 255]$                           |
| `uint16` | 长度为 $16$ 位的无符号整数，表示的整数范围为 $[0, 65535]$                        |
| `uint32` | 长度为 $32$ 位的无符号整数，表示的整数范围为 $[0, 4294967295]$                   |
| `uint64` | 长度为 $64$ 位的无符号整数，表示的整数范围为 $[0, 18446744073709551615]$         |
|          |                                                               |
| `int8`   | 长度为 $8$ 位的有符号整数，表示的整数范围为 $[-128, 127]$                        |
| `int16`  | 长度为 $16$ 位的有符号整数，表示的整数范围为 $[-32768, 32767]$                   |
| `int32`  | 长度为 $32$ 位的有符号整数，表示的整数范围为 $[-2147483648, 2147483647]$         |
| `int64`  | 长度为 $64$ 位的有符号整数，$[-9223372036854775808,9223372036854775807]$ |

此外，Go 也提供了与机器相关的整数类型，即 `int` 和 `uint`，分别表示有符号整数和无符号整数

#### 字面值

整数字面值表示 **整数常量** 的数字序列。通过 **前缀** 指定使用不同的表示方式，默认采用 **十进制** 数字。下面列出了 Go 语言支持的整数字面值

+ `0b` 或 `0B` 表示 **二进制** 
+ `0` `0o` 或 `0O` 表示 **八进制**
+ `0x` 或 `0X` 表示 **十六进制**。Go 1.13 版本开始支持

> [!tip] 
> 
> 整数字面值都是 `untyped constant`，默认的类型为 `int`
>  

```go
package main

import "fmt"

func main() {
	// 有符号整数
	var i1 int8 = 127   // 十进制
	var i2 int8 = -0x7f // 十六进制
	var i3 int8 = 0o177 // 八进制
	fmt.Println(i1, i2, i3)

	// 无符号整数
	var u1 uint8 = 256 
	// cannot use 256 (untyped int constant) as uint8 value in variable declaration 
	var u2 uint8 = 0xFF
	var u3 uint8 = 0o377
	fmt.Println(u1, u2, u3)
}
```

> [!attention] 
> 
> 请注意：当我们使用整数字面值赋值给一个变量时，Go 语言不允许使用超出类型的取值范围的字面值给变量赋值(溢出)
> 

#### 数字系统

**数字系统** 定义了 **如何用独特的语言符号来表示一个数字**。任何语言的符号的数量都是有限的，需要重复并组合它们。由于我们使用有限的数字符号来表示无限的数字，这意味着符号需要重复使用

如今广泛使用的数字系统有：**位置化系统** 和 **非位置化系统**。**我们主要关注位置化系统**。在 **位置化数字系统** 中，**数字中符号所占据的位置诀定了其表示的值**

在位置系统中，采用 **进制** 表示不同的位置系统，在计算机中常用的位置系统有：**十进制位置系统**、**二进制位置系统**、**八进制位置系统** 和 **十六进制位置系统**

> [!tip] 
> 
> 所谓的 **进制** 就是用于表示数字的符号个数
> 

在该数字系统中，数字的表示形式为

$$
\pm (S_{K-1}\ldots S_2S_1S_0.S_{-1}S_{-2}\ldots S_{-L})
$$

表示的值 $N$

$$
N = \pm(S_{K-1} \times b^{K-1} + \ldots + S_1\times b^{1}+ S_0\times b^{0}+S_{-1}\times b^{-1}\ldots+S_{-L}\times b^{-L})
$$

其中， $S$ 是数字符号集；$b$ 是基数(底)，等于数字符号集合 $S$ 中符号的个数

在计算机科学中，常用的数字系统有 $4$ 种，如下表列出

|数字系统|符号集合|基数|
|:---|:---|:---|
|十进制|$\{0, 1, 2, 3, 4, 5, 6, 7, 8, 9\}$|$10$|
|二进制|$\{0, 1\}$|$2$|
|八进制|$\{0, 1, 2, 3, 4, 5, 6, 7,\}$|$8$|
|十六进制|$\{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F\}$|$16$|

### 浮点数

理解浮点数的第一步是考虑含有小数值的二进制数字。首先，让我们来看看更熟悉的十进制表示法。十进制表示法使用如下形式的表示：

$$
d_{m}d_{m-1}\cdots d_{1}d_{0}.d_{-1}d_{-2}\cdots d_{-n}
$$
其中，$d_{i}$ 是十进制数字 $0\sim 9$。这个表示法描述的数值 $d$ 定义如下

$$
d = \sum_{i=-n}^{m}10^i \times d_i
$$

例如 $12.34_{10}$ 表示的就是数字 $1\times 10 + 2 \times 10^0 + 3 \times 10^{-1} + 4 \times 10^{-2}=12\frac{34}{100}$

类似的，考虑二进制表示法使用如下形式表示

$$
b_{m}b_{m-1}\cdots b_{1}b_{0}.b_{-1}b_{-2}\cdots b_{-n}
$$

其中，$b_{i}$ 是二进制数字 $0\sim 1$。这个表示法描述的数值 $b$ 定义如下

$$
b = \sum_{i=-n}^{m}2^i \times b_i
$$

例如，$101.11_{2}$ 表示的就是数字 $1\times 2^2 + 0\times 2^1 + 1\times 2^0+1\times 2^{-1} + 1\times 2^{-2} =5\frac{3}{4}$

上述表示法称为 **定点表示法**，但是结果不一定精确或达不到要求精度。同时，**很大的整数部分或很小的小数部分不应该采用定点表达式**

为了提高表示精度，我们采用 **浮点数** 表示法。回忆中学阶段学习的 **科学计数法**，如下所示，这是十进制的科学计数法

$$
\text{Value} = (-1)^\text{Sign} \times \text{Fraction} \times 10^ \text{Exponent}
$$

我们期望只使用 `Sign`、`Fraction` 和 `Exponent` 三个数字表示任意一个数字，那么这些数字如何存放呢？IEEE 754 标准规定两种存储格式：**单精度浮点数** 和**双精度浮点数**，如下图所示

![[Pasted image 20250602160316.png]]

> [!tip] 
> 
> 符号位 `s` 占 $1$ 位；指数位 `exp` 占 $8$ 位或 $11$ 位，剩余的位存放尾数 `frac`
> 
> 单精度浮点表示总共占 $32$ 位，符号位占 $1$ 位，指数位占 $8$ 位，剩余 $23$ 位用于存储尾数
> 
> 双精度浮点表示总共占 $64$ 位，符号位占 $1$ 位，指数位占 $11$ 位，剩余 $52$ 位用于存储尾数
> 

**显然双精度浮点表示得到结果更精确**。指数有正数也有负数，为了统一，我们会给指数加上一个 **偏置**  $2^{m-1}-1$，$m$ 为存储指数的位数。这样，指数的表示就不用区分正负了。此外，为了使表示法与定点数部分统一，**小数点左边仅保留一个非零数码**，这称为 **规范化**。

#### 浮点类型

Go 语言提供了两种精度的浮点数，`float32` 和 `float64`。它们的算术规范由 [IEEE 754](https://zh.wikipedia.org/wiki/IEEE_754) 浮点数国际标准定义，该浮点数规范被所有现代的 CPU 支持

|    类型     |   大小   | 范围                                            | 备注                       |
| :-------: | :----: | :-------------------------------------------- | ------------------------ |
| `float32` | $32$ 位 | $[-3.4\times 10^{38}, 3.4\times 10^{38}]$     | 最大值定义在 `math.MaxFloat32` |
| `float64` | $64$ 位 | $[-1.8 \times 10^{308}, 1.8 \times 10^{308}]$ | 最大值定义在 `math.MaxFloat64` |


> [!attention] 
> 
> 注意：**`float32` 与 `float64` 类型的变量不能相互赋值。是两个不同的数据类型**
> 

下面的例子展示了如何声明 `float32` 类型的变量

```go
package main  
  
import (  
    "fmt"  
    "math")  
  
func main() {  
    var x float32 = 123.78  
    var y float32 = 3.4e+38  
    var max_flaot32 = math.MaxFloat32  
    fmt.Printf("Type: %T, value: %v\n", x, x)  
    fmt.Printf("Type: %T, value: %v\n", y, y)  
    fmt.Printf("Type: %T, value: %v", max_flaot32, max_flaot32)  
}
```

`float32` 类型在采用 IEEE 754 标准的浮点数中尾数只有 $23$ 位。`float64` 类型在采用 IEEE 754 标准的浮点数中尾数有 $52$ 位。`float64` 类型能够提供更高的精度，应该优先使用 `float64` 类型，因为 `float32` 类型的累计计算误差很容易扩散。当整数大于 $23$ 位能表达的范围时，`float32` 的表示将出现误差

```go
var f float32 = 16777216 // 1 << 24
fmt.Println(f == f+1)    // "true"!
```

#### 字面值

浮点字面值是浮点常量的 **十进制** 或 **十六进制** 表示形式

##### 十进制浮点字面值

十进制浮点字面值由 **整数部分**、**小数点**、**小数部分** 和 **指数部分**
- **_整数部分_ 和 _小数部分_ 采用 十进制数表示**，其中的某个部分可以省略
- 指数部分由 `e` 或 `E` 后的 **可选符号(`-` 或 `+`)** 和 **十进制数** 组成。指数值 `exp` 将尾数（整数和小数部分）缩放 $10^{\text{exp}}$

下面给出了几个十进制浮点字面值示例

```go
0.
72.40
072.40         // == 72.40
2.71828
1.e+0
6.67428e-11    
1E6           // == 1 * 10 ^ 6
.25
.12345E+5     // == 12345.0
1_5.          // == 15.0
0.15e+0_2     // == 15.0
```

##### 十六进制浮点字面值

从 Go 1.13+ 开始支持十六进制的浮点数字面值。十六进制浮点字面值由  **前缀 `0x` 或 `0X` **、**整数部分**(十六进制数字)、**小数点**、**小数部分**(十六进制数字) 和 **指数部分** 组成( `p` 或 `P` 后跟可选的符号和十进制数)
- **整数部分** 或 **小数部分** 可以省略其中任意一项
- **小数点也可以省略**，但 **指数部分是必需的**
- 指数值 `exp` 将尾数（整数和小数部分）缩放 $2^{\text{exp}}$

下面给出了完整十六进制字面值的表示。中括号包围的表示可以省略

```
{0x | 0X} {0-9 a-f} . {0-9 a-f} p {[+ | -] 0-9}
```

下面是几个十六进制浮点字面值的示例

```
0x1p-2       // == 0.25
0x2.p10      // == 2048.0
0x1.Fp+0     // == 1.9375
0X.8p-0      // == 0.5
0X_1FFFP-16  // == 0.1249847412109375
0x15e-2      // == 0x15e - 2 (integer subtraction)
```

> [!important] 
> 
> 浮点数字面值是 `untyped constant`，**默认类型是 `float64`**
> 

### 布尔类型

布尔类型用于表示逻辑值。在 Go 语言中，类型 `bool`的值只有两个预定常量，分别是 `true` 和 `false`

> 请注意：Go 语言与其他语言不同。类型 `bool` 是一个独立的类型， 

如果你学过 Python 语言或者其他语言，你可能见过这样的表达式

```python
x = 1 + True
```
这种表达式在 Go 语言中是不成立，会抛出语法错误。因为，Go 语言中的 `bool` 类型不能转换为其他类型。

### 字符类型

在任何地区的语言中，**文本** 片段是用来 **表示该语言中某个意思的一系列的符号**。例如，在英语中使用 $26$ 个符号(`A, B, C, ...., Z`) 来表示大写字母，$26$ 个符号 (`a, b, c, ...., z`) 表示小写字母，$10$ 个符号(`0, 1, 2, ...., 9`)来表示数字字符(不是实际的数字)，以及符号 (`. ? :  ; .... !`) 来表示标点。另外一些符号 (`空格、换行和制表符`) 被用于文本的对齐和可读性

为了在计算机中存储文本，我们 **可用 _位模式_ 来表示任何一个符号**。换句话说，如 $4$ 个符号组成的文本 `"CATS"` 用 $4$ 个 $n$ 位模式表示，任何一个位模式定义一个单独的符号

不同的位模式集合被设计用于表示文本符号。其中每一个位模式我们称之为代码， **表示符号的过程被称为 _编码_**

> [!important] 
> 
> **位模式的长度取决于符号的数量**，但是它们的关系并不是线性的，而是对数的；即，如果需要编码 $N$个符号，长度将是 $\log_2 N$
> 

目前使用最广泛的编码方式有两种 **ASCII 编码** 和 **Unicode 编码**

#### ASCII 编码
美国国家标准协会(ANSI)开发了一个被称为 **美国信息交换标准码**(ASCII)的字符编码集。该编码集使用 $7$ 位表示每个符号。即该代码可以定义 $2^7=128$ 种不同的符号。

ASCII 字符集可以被分为 **可打印字符** 和 **控制字符**。下表来源于 [ASCII 字符集](https://www.runoob.com/w3cnote/ascii.html)。

![](https://i-blog.csdnimg.cn/direct/40581b5a59ca4a4891a7c9826e7dc460.png)![](https://i-blog.csdnimg.cn/direct/d716649e38d842da89cbce20d5f2266b.png)
关于 ASCII 字符集我们需要记忆几个关键的字符的编码

|         字符         |    位模式     | 十进制  |  十六进制   |
| :----------------: | :--------: | :--: | :-----: |
| `NULL` 字符 (`'\0'`) | `000 0000` | `0`  | `0x00 ` |
| `SPACE` 字符 (`' '`) | `010 0000` | `32` | `0x20 ` |
|  `HT` 字符 (`'\t'`)  | `000 1001` | `9`  | `0x09 ` |
|  `CR` 字符 (`'\r'`)  | `000 1101` | `13` | `0x0d ` |
|  `LF` 字符 (`'\n'`)  | `000 1010` | `10` | `0x0a ` |
|  `VT` 字符 (`'\v'`)  | `000 1011` | `11` | `0x0b ` |
|  `FF` 字符 (`'\f'`)  | `000 1100` | `12` | `0x0c ` |
|      字符 `'0'`      | `011 0000` | `48` | `0x30 ` |
|      字符 `'1'`      | `011 0001` | `49` | `0x31 ` |
|      字符 `'A'`      | `100 0001` | `65` | `0x41 ` |
|      字符 `'a'`      | `110 0001` | `97` | `0x61`  |

#### Unicode 编码

随着计算机在全世界的普及和互联网的发展，让计算机能处理特定区域的文本迫在眉睫。每个地区都设计了能够处理当地文本的字符集。例如，中国的 `GB/T 2312, GBK`，日本的 `Shift JIS` 等编码

由于不同地区使用的字符集编码方式不同，在不同国家间就会经常出现不兼容的情况。很多传统的编码方式都有共同的问题，即容许电脑处理双语环境（通常使用拉丁字母以及其本地语言），但却无法同时支持多语言环境（指可同时处理多种语言混合的情况）。

> 同一个位模式在不同的字符集中可能表示不同的字符，从而会造成乱码的情况

为此，硬件和软件制造商联合起来共同设计了一种名为 `Unicode` 的代码，称为 **统一码**。它 **为每一个字符而非字形定义唯一的代码（即一个整数）**

> 统一码以一种抽象的方式（即数字）来处理字符。并将字体大小、外观形状、字体形态、文体等工作留给其他软件来处理

Unicode 编码系统可分为 **编码方式** 和 **实现方式** 两个层次

###### 编码方式

Unicode 最基本的编码方式是 **UCS-2**  使用 $2$ 字节存储每个编码，这样理论上最多可以表示 $2^{16} = 65536$ 个字符。然而，当前 Unicode 编码并未使用这种基本的方式，而是采用 $4$ 字节编码，保留了大量空间以作为特殊使用或将来扩展；这种编码方式称为 **UCS-4**

最新（但未实际广泛使用）的统一码版本定义了 $16$ 个辅助平面，两者合起来至少需要占据 $21$ 位的编码空间，比 $3$ 字节略少。但事实上辅助平面字符仍然占用 $4$ 字节编码空间，与 **UCS-4** 保持一致

###### 实现方式
Unicode 编码方式确定了字符的二进制表示。但是，需要存储字符串时，如何存储呢？首先就是直接存储这些编号的位模式。如下实例

```
"hello, 世界!"
字符 编号(hex)  位模式
h    68        01101000
e    65        01100101
l    6c        01101100
l    6c        01101100
o    6f        01101111
,    2c        00101100
     20        00100000
世   4E16      01001110 00010110
界   754C      01110101 01001100
!    21        00100001

011010000110010101101100011011000110111100101100001000000100111000010110011101010100110000100001
```

> 直接存储字符的位模式有一个棘手的问题！**如何区分字符边界？**

首先想到的就是按照编码最长的位模式存储，不足的在左边使用 $0$ 补齐位模式。比如，按照 UCS-2 标准编码的字符，需要如下方式存储 `"hello, 世界!"` 

```
00000000 01101000
00000000 01100101
00000000 01101100
00000000 01101100
00000000 01101111
00000000 00101100
00000000 00100000
01001110 00010110
01110101 01001100
00000000 00100001
```

> 好多字节存储的都是 $0$，这些 $0$ 都是无效为，比较浪费内存

---

一个字符的 Unicode 代码是确定。但是在实际传输过程中，由于不同系统平台的设计不一定一致，以及 **出于 _节省空间_ 的目的**，对 Unicode 编码的实现方式有所不同。**Unicode 的实现方式称为 Unicode 转换格式（Unicode Transformation Format，简称为`UTF`）**。最常用的 `UTF-8(8-bit Unicode Transformation Format)` 编码。UTF-8 转换格式采用了如下转换模板
```shell
U+0000 .... U+007F(0 ~ 127)      0xxxxxxx
U+0080 .... U+07FF(128~2047)     110xxxxx 10xxxxxx
U+0800 .... U+FFFF(2048~65535)   1110xxxx 10xxxxxx 10xxxxxx
 ```

UTF-8 使用 $1 \sim 6$ 个字节为每个字符编码（尽管如此，2003年11月 UTF-8 被 RFC 3629 重新规范，只能使用原来 Unicode 定义的区域，U+0000 到 U+10FFFF，也就是说 **最多四个字节**）。比如

```
"hello, 世界!"
字符 编号(hex)  位模式
h    68        01101000
e    65        01100101
l    6c        01101100
l    6c        01101100
o    6f        01101111
,    2c        00101100
     20        00100000
世   4E16      01001110 00010110
界   754C      01110101 01001100
!    21        00100001

01101000 01100101 01101100 01101100 01101111 00101100 00100000 11100100 10111000 10010110 11100111 10010101 10001100 00100001
```

> UTF-8 编码 UCS-4 的编码范围为 `U+0000` 到 `U+10FFFF`

下图展示了 Unicode 与 UTF-8 的转换过程

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/88320127723d48bfad8789d71843df99.png)

#### 字符类型

在 Go 中，对字符的处理与 C 语言一样，都是 **将字符当做一个整数进行处理的**。不同的是，Go 在处理字符时 **采用了 Unicode 编码** 字符。同时，也提供了对 **ASCII 编码** 字符的处理

在 Go 中类型 `rune` 是用于存储单个字符的标准类型，它是 `int32` 的一个别名，占 $4$ 个字节，足以存储 Unicode 字符的编码值

```go
type rune = int32
```

此外，还有另外一个类型 `byte`，它是 `uint8` 的别名，通常用于处理字节相关，无关类型的。例如，文件IO，网络IO 等。它也可以用于处理 ASCII 编码的字符

```go
type byte = uint8 // byte 是 uint8 的别名，1 个字节
```

例如，`rune` 类型存储的是字符的 Unicode 码值

```go
package main

import "fmt"

func main() {
	var c rune
	c = '中'                      // 字面值，代表了字符 '中' 的 Unicode 码点
	fmt.Printf("%v %#[1]x\n", c) // 20013 0x4e2d
	c = 0x4e2d                   // 可以直接给 rune 赋值整数，表示 Unicode 码点
	fmt.Printf("%c\n", c)        // 中
}
```

## 格式化输出

我们在前面使用了 Go  `fmt` 标准包中的 `fmt.Print` 系列的函数。其中 `fmt.Printf` 用于格式化输出。继承自 C 语言的格式化输出。其中，第一个参数 `format` 的格式如下图

![[Pasted image 20240922005552.png]]

### 标志

**标志是可选的**。允许下面 $5$ 个标志位

| 标志        | 含义                              |
| --------- | ------------------------------- |
| `-`       | 栏内左对齐，默认是右对齐的                   |
| `+`       | 有符号转换得到的数总是以 `+` 或 `-` 开头       |
| `" "`(空格) | 有符号转换得到的非负数前面加空格（`+`标志优先于空格标志）  |
| `0`(数字零)  | 用前导零在数的栏宽内进行填充（`-`标志优先于 `0` 标志） |
| `#`       | 显示 Go 字面值的表现形式                  |

### 最小栏宽

**最小栏宽是可选的**。最小栏宽可以使用 **整数** 或 **字符 `*`**。如果是字符 `*`，则需要在参数列表中提供它的值

> [!tip] 
> 
> + 如果 **数据项太小** 以至于无法达到这一宽度，那么会 **进行填充**，填充内容由 **标志** 位确定；**默认情况下填充空格**
> + 如果 **数据项过大** 以至于超过了这个宽度，那么会 **完整地显示数据项**
> 

### 精度

**精度也是可选项**。精度的形式 `.整数` 或 `.*`。如果是 `.*`，则需要在参数列表中提供它的值。**精度的含义依赖于转换指定符**

> [!tip] 
> 
> 如果转换指定符是 **整数类型** 的(`d, i, o, u, x, X`)，那么精度表示 **_最少位数_** 。如果位数不够，则添加前导零
> 
> 如果转换指定符是 **浮点数类型** 的(`a, A, e, E, f, F`)，那么精度表示 **_小数点后的位数_**
> 
> 如果转换指定符是 `g, G`，那么精度表示有效数字的个数
> 
> 如果转换指定符是 `s`，那么精度表示最大字节数
> 

### 转换指定符

**转换指定符是必选的**，Go 语言支持下面几种转换指定符

| 转换指定符        | 含义                                                |
| ------------ | ------------------------------------------------- |
| `d, i`       | 整数类型的十进制形式                                        |
| `o, u, x, X` | 无符号整数转换为八进制(`o`), 十进制(`u`), 十六进制(`x,X`)           |
|              |                                                   |
| `f, F`       | 浮点类型的十进制小数形式                                      |
| `e, E`       | 浮点类型的十进制指数形式                                      |
| `g, G`       | 浮点类型。`g` 转换为 `f` 形式或者 `e` 形式。`G` 转换为 `F` 或 `E` 形式 |
| `b`          | 十进制科学记数法，指数是二的幂， 例如 `-123456p-78`                 |
|              |                                                   |
| `c`          | `rune` 类型，格式为字符                                   |
| `s`          | `str` 或 `[]byte` 。当达到精度值或消耗完所有内容时停止               |
|              |                                                   |
| `p`          | 指针                                                |
| `%`          | 字符 `'%'`                                          |
|              |                                                   |
| `t`          | `bool` 类型，转换为 `"true"` 或 `"false"`                |
| `v`          | 所有类型的缺省格式                                         |
| `T`          | Go 语法表示的值类型                                       |

## 运算符

运算符用于对变量和值执行操作。例如，**运算符 `+` 将两个值相加**，如下例所示

```go
package main

import "fmt"

func main() {

	var a = 15 + 25
	fmt.Println(a)
}

```

虽然 `+`  通常用于将两个值相加，但它 **也可以用于将一个变量和一个值相加**，或者 **将一个变量和另一个变量相加**

```go
package main

import "fmt"

func main() {
	var (
		sum1 = 100 + 50    // 150 (100 + 50)  值 + 值
		sum2 = sum1 + 250  // 400 (150 + 250) 变量 + 值
		sum3 = sum2 + sum2 // 800 (400 + 400) 变量 + 变量
	)
	fmt.Println(sum1, sum2, sum3)
}
```

> [!attention] 
> 
> 请注意：**运算符不会改变其操作数的内容**，而是使用运算符的结果创建一个新的对象
> 

### 算术运算符

算术运算符用于 **执行常见的数学运算**。

| 运算符 | 名称  | 描述         | 示例       | 结果   |
| --- | --- | ---------- | -------- | ---- |
| `+` | 加法  | 将两个值相加     | `10 + 5` | $15$ |
| `-` | 减法  | 用一个值减去另一个值 | `10 - 5` | $5$  |
| `*` | 乘法  | 将两个值相乘     | `10 * 5` | $50$ |
| `/` | 除法  | 用一个值除以另一个值 | `10 / 5` | $2$  |
| `%` | 取模  | 返回除法的余数    | `7 % 3`  | $1$  |

算术运算符适用于整数、浮点数和复数，但是 **取模运算符 `%`  仅用于整数间的运算**

> [!important] 
> 
> Go 中 `%` 取模运算结果的符号和被取模数的符号总是一致的，因此 `-5%3` 和 `-5%-3` 结果都是 `-2`
> 

除法运算符 `/` 的行为则依赖于操作数是否为全为整数，比如  `5.0 / 4.0` 的结果是 `1.25`，但是 `5 / 4` 的结果是1，因为 **整数除法会向着 `0` 方向截断余数**

```go
package main

/* 算术运算：执行常规算术运算符 */

import "fmt"

func main() {
	a := 10                          // int
	b := 3                           // int
	quotient := a / b                // quotient = 3 int
	remainder := a % b               // 返回的是 a / b 的余数 int
	fmt.Println(quotient, remainder) // 3 1
}
```

> [!tip] 
> 
> **两个浮点型变量** 执行除法运算(`/`)，得到 **结果为浮点型**，即真实值，**除数为 $0$ 时，得到 `Inf`**
> 

如果一个算术运算的结果，不管是有符号或者是无符号的，如果需要更多的 `bit` 位才能正确表示的话，就说明计算结果是 **溢出** 了。**超出的高位的 `bit` 位部分将被丢弃**。如果原始的数值是有符号类型，而且最左边的 `bit` 为是 `1` 的话，那么最终结果可能是负的，例如 `int8` 的例子：

```go
var u uint8 = 255
fmt.Println(u, u + 1, u * u)  // 255, 0, 1

var i int8 = 127
fmt.Println(i, i+1, i*i) // "127 -128 1"
```

与 C 语言不同的时，**`++` 和 `--` 在 Go 中不以运算符的形式出现**，仅仅是单独的一条语句，且 **只能出现在变量的后面**

```go
package main

/* 算术运算：执行常规算术运算符 */

import "fmt"

func main() {
	a := 10    // int
	b := 3     // int
	
	a++       // 语句，不是运算符
	b--
	
	fmt.Println(a, b) // 11 2

	//--a // 错误的
	//++b  // 错误的
	// result = a++ // 错误的，++ 不是运算符，而是语句，没有返回值
}
```

#### 强制类型转换

在执行操作时，**两个操作数必须具有相同的类型**。在 C 语言中，C 编译器提供了隐式类型转换，使得我们可以对不同类型的数据直接执行操作

然而，**Go 编译器并未提供隐式类型转换**，当遇到两个不同类型的变量执行算术运算时，需要进行 **强制类型转换**，通常，**将类型尺寸较小的操作数转换为类型尺寸较大的类型**

```go
package main

/* 算术运算：执行常规算术运算符 */

import "fmt"

func main() {
	a := 10   			// int
	b := 3.14		 	// float64
	//result := a * b 	//  由于 a 和 b 的类型不同，因此需要将 int 类型转换为 float64 类型

	result := float64(a) * b
	fmt.Println(result)
}
```

Go 只提供了 **强制类型转换**，**没有隐式类型转换**。该语法只能在两个类型之间支持相互转换的时候使用。强制类型转换的基本语法如下

```go
object_type(expr)
```
+ `object_type` 表示目标数据类型
+ `expr` 表达式包括 变量，复杂的表达式和函数的返回值等

```go
package main  
  
import "fmt"  
  
func main() {  
    var a int8 = 0x7f  
    var b int16 = int16(a) // 不能直接用 int8 的变量赋值给 int16    
    fmt.Println(a)  
    fmt.Println(b)  
}
```

#### 算数运算符示例

案例1：计算 $46$ 天的整数周数和剩余天数

```go
package main

/* 算术运算：执行常规算术运算符 */

import "fmt"

func main() {
	fmt.Println(46/7, 46%7) // 6 4
}
```

案例2：$107653$ 秒是几天几小时几分几秒

```go
package main  
  
/* 算术运算：执行常规算术运算符 */  
import "fmt"  
  
func main() {  
  
    total_seconds := 107653                // 总秒数  
    day := total_seconds / (24 * 60 * 60)  // 天数  
    hour := total_seconds / (60 * 60) % 24 // 小时  
    minute := total_seconds / 60 % 60      // 分钟  
    seconds := total_seconds % 60          // 秒  
    fmt.Printf("%v s is %v day %v hour %v m %v s\n", total_seconds, day, hour, minute, seconds)  
}
```

### 位运算符

位运算符用于操作 **整数** 在内存中的二进制位进行操作

| 运算符  |  名字  | 描述                                 | 示例      |
| :--: | :--: | :--------------------------------- | ------- |
| `&`  | 按位与  | 如果两个位都是 $1$，则将位设置为 $1$             | `x & y` |
|  \|  | 按位或  | 如果两个位中的一个为 $1$，则将位设置为 $1$          | x \| y  |
| `^`  | 按位异或 | 如果两个位中只有一个为 $1$，则将位设置为 $1$         | `x ^ b` |
| `^`  | 按位取反 | 作为一元运算符是，替代其他语言中 `~` 按位反运算符       | `^b`    |
| `&^` | 位清除  | `a &^ b` 等价于 `a & \~b`，`\~` 表示按位取反 |         |
| `<<` |  左移  |                                    |         |
| `>>` |  右移  |                                    |         |

```go
package main

import "fmt"

func main() {
	// 位运算符, 作用在二进制位上的操作
	// 5: 101
	// 2: 010
	// & 按位与，同位1取1，有0则取0
	fmt.Printf("5 & 2: %b\n", 5&2)
	// | 按位或, 有1取1
	fmt.Printf("5 | 1: %b\n", 5|2)
	// ^ 异或，不同则取1，同则取0
	fmt.Printf("5 ^ 2: %b\n", 5^2)
	// << 左移指定位数: 左移n位就是乘以2的n次方。
	fmt.Printf("5 << 1: %b\n", 5<<1) // 1010
	// >> 右移指定位数: 右移n位就是除以2的n次方。
	fmt.Printf("5 >> 1: %b\n", 5>>1) // 10
	// ~ 按位取反 ~n = -(n+1)，Go 使用 ^ 替换了其他语言的 ~
	fmt.Printf("~5: %b\n", ^5) // ~5 = -(5 + 1)
}
```

### 比较运算符

比较运算符用于比较两个 **相同类型** 的值大小。 比较运算符的返回值要么是 `true` ，要么是 `false`。

在下面的示例中，我们使用大于运算符 ( `>` ) 来确定 $5$ 是否大于 $3$：

```go
package main  
  
import "fmt"  
  
func main() {  
    var x = 5  
    var y = 3  
    fmt.Println(x > y) // true  
}
```

下表列出了所有比较运算符

| 运算符 | 名称    |   示例   |
| :-: | :---- | :----: |
| ==  | 等于    | x == y |
| !=  | 不等于   | x != y |
|  >  | 大于    | x > y  |
|  <  | 小于    | x < y  |
| >=  | 大于或等于 | x >= y |
| <=  | 小于或等于 | x <= y |


> [!tip] 
> 
> 布尔型、数字类型和字符串等基本类型都是可比较的，也就是说两个相同类型的值可以用 `==` 和 `!=` 进行比较
> 
> + 整数、浮点数和字符串可以根据比较结果排序
> 

### 逻辑运算符

用于布尔逻辑运算符。Go 提供下面三种逻辑运算符

| 运算符  | 名称  | 描述                           | 示例                   |
| ---- | --- | ---------------------------- | -------------------- |
| `&&` | 逻辑与 | 如果两个语句都为`true`，则返回 `true`    | `x < 5 &&  x < 10`   |
| \|\| | 逻辑或 | 如果两个语句都为 `false`，则返回 `false` | `x < 5` \|\| `x < 4` |
| `!`  | 逻辑非 | 反转结果，如果结果为`true` 则返回 `false` | `!(x < 5 && x < 10)` |
> [!warning] 逻辑运算符的操作数的类型只能是 `bool` 类型

- 逻辑非 `!` **作用在 `bool` 类型返回值的表达式之上**，对布尔值进行取反操作
- 逻辑或 `||`: 短路运算符，只要遇到 `true` 就返回 `true`，后续表达式就不再求值
- 逻辑与 `&&`: 短路运算符，只要遇到 `false` 就返回 `false`，后续表达式就不再求值

### 赋值运算符

赋值操作符用于为 **变量赋值**。在下面的例子中，我们使用 **赋值运算符(`=`)** 将值 $10$ 赋值给一个名为 `x` 的变量

```go
package main  
  
import "fmt"  
  
func main() {  
    var x int  
    x = 10  
    fmt.Println(x)  
}
```

有时候，当我们对两个变量操作时，需要将结果存放在其中一个变量中，通常采用

```go
a := 10
b := 5
a = a + b
```

然而，这个操作会读取三次内存。Go 语言提供另一种赋值运算符来完成此操作

```g
a := 10
b := 5
a += b
```

`a += b` 等价于 `a = a + b`，但是 `a += b` 只会读取两次内存，提高了一定的执行效率

下表列出了所有赋值运算符

| 运算符 |   示例    |    等价物     | 备注         |
| :-: | :-----: | :--------: | ---------- |
|  =  |  x = 5  |   x = 5    | 普通的赋值运算符   |
| +=  | x += 3  | x = x + 3  |            |
| -=  | x -= 3  | x = x - 3  |            |
| *=  | x *= 3  | x = x * 3  |            |
| /=  | x /= 3  | x = x / 3  |            |
| %=  | x %= 3  | x = x % 3  |            |
| &=  | x &= 3  | x = x & 3  | & 是按位与运算符  |
| \|= | x \|= 3 | x = x \| 3 | \| 是按位或运算符 |
| ^=  | x ^= 3  | x = x ^ 3  | ^ 按位异或运算符  |
| >>= | x >>= 3 | x = x >> 3 | >> 右移运算符   |
| <<= | x <<= 3 | x = x << 3 | << 左移运算符   |

### 运算符的优先级

一元运算符具有最高优先级。由于 `++` 和 `--` 运算符构成语句，而不是表达式，它们被排除在运算符层次结构之外。因此，语句 `*p++` 与 `(*p)++` 是相同的。

二元运算符有五个优先级。**乘法运算符优先级最高**，**其次是加法运算符**，**比较运算符**，**逻辑与（&&**），最后是 **逻辑或（||）**

```
Precedence    Operator
    5             *  /  %  <<  >>  &  &^
    4             +  -  |  ^
    3             ==  !=  <  <=  >  >=
    2             &&
    1             ||
```

**相同优先级的二元运算符从左到右结合**。例如，`x / y * z` 等同于 `(x / y) * z`。

```go
+x                         // x
42 + a - b                 // (42 + a) - b
23 + 3*x[i]                // 23 + (3 * x[i])
x <= f()                   // x <= f()
^a >> b                    // (^a) >> b
f() || g()                 // f() || g()
x == y+1 && <-chanInt > 0  // (x == (y+1)) && ((<-chanInt) > 0)
```

## 指针

在 [[计算机组成：计算机组成原理#主存储器]] 中我们介绍过，大多数现代计算机将内存分割为 **字节**，每个字节可以存储 $8$ 位的信息

每个字节都有唯一的 **地址**，用来和内存中的其他字节相区别。如果内存可以存储 $n$ 个字节，那么可以把地址当做 $0 \sim n-1$ 个整数

程序中的每个变量占有一个或多个字节内存，把 **第一个字节的地址** 称为 **变量的地址**

> [!tip] 第一个字节的地址：对象占用的所有字节中，编号最小的地址
> 
> ![[Pasted image 20240926234808.png]]
> 

> [!important] 
> 
> 这就是指针的出处。**地址使用整数表示**，但是 **地址并不等同于整数**。所以，**_不能使用普通的整型变量存储地址_**
> 
> 在 Go 语言中，**用 _指针变量_ 存储地址**。也就是说，**指针就是地址**，而指针变量就是存储地址的变量
> 

Go 语言中的指针受到严格限制，不像 C/C++ 中那样灵活。即，Go 指针不能进行运算，对于指针只有 **取地址(`&`)** 和 **解引用 (`*`)** 两种操作

### 声明指针

在 Go 中的 **值类型都有其对应的指针类型**。在声明指针类型的变量时，只需要在其类型前面添加 `*` 就能表示指针类型
- `int` 类型的指针类型就是 `*int`
- `float32` 类型的指针类型就是 `*float32`
- `[length]T` 类型的指针类型就是 `*[length]T`

声明指针类型的语法为

```go
var pointerName *Type
```

该语句声明了一个指向 `Type` 类型变量的指针变量，**默认会被初始化为 `nil`**

> [!tip] 
> 
> `nil` 其实甚至不是 Go 的关键词，只是在 `$GOROOT/src/buildin/buildin.go` 中预定义的标识符
> 
> 换句话说，我们也可以自己声明一个 `nil`，就会把预定义的 `nil` 覆盖了。肯定是不推荐的。根据这里的定义，也可以看出，**在 Go 中 `nil` 代表了 `pointer`, `channel`, `func`, `interface`, `map` 或者 `slice` 的 零值**
> 

```go
// nil 是预先声明的标识符，代表指针、通道、func、接口、映射或切片类型的零值。
var nil Type // 类型必须是指针、通道、函数、接口、映射或片段类型

// Type 仅用于文档目的。它是任何 Go 类型的替身，但在任何给定的函数调用中都代表相同的类型.
type Type int
```

### 使用指针

我们可以使用取地址运算符 `&` 获取一个对象的地址，使用解引用运算符 `*` 获取地址执行的对象

```go
package main

import "fmt"

func main() {
	a := 10
	b := &a                     // 取变量 a 的地址，将指针保存到 b 中
	fmt.Printf("type of b: %T\n", b)        // type of b:*int
	recv := *b                              // 解引用
	fmt.Printf("type of recv: %T\n", recv)  // type of recv:int
	fmt.Printf("value of recv: %v\n", recv) // value of recv:10
}
```

### new 函数

内置函数 `new(Type)` 返回一个指向 `Type` 类型对象的指针

```go
package main

import (
	"fmt"
)

func main() {
	var pa *int
	pa = new(int)
	*pa = 10
	fmt.Printf("&pa = %p\npa = %p\n*pa = %d\n", &pa, pa, *pa)
}
```

> [!tip] 
> 
> `new(Type)` 函数会分配一片能够存储 `Type` 类型对象的内存空间，并返回其首地址。至于 Go 编译器会在栈区还是堆区分配完全由编译器决定
> 

## 流程控制

### if 语句

`if` 语句允许程序检查表达式的值并从两个分支中选择一条分支进行执行。完整的 `if` 语句如下

```go
if initializer; expr {  // 注意：花括号 { 必须与 if 在同一行
	语句块1
} else {  // 注意：花括号 { 必须与 else 在同一行
	语句块2
}
```

其中 `initializer` 是一个初始化表达式，可以省略；`expr` 是条件表达式。注意：`expr` 表达式的值必须是 `bool` 类型，即要么为 `true`，要么为 `false`

> [!tip] 
> 
> `initializer` 初始化表达式初始化的变量只能在 `if` 语句中使用，离开 `if` 语句就无法访问了
> 

`if` 语句在执行时测试表达式 `expr` 的值；如果为 `true`，则执行 **语句块1**；否则，执行 **语句块2**

```go
if line_num == MAX_LINE {  // 首先检查表达式 line_num == MAX_LINE
	line_num = 0          // 如果为真(true)，执行该语句
} else{
	line_num++           // 否则(false)，执行该语句
}
```

#### 嵌套的 if 语句

Go 语言对可以出现在 `if` 语句内部的语句类型没有限制。事实上，在 `if` 语句内部嵌套其他 `if` 语句是非常普遍的。如下例程，用于选择三个数中的最大值

```go
package main

import "fmt"

func main() {
	var a, b, c int
	fmt.Scanf("%d%d%d", &a, &b, &c)
	var max int
	if a > b {
		if a > c {
			max = a
		} else {
			max = c
		}
	} else {
		if b > c {
			max = b
		} else {
			max = c
		}
	}
	fmt.Printf("max(%d, %d, %d) is %d\n", a, b, c, max)
}
```

#### else if 语句

`if ... else if ... else` 语句是 **多分支语句**，当我们 **有多个条件可供选择时**，就需要使用该语句

例如，下列代码片段展示了一个完整的 if 语句的使用方法

```go
a := 6
if a < 0 {
	fmt.Println("negative")
} else if a > 0 { // 走到这里一定 a 不小于 0
	fmt.Println("positive")
} else { // 走到这里一定 a 不大于、也不小于 0
	fmt.Println("zero")
}
```

多分支结构，**从上向下依次判断分支条件**，只要一个分支条件成立，其后语句块将被执行，那么其他条件都不会被执行

> [!attention] 
> 
> **前一个分支条件被测试过，下一个条件相当于隐含着上一个分支的条件**。所以一定要考虑一下 else 分支是否有必要写，以防逻辑漏洞
> 

请注意：`if ... else if ... else` 本质上就是下列 `if` 语句的嵌套

```go
// 嵌套
a := 6
if a == 0 {
	fmt.Println("zero")
} else {
	if a < 0 {
		fmt.Println("negative")
	} else {
		if a >= 0 { // 走到这里一定 a 不小于 0
			fmt.Println("positive")
		}
	}
}
```

### switch 语句

`switch` 语句用于 **从多个代码块中选择一个执行**。它的完整语法如下

```go
switch initializer; expr {
	case value1:
		<statement-1>
		<....>
		<statement-n>
	case value2:
		<statement-1>
		<....>
		<statement-n>
	....
	default:
		<statement-1>
		<....>
		<statement-n>
}
```

其中，`initializer` 是一个简单的初始化语句，可以省略；`expr` 是一个表达式，`value` 的值的类型必须与 `expr` 表达式的类型相同。

> [!attention] 
> 
> 所有的  `case` 后面的值都应该与 `switch` 后的表达式的值的类型相同，否则将抛出错误
> 

考虑以下示例，它在特定日期显示不同的消息

```go
package main  
  
import (  
    "fmt"  
    "time")  
  
func main() {  
    today := time.Now()  
  
    switch today.Day() {  
    case 5:
       fmt.Println("Today is 5th. Clean your house.")  
    case 10:  
       fmt.Println("Today is 10th. Buy some wine.")  
    case 15:  
       fmt.Println("Today is 15th. Visit a doctor.")  
    case 25:  
       fmt.Println("Today is 25th. Buy some food.")  
    case 31:  
       fmt.Println("Party tonight.")  
    default:  
       fmt.Println("No information available for that day.")  
    }  
}
```

#### case 多个值

一个 `case` 子句可以带有多个值，用于为多个类似情况选择共同的代码块。例如

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	today := time.Now()
	var t int = today.Day()

	switch t {
	case 5, 10, 15:
		fmt.Println("Clean your house.")
	case 25, 26, 27:
		fmt.Println("Buy some food.")
	case 31:
		fmt.Println("Party tonight.")
	default:
		fmt.Println("No information available for that day.")
	}
}
```

#### fallthrough

Go 的 `case` 语句在匹配成功之后，**不会连续执行多个 `case` 块**。如确需要连续执行，使用关键字 `fallthrough`

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	today := time.Now()

	switch today.Day() {
	case 5:
		fmt.Println("Clean your house.")
		fallthrough // 强制控制流转到下一个 case 语句组
	case 10:
		fmt.Println("Buy some wine.")
		fallthrough //强制控制流转到下一个 case 语句组
	case 15:
		fmt.Println("Visit a doctor.")
		fallthrough // 强制控制流转到下一个 case 语句组
	case 25:
		fmt.Println("Buy some food.")
		fallthrough // 强制控制流转到下一个 case 语句组
	case 31:
		fmt.Println("Party tonight.")
	default:
		fmt.Println("No information available for that day.")
	}
}
```

#### case 条件表达式

`case` 语句也可以与比较运算符和逻辑运算符一起使用

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	today := time.Now()

	switch { // 此处没有表达式
	case today.Day() < 5: // case 一个条件
		fmt.Println("Clean your house.")
	case today.Day() <= 10: // case 一个条件
		fmt.Println("Buy some wine.")
	case today.Day() > 15: // case 一个条件
		fmt.Println("Visit a doctor.")
	case today.Day() == 25: // case 一个条件
		fmt.Println("Buy some food.")
	default:
		fmt.Println("No information available for that day.")
	}
}
```

> [!tip] 
> 
> 当 `case` 条件表达式时，`switch` 后面就没有 `expr`
> 

### for 语句

`for` 语句 是 Go 中的唯一一个循环语句。基本的 `for` 循环结构如下

```go
for init; condition; post {
	// 循环体执行的代码
}
```

 其中，`init` 是循环的初始化，只在进入循环时执行一次。`condition` 是条件表达式；`post` 在每次迭代结束时执行，通常用于改变循环条件
+ **init** 是循环开始执行前的 **初始化步骤**，**只执行一次**；也称为初 _始化表达式_
+ **condition** 用来 **控制循环的终止**（在执行循环体之前，只要 **表达式 2** 的值不为 `false` ，循环就会继续执行；否则退出循环）
+ **post** 是每次循环中最后被执行的一个操作

**`init` 语句通常是一个简短的变量声明**，在那里声明的变量仅在 `for` 语句的作用域内可见。一旦`condition` 条件表达式的计算结果为 `false` ，循环将停止迭代

> [!tip] 
> 
> `for` 的 `init; condition; post` 没有被 `()` 包围， `{}` 是必须的，且 `{` 必须和关键字 `for` 在同一行

如下示例程序演示了 `for` 循环

```go
package main

import "fmt"

func main() {
	sum := 0
	for  i:= 1; i <= 100; i++ {
		sum += i
	}
	fmt.Printf("sum = %d\n", sum)
}
```

请注意：在 Go 语言中，`for` 后面的三部分可以任意省略。如果省略循环条件，则它将永远循环，因此可以紧凑地表示无限循环

```go
for {}  // 类似于 C 的 for(;;)
```

如果 `init; condition; post` 只省略其中之一，那么分号(`;`) 将不能省略

```go
i := 0
for ; i < 10; i++ {
	// 条件
}
```

如果只保留 `condition`，那么分号就可以省略，此时类似于 C/C++ 中的 `while` 语句

```go
package main

import "fmt"

func main() {
	// 省略 init 和 post 此时，类似 C 的 while，这样就可以省略两边的分号
	sum := 0
	i := 1
	for i <= 100 {
		sum += i
		i++
	}
	fmt.Println(sum)
}
```

#### `continue` 关键字

该 `continue` 语句用于跳过循环中的一个或多个迭代。然后，它继续进行循环中的下一次迭代

```go
package main

import "fmt"

func main() {
	for i:=0; i < 10; i++ {
		if i % 2 != 0 {
			continue
		}
		fmt.Printf("%d ", i)
	}
}
```

`continue`语句后可以添加标签，**表示开始标签对应的循环**

```go
package main

import "fmt"

func main() {
forloop1:
	for i := 0; i < 5; i++ {
		//forloop2:
		for j := 0; j < 5; j++ {
			if i == 2 || j == 2 {
				continue forloop1
			}
			fmt.Printf("%v-%v\n", i, j)
		}
	}
}
```

#### `break` 关键字

该 **`break`** 语句用于 **中断/终止循环执行**

```go
package main

import "fmt"

func main() {
	for i:=0; i < 10; i++ {
		fmt.Printf("%d ", i)
		if i == 5 {
			break  // 跳出本层循环
		}
	}
	fmt.Printf("\n")
}
```

`break`语句还可以在语句后面添加 **标签**，表示 **退出某个标签对应的代码块**

```go
package main

import "fmt"

func main() {
BREAKDEMO1:
	for i := 0; i < 10; i++ {
		for j := 0; j < 10; j++ {
			if j == 2 {
				break BREAKDEMO1 // 跳出标签指定的语句
			}
			fmt.Printf("%v-%v\n", i, j)
		}
	}
	fmt.Println("...")
}
```

> [!tip] 
> 
> `break` 关键字还可以用于 `switch` 和 `select` 的代码块上


#### 嵌套的 for 语句

可以将一个循环放在另一个循环中。处于另一个循环内部的循环称为 **"内部循环"**。在这里，**“外部循环” 的每迭代执行一次，"内部循环" 将完整执行**：

示例：寻找 $2 \sim 100$ 内的素数

```go
package main

import "fmt"

func main() {
	/* 寻找 2 ~ 100 内的素数 */
	for num := 2; num < 100; num++ {
		var j int = 2
		for ; j < num; j++ {
			if num%j == 0 {
				fmt.Printf("%d is not a prime.\n", num)
				break // 跳出内层循环
			}
		}
		if j == num {
			fmt.Printf("%d is a prime.\n", num)
		}
	}
}
```

#### `goto` 关键字

`goto` 语句通过标签进行代码间的 **无条件跳转**。`goto` 语句可以在快速跳出循环、避免重复退出上有一定的帮助。

```go
func f() {
	a := 0
	if a == 1 {
		goto LABEL1
	} else {
		fmt.Println("other")
	}

LABEL1:
	fmt.Printf("next...")
}

func main() {
	f()
}
```

Go 语言中使用 `goto` 语句能简化一些代码的实现过程。 例如双层嵌套的 `for` 循环要退出时

```go
func f() {
	for i := 0; i < 5; i++ {
		for j := 0; j < 5; j++ {
			if i == 2 && j == 2 {
				goto LABEL1
			}
		}
	}
LABEL1:
	fmt.Println("label1")
}

func main() {
	f()
}
```

## 练习题

1. 编写一个程序，判断一个整数是否为奇数或偶数

```go

```


2. 编写一个程序，计算并输出 1 到 100 之间所有能被 3 整除的数字的和

```go

```

3. 编写一个程序，接受用户输入的一个字符串，并判断该字符串是否是回文字符串（正序和逆序相同）

```go

```

4. 

