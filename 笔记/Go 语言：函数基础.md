# 函数基础

函数是执行特定任务的代码块。这是可重复使用的代码单元，可以从程序的其他部分调用。函数可帮助我们组织代码，使其更模块化并提高可读性。

## 函数声明与调用

Go 语言中使用 `func` 关键字声明函数。函数声明包括 **函数名**、**形参列表**、**返回值列表** 以及 **函数体**

```go
func functionName(parameter-list) (result-list) {  // { 与 func 在同一行
    body
}
```

> [!tip] 
> 
> 函数名本质上就是一个标识符，必须符合 Go 语言标识符命名规则
> 
> 形参列表描述了函数需要的参数名及其类型。这些参数作为函数的局部变量使用
> + 函数在调用时，调用者提供参数的值并发生一次值拷贝
> 
> 返回值列表描述了函数返回的变量名以及类型。如果函数返回一个无名变量或者没有返回值，返回值列表的括号是可以省略的
> + 如果一个函数声明没有返回值列表，那么函数体中不需要 `return` 语句
> 

例如，如下声明的函数 `hypot()`

```go
func hypot(x, y float64) float64 {
	return math.Sqrt(x * x + y * y)
}

fmt.Println(hypot(3, 4))  // "5"
```

`x` 和 `y` 是形参名，而 $3$ 和 $4$ 是调用是传递的实参。该函数返回一个 `float64` 类型的值

### 形参列表

#### 类型简写

Go 语言在声明函数时，如果形参列表中连续几个形参都是同一个类型，那么可以只需要在最后一个形参后声明类型即可。例如，下面两个函数的声明是等价的

```go

func f(i, j, k int, s, t string)                 {
	/* ... */
}

func f(i int, j int, k int,  s string, t string) { 
	/* ... */ 
}
```

#### 可变参数

可变参数是指函数的参数数量不固定。Go 语言中的可变参数通过在参数名后加省略号(`...`)  来标识

```go
func intSum2(x ...int) int {
	fmt.Println(x) // x是一个切片
	sum := 0
	for _, v := range x {
		sum = sum + v
	}
	return sum
}
```

> [!attention] 
> 
> 可变参数 **收集实参到一个切片** 中。如果一个函数声明有可变参数，那么这个可变参数 **必须位于形参列表的最后**
> 
> 例如， `func fn7(x, y int, nums ...int, z string){}` 这是错误的
> 

如果我们的参数在一个切片中，Go 语言支持 **切片分解**，然后传递给可变参数，这类似于 Python 中序列解包，但是却存在很大的差异

```go
func fn4(x int, y int)   {} // 多参函数

p := []int{4, 5}
fn4(p...) // 错误，这在Go中不行，不能用在非可变参数 non-variadic 上
```

如果最终的实参是 **某类型的切片** 且其 **后跟着 `...`**，它将 **无变化** 的传递给 `...T` 的可变参数。注意，**这个过程无新的切片创建**

```go
func fn7(x, y int, nums ...int) {
	fmt.Printf("%d %d; %T %[3]v, %d, %d\n", x, y, nums, len(nums), cap(nums))
}
p := []int{4, 5}
fn7(p...)          // 错误，不能用在普通参数上
fn7(1, p...)       // 错误，不能用在普通参数上
fn7(1, 2, 3, p...) // 错误，不能用 2 种方式为可变参数传参，不能混用

fn7(1, 2, p..., 9, 10) // 语法错误
fn7(1, 2, []int{4, 5}..., []int{6, 7}...) // 语法错误，不能连续使用 p...，只能一次

// 正确的如下
fn7(1, 2, []int{4, 5}...)
fn7(1, 2, p...)
fn7(1, 2, 3, 4, 5)
```

> [!important] 
> 
> 切片分解的限制
> 
> + **切片分解只能用于给可变参数传参**，不能用在普通参数上
> + **不能用 $2$ 种方法为可变参数传参**
> + 不能连续使用切片分解，**只能一次**
> 

### 返回值

#### 无返回值

在 Go 中仅仅一个 `return` 并不一定表示无返回值，只能说在一个无返回值的函数中，`return` 表示无返回值函数返回。

```go
// 无返回值函数，return 语句可有可无，必要时也需要使用 return
func fn1() {
	fmt.Println("无返回值")
	return // return 可有可无，如有需要，在必要的时候使用 return 来返回
}

t := fn1()         // 错误，无返回值函数无返回值可用
fmt.Println(fn1()) // 错误，无返回值函数无返回值可打印
```

> [!attention] 
> 
> Go 语言中，没有返回值的函数不能使用变量接收其返回值
> 

#### 返回一个值

如果函数需要返回一个值，就必须使用 `return` 语句

```go
// 返回一个值，没有变量名只有类型
func fn2() int {
	a := 100
	return a + 1 // return后面只要类型匹配就行
}

fmt.Println(fn2()) // 返回101
t := fn2()         // 返回101
```

> [!tip] 
> 
> 只有一个返回值时，可以省略返回值列表的括号
> 

#### 返回多个值

Go 支持多个返回值

```go
// 返回多个值。注意，返回值列表两边的圆括号是必不可少的
func fn4() (int, bool) {
	a, b := 100, true
	return a, b
}

fmt.Println(fn4())
x, y := fn4() // 需要两个变量接收返回值
```

> [!attention] 
> 
> 多返回值列表需要使用 `()` 括起来。这是必不可少的
> 
> 多返回值的函数调用时，需要使用多个变量接收函数的返回值
>

#### 命名返回值

函数定义时可以给返回值命名，并在函数体中直接使用这些变量，最后通过`return`关键字返回。

```go
func calc(x, y int) (sum, sub int) {
	sum = x + y
	sub = x - y
	return
}
```

## Go 函数调用栈布局与跳转

我们按照编程语言提供的语法规则编写的函数会被编译器编译为机器指令，并写入可执行文件中。程序在执行时，可执行文件会被加载到内存，而这些机器指令对应到虚拟地址空间中的代码段。如下图所示

![[Pasted image 20250322103247.png]]

> [!tip] 
> 
> 如果在函数 `A()` 中调用函数 `B()`，那么编译器就会生成一条 `call` 指令，用于跳转到函数 `B()` 的入口位置继续执行
> 
> 当函数 `B()` 执行完成之后，有一条 `ret` 指令，用于返回到该函数的调用位置
> 

函数在执行时需要有足够的内存空间供函数存放 **局部变量**，**被调函数的参数** **被调函数的返回值**。这段空间对应虚拟地址中的 **栈区域**

> [!tip] 
> 
> Go 语言允许返回多个值，因此将返回值分配在栈上是比较好的
> 

运行时栈上面是高地址向下增长，分配给函数的栈空间被称为函数 **栈帧**。 栈底被称为 **栈基指针(base pointer, bp)**，栈顶被称为 **栈指针(stack pointer, sp)**。如下图所示

![[Pasted image 20250322111534.png]]

Go 语言的函数调用栈按照 **该函数的调用者栈基地址**、**该函数的局部变量**、**被调函数的返回值** 以及 **被调函数的参数**

![[Pasted image 20250322112213.png]]

`call` 指令只做两件事情：**将它下一条指令地址入栈**，这就是函数的返回地址；**跳转到被调函数的入口位置**。返回地址之后就是被调函数的栈帧了，同样按照上述栈帧布局规则布局

![[Pasted image 20250322112506.png]]

> [!important] 
> 
> 显然，被调函数要定位其参数和返回值所在的位置需要通过 **栈指针 + 偏移** 的方式。
> 

Go 语言在函数执行前会一次性的分配好函数需要的栈帧。然后通过相对寻址的方式使用栈帧。

![[Pasted image 20250322112830.png]]

> [!tip] 
> 
> 一次性分配好栈帧的好处就是可以防止栈访问越界的问题
> 

下面我们来看 `call` 和 `ret` 指令是如何控制函数跳转与返回的！函数 `A()` 在 `a1` 处调用函数 `B()`，在跳转前函数 `A()` 的栈帧如下

![[Pasted image 20250322113724.png]]

`call` 指令只做两件事：首先将返回地址 `a2` 入栈保存起来，然后跳转到函数 `B()` 的入口地址 `b1`。此时，`call` 指令结束，函数 `B()` 开始执行

![[Pasted image 20250322113856.png]]

`B()` 开始执行时，首先会为自己分配足够的栈帧，然后保存调用者的栈基地址；随后，将函数 `B()` 的栈帧保存在寄存器 `bp` 中。到此，函数 `B()` 的栈帧就分配完成了。

![[Pasted image 20250322114152.png]]

接下来就是执行函数 `B()` 的其他指令的。在执行 `ret` 指令之前，编译器会插入 **恢复调用者栈基** 和 **释放栈帧** 的指令，之后就会执行 `ret` 指令。`ret` 指令也只做两件事：**从占中弹出返回地址** 和 **跳转到返回地址**

![[Pasted image 20250322113447.png]]

现在就回到函数 `A()` 的 `a2` 处的指令继续执行了

## Go 语言函数传参与返回值

下面我们来看看 Go 语言函数参数是如何传递的。如下有一个函数 `swap()`，它用于交换调用的两个局部变量，但是交换失败了

```go
func swap(a, b int) {
	a,b = b, a
}

func main() {
	a, b := 1, 2
	swap(a, b)
	fmt.Println(a, b)  // 1, 2
}
```

下面我们通过函数调用栈看看问题出现在什么地方。下图展示了 `main()` 函数和 `swap()` 函数的栈帧布局。

![[Pasted image 20250322120619.png]]

当我们执行到 `swap()` 中的 `a, b = b, a` 语句时，要交换 `swap()` 的两个参数。下图展示交换之后的栈帧状态

![[Pasted image 20250322120837.png]]

> [!tip] 
> 
> 这交换的只是 `swap()` 的参数，而不是交换的 `main()` 函数的局部变量
> 

下面我们让 `swap()` 接收两个 `int` 类型的指针，然后再试试能否交换成功。编译运行后，我们发现这次成功交换了 `main()` 的两个局部变量

```go
func swap(a, b *int) {
	*a,*b = *b, *a
}

func main() {
	a, b := 1, 2
	swap(&a, &b)
	fmt.Println(a, b)  // 2, 1
}
```

上述代码执行时的栈帧布局如下

![[Pasted image 20250322121159.png]]

当执行到 `swap()` 的 `*a, *b = *b, *a` 时，交换的是 `addrA` 和 `addrB` 执指向位置的数据。如下图，这次交换成功了

![[Pasted image 20250322121257.png]]

---

在介绍 Go 语言如何返回值之前，我们首先补充介绍一个概念 `defer` 函数

> [!tip] 
> 
> `defer` 即延迟的含义，因此 `defer` 后的函数调用会被延迟执行。
> 
> 既然是延迟执行，那么延迟到合适呢？答案是 **函数返回之前**
> 

同一个函数中可以通过 `defer` 注册多个延迟调用函数。当函数返回时，就会按照注册顺序的相反方向依次执行

```go
func main() {
	fmt.Println("start")
	defer fmt.Println(1)
	defer fmt.Println(2)
	defer fmt.Println(3)
	fmt.Println("end")
}
```

由于`defer`语句延迟调用的特性，所以`defer`语句能非常方便的处理资源释放问题。比如：资源清理、文件关闭、解锁及记录时间等

`defer` 函数的参数在注册时计算

```go
package main

import "fmt"

func main() {
	count := 1
	fmt.Println("start")

	defer fmt.Println(count) // defer fmt.Println(1)

	count++
	defer fmt.Println(count) // defer fmt.Println(2)

	count++
	defer fmt.Println(count) // defer fmt.Println(3)

	fmt.Println("end")
}

// Out:
// start
// end
// 3
// 2
// 1
```

---

下面我们来看 Go 函数是如何返回值。考虑如下代码

```go
func incr(a int) int {
	var b int
	
	defer func() {
		a++
		b++	
	}()
	
	a++
	b = a
	return b
}

func main() {
	var a, b int
	b = incr(a)
	fmt.Println(a, b) // 0, 1
}
```

下面我们看看上述函数的调用栈的内容。`main()` 函数的栈帧中存放了 `incr()` 函数的参数和返回值，当 `incr()` 执行到 `return` 语句时的栈帧如下

![[Pasted image 20250322130222.png]]

下一步就是要执行 `return` 语句了。但是在执行 `return` 语句之前需要做两件事情：**给返回值赋值** 和 **执行 defer 函数**。那么这个两件事情谁先谁后呢？

> [!attention] 
> 
> 请注意：给返回值赋值要先执行，然后才是执行 defer 函数
> 

所以，在返回前需要将局部变量 `b` 拷贝到返回值空间。然后在执行 `defer` 函数，此时，局部变量 `b` 和参数 `a` 分别加 $1$。`incr()` 函数执行结束，返回值为 $1$，并将其赋值给 `main()` 函数的局部变量 `b`。下图展示了 `inc()` 返回栈帧的状态

![[Pasted image 20250322130723.png]]

---

上面讨论匿名返回值是如何返回的。下面我们讨论 **命名返回值** 的情形。如下代码，我们将返回值命名为 `b`，其他都没有发送变化

```go
func incr(a int) (b int) {
	defer func() {
		a++
		b++	
	}()
	
	a++
	return a
}

func main() {
	var a, b int
	b = incr(a)
	fmt.Println(a, b) // 0, 2
}
```

 这个例子中 `main()` 函数栈帧与之前没有变化，`incr()` 函数的栈帧没有局部变量。当执行到 `return` 语句时，首先将参数 `a` 的值拷贝到返回值空间中，如下图所示：此时的栈帧如下
 
 ![[Pasted image 20250322131151.png]]
 
 然后执行 `defer` 函数，参数 `a` 再次加 $1$，返回值 `b` 也被加 $1$。`incr()` 函数返回，返回值此时为 $2$，赋值给 `main()` 的局部变量 `b`。此时，栈帧如下

![[Pasted image 20250322131352.png]]

## 作用域

函数会开辟一个 **局部作用域**，其中定义的标识符仅能在函数之中使用，也称为标识符在函数中的可见范围。

> [!tip] 
> 
> 这种对 _标识符约束的可见范围_，称为 _作用域_
> 

### 语句块作用域

Go 的 `if`、`for`、`switch` 等语句会开辟一个作用域，**作用域仅在该语句块中**，称为语句块作用域

```go
s := []int{1, 3, 5}

for i, v := range s {
	fmt.Println(i, v) // i 和  v在 for 块中可见
}

fmt.Println(i, v) // 错误，在for外不可见
```

```go
if f, err := os.Open("o:/t.txt"); err != nil {
	fmt.Println(f, err) // 可见
}

fmt.Println(f, err) // 错误，不可见
```

> [!tip] 
> 
> `swith`、`select` 语句中的 **每个子句都被视为一个隐式的代码块**。
> 

### 显式的块作用域

在任何一个大括号中定义的标识符，其作用域只能在这对大括号中。

> [!important]
>  
>  一对花括号(`{}`)就会创建一个作用域，称为块作用域
>  

```go
{ 
	// 块作用域
	const a = 100
	var b = 200
	c := 300
	fmt.Println(a, b, c) // 可见
}

fmt.Println(a, b, c) // 错误，不可见
```

### 函数作用域

函数声明的时候使用了花括号，所以 **整个函数体就是一个显式代码块**。这个 **函数就是一个块作用域**

### 包级作用域(全局作用域)

**每一个 `package` 包含该包所有源文件，形成的作用域**。有时 **在 _包中顶层代码_ 定义标识符，也称为 _全局标识符_**。

**所有包内定义全局标识符，包内可见**。**_包外需要大写首字母导出_**，使用时也要加上包名。

```go
package intset

// 包内全局标识符
const (
	NULL = iota
	INT
	FLOAT
	...
)
```

> [!important] 在同一个包中，所有源文件形成了一个全局作用域

### 内建作用域

**预定义的标识符就在这个全局环境中**，因此像 `bool`、`int`、`nil`、`true`、`false`、`iota`、`append` 等标识符全局可见，随处可用
