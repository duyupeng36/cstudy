# 进程创建

即将涉及 $4$ 个主要的系统调用或库函数如下表

| 系统调用/库函数                       | 描述                   |
| :----------------------------- | :------------------- |
| `fork()`                       | 通过复制父进程创建子进程         |
| `exit(status)`                 | 退出进程，释放进程占用的资源       |
| `wait(&status)`                | 等待子进程结束，并回收 PCB      |
| `execve(pathname, argv, envp)` | 加载 `pathname` 指定的新程序 |
下图展示上述 $4$ 个函数是如何相互协同工作的

![[Pasted image 20241102192522.png]]

现在我们集中在 `fork()` 系统调用之上

## 创建新进程

系统调用 `fork()` 创建一个新的子进程，它几乎是父进程的翻版，父进程就是调用 `fork()` 的进程

```c
#include <unistd.h>

pid_t fork(void);
/* 成功：父进程中返回子进程的 PID; 子进程中返回 0；错误返回 -1 */
```

> [!attention] 
> 
> 注意，调用 `fork()` 后将存在两个进程，每个进程都会从 `fork()` 的返回位置继续执行
> 

`fork()` 采用 **复制** 的方式将父进程拷贝一份从而创建子进程。所以，两个进程拥有 **相同的文本段**。但是，其他虚拟内存区域确是不同的，不过子进程的栈区，数据段，堆区都是从父进程中完全拷贝而来的。

> [!tip] 
> 
> `fork()` 返回后，父子进程均可以修改各自的数据，并且不会相互影响
> 

也就是父进程调用 `fork()` 创建子进程的内存拷贝如下图所示

![[Pasted image 20241102210610.png]]

> [!tip] 返回值
> 
> `fork()` 后出现两个进程。其中在父进程中返回子进程的 PID，而在子进程中返回 $0$
> 
> 当系统无法创建子进程时，`fork()` 将返回 $-1$。失败的原因可能是
> 
> + 进程数量超出了系统针对真实用户设置限制
> 
> + 进程数量触及系统允许的最大进程数量
> 

子进程如果需要获取自己的 PID 可以调用 `getpid()`；获取父进程的 PID 可以调用 `getppid()`

通过 `fork()` 可以区分子进程和父进程，因此调用 `fork()` 时，有时会采用如下习惯用语

```c
pid_t child_pid; // 用于记录成功调用后父进程中 fork() 返回的子进程的 pid
switch(child_pid = fork())
{
	case -1:  // 错误到此分支
		// 错误处理
		break;
	case 0:  // 子进程到此分支
		// 子进程代码
		break;
	default:  // 父进程到次分支
		// 父进程处理的代码
		break;
};
// 子进程或父进程共同执行的代码
```

> [!attention] 
> 
> 调用 `fork()` 之后，**系统将率先执行于哪个进程（即调度其使用 CPU），是无法确定的**，意识到这一点极为重要
> 
> 在设计拙劣的程序中，这种不确定性可能会导致所谓 “**竞争条件**（race condition）”的错误
> 
> 关于竞争条件，在 [[Linux 系统编程：深入文件 IO#原子操作和竞争条件]] 有过介绍
> 

下面的例程验证了 `fork()` 创建的子进程与父进程之间是隔离的

```c title:procexec/t_fork.c
#include <unistd.h>  
  
#include "base.h"  
  
static int idata = 111; // 数据段  
  
int main() {  
  
    int istack = 222; // 栈区  
    pid_t child;  
  
    switch (child = fork()) {  
        case -1:  // fork 失败  
            errExit("fork");  
        case 0:  // 子进程  
            istack *= 3;  
            idata *= 3;  
            break;  
        default: // 父进程  
            sleep(1); // 让父进程等待子进程结束  
            break;  
    }  
    // 父进程和子进程都会执行  
    printf("%s[PID %ld] idata = %d and &idata = %p; istack = %d and &istack = %p\n",  
        (child == 0)?"child": "parent",  
        (long)getpid(),  
        idata, &idata,  
        istack, &istack);  
    return 0;  
}
```

编译并执行的结果如下

```shell
$ ./t_fork
child[PID 2028613] idata = 333 and &idata = 0x5c38fe429010; istack = 666 and &istack = 0x7ffc975d2e80
parent[PID 2028612] idata = 111 and &idata = 0x5c38fe429010; istack = 222 and &istack = 0x7ffc975d2e80
```

### 父子进程之间共享打开文件句柄

执行 `fork()` 时，子进程会获得父进程所有文件描述符的副本。这些副本的创建类似于 `dup()` 

> [!hint] 
> 
> **父子进程中对应的文件描述符指向相同的打开文件句柄**。即，父子进程中相同的文件描述符指向相同的系统级打开文件表项
> 

在 [[Linux 系统编程：深入文件 IO]] 中我们介绍过，系统级打开文件表项中包含当前文件偏移量以及文件状态标志

> [!hint] 
> 
> 一个打开文件的 **文件偏移** 和 **文件状态标志** 在父子进程间实现了共享
> 
> + 父进程修改了文件偏移量，这些修改在子进程中也会反应出来
> 

父子进程共享打开文件表项可以保证 **当父子进程同时写入文件** 时，**写入内容不会彼此覆盖**。但是，父子进程写入文件的 **内容可能会交错在一起**

> [!tip] 
> 
> 如果需要规避父子进程写入文件内容出现交错，需要进行 **进程同步** 或者使用 [[Linux 系统编程：文件锁]]
> 

如果不需要这种对文件描述符的共享方式，那么设计程序时，应于 `fork()` 调用后注意下面两点

> [!attention] 
> 
> + 令父、子进程使用不同的文件描述符
> + 各自立即关闭不再使用的描述符
>   

如下图展示了执行 `fork()` 期间对文件描述符的复制，以及关闭不再使用的描述符

![[Pasted image 20241102214240.png]]

### fork() 的内存语义

从概念上说来，可以将 `fork()` 认作对父进程 **文本段**、**数据段**、**堆段** 以及 **栈段** 创建 **拷贝**。在一些早期的 UNIX 实现中，此类复制确实是原汁原味

> [!tip] 
> 
> 将父进程内存 **拷贝至交换空间**，以此创建新进程映像(`image`)，而在父进程保持自身内存的同时，将 **换出映像置为子进程**
> 

然而，啧啧原汁原味的复制非常浪费时间，因为拷贝到交换空间和从交换空间换出涉及到磁盘访问。然而，`fork()` 之后往往伴随 `exec()`，会使用新程序 **替换进程的代码段**，并 **重新初始化数据段、堆段和栈段**

大部分现代 `UNIX` 实现（包括 `Linux`）采用两种技术来避免这种浪费

> [!tip] 代码段标记为只读
> 
> 内核将进程的代码段标记为只读，从而进程无法修改自身代码。父子进程可以共享代码段。 `fork()`  在为子进程创建代码段时，其所构建的一系列进程级页表项均指向与父进程相同的物理内存页帧
> 

> [!tip] 写时复制
> 
> 对于父进程 **数据段**、**堆段** 和 **栈段** 中的各页，内核采用 **写时复制**（copy-on-write）技术来处理
> 
> 最初，内核做了一些设置，令这些段的页表项指向与父进程相同的物理内存页，并将这些页面自身标记为只读
> 
> 调用 `fork()` 之后，内核会 **捕获所有父进程或子进程针对这些页面的修改企图**，并 **为将要修改的页面创建拷贝**
> 
> **系统将新的页面拷贝分配给遭内核捕获的进程**，还会对子进程的相应页表项做适当调整。从这一刻起，父、子进程可以分别修改各自的页拷贝，不再相互影响
> 

下图展示对一共享写时复制页进行修改前后的页表

![[Pasted image 20241102215348.png]]

## vfork()

正如前所述，早期 BSD 实现中，`fork()` 会对父进程的数据段、堆和栈施行 **严格的复制**，这是一种浪费，尤其是在调用 `fork()` 之后立即执行 `exec()` 的情况下。

出于上述原因，BSD 引入了 `vfork()` 系统调用，其含义于 `fork()` 类似，但是 `vfork()` 的行为有些怪异。由于现代 Unix 采用 **写时复制** 技术实现 `fork()`，其效率远高于早期 `fork()` 的实现，`vfork()` 的作用也逐渐减少

现代 Unix，包括 Linux， 还是提供了 `vfork()` 系统调用，以期为程序提供尽可能快的 `fork` 功能

> [!attention] 
> 
> 除非能够性能带来重大提升，否则尽量避免使用 `vfork()`
> 

`vfork()` 可以为调用进程创建一个新的子进程。然而，`vfork()` 是为子进程立即执行 `exec()` 的程序而专门设计的

```c
#include <unistd.h>

pid_t vfork(void);
/* 成功：父进程中返回子进程的 PID; 子进程中返回 0；错误返回 -1 */
```

`vfork()` 因为如下两个特性而更具效率，这也是其与 `fork()` 的区别所在

> [!tip] 没有为子进程复制虚拟内存页或页表
> 
> `vfork()` 没有为子进程复制虚拟内存页或页表。子进程共享父进程的内存，直到成功调用 `exec()` 或 `_exit()` 退出
> 

> [!tip] 暂停执行父进程
> 
> 在子进程调用 `exec()` 或 `_exit()` 之前，将暂停执行父进程
> 

> [!attention] 
> 
> 由于子 **进程使用父进程的内存**，因此子进程对数据段、堆或栈的任何改变将在父进程恢复执行时为其所见
> 

在不影响父进程的前提下，子进程能在 `vfork()` 与 `exec()` 之间所做的操作屈指可数。能够在 `vfork()` 和 `exec()` 之间做的操作包括了 **打开文件描述符进行操作**

> [!tip] 
> 
> 因为系统是在内核空间为每个进程维护文件描述符表，且在 `vfork()` 调用期间将复制该表，所以 **子进程对文件描述符的操作不会影响到父进程**
> 

> [!attention] SUSv3 指出，在如下情况下程序行为未定义
> 
> 修改了除用于存储 `vfork()` 返回值的 `pid_t` 型变量之外的任何数据
> 
> 从调用 `vfork()` 的函数中返回
> 
> 在成功地调用 `_exit()` 或执行 `exec()` 之前，调用了任何其他函数。
> 

`vfork()` 的语义在于执行该调用后，系统将保证子进程先于父进程获得调度以使用 CPU 

## fork() 之后的竞争条件

调用 `fork()` 后，**无法确定父子进程间谁将率先访问 CPU**。如果为了产生正确结果依赖特定的执行顺序，那么就会因竞争条件而导致得到错误的结果

> [!tip] 
> 
> 不应该对 `fork()` 之后执行 父子进程的特定顺序做出任何假设。如果确实需要 **保证某种特定执行顺序**，必须 **采用同步技术**
> 

后续会相继介绍各种同步技术
