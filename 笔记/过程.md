# 过程

**过程** 是软件中一种重要的抽象，提供了一种 **封装代码的方式**，用一组指定的 **参数** 和一个可选的 **返回值** 实现了某种功能。然后，可以 **在不同的地方调用这个过程**

> [!tip]
> 
> 设计良好的软件用过程作为抽象机制，**隐藏某个行为的具体实现**，同时又提供清晰简洁的接口定义，说明要计算哪些值，过程会程序状态产生什么样的影响
> 

> [!tip]
> 
> 过程的形式多样。在不同的语言中的称呼也不同。常见的一些称呼为：函数、方法、子列程、处理函数等
> 

要提供对过程的机器级支持，必须要处理许多不同的属性。我们假设 过程 $P$ **调用** 过程 $Q$, 过程 $Q$ **执行后返回** 到 过程 $P$。这些动作包括下面一个或多个机制

> [!tip] 传递控制
> 
> 在进入过程 $Q$ 的时候，**PC 被设置为过程 $Q$ 指令的起始位置**
> 
> 返回时，**PC 被设置为调用 $Q$ 之后的那条指令的地址**
> 

> [!tip] 传递数据
> 
> 过程 $P$ 向 过程 $Q$ **提供一个或多个参数**
> 
> 过程 $Q$ 向 过程 $P$ **返回一个值**
> 

> [!tip] 分配和释放内存
> 
> 在开始时，过程 $Q$ 可能需要为局部变量分配空间
> 
> 返回前，过程 $Q$ 必须释放这些空间
> 

`x86-64` 的过程实现包括 **一组特殊的指令** 和 **一些对机器资源使用的约定规则**

## 运行时栈

C 语言过程调用机制的一个 **关键特性**（大多数语言也是如此）在于 **使用了 _栈_ 数据结构提供的 _后进先出_ 的内存管理原则**

在过程 $P$ 调用过程 $Q$ 的例子中，可以看到当 $Q$ 在执行时，$P$ 以及所有向上追溯到 $P$ 的调用链中的过程，都是暂时被挂起的

> [!tip]
> 
> **当 Q 运行时**，它只需要 **为局部变量分配新的存储空间**，或 **设置到另一个过程调用**
> 
> **当 Q 返回时**，任何被 **它分配的存储空间都会被释放**
> 

因此，程序可以用栈来管理它的过程所需要的存储空间，栈和程序寄存器存放在传递控制和数据、分配内存所需要的信息

> [!tip]
> 
> **当 P 调用 Q 时**，控制和数据信息 **添加到栈顶**
> 
> **当 Q 返回时**，这些信息 **被释放**
> 

在 x86-64 的 **栈向低地址方向增长**，而 **栈指针 `%rsp`** 指向栈顶元素。可以用 `pushq` 和 `popq` 指令将数据存入栈中和从栈中取出

> [!tip] 
> **`%rsp` 减小一个适当的量** 可以为没有初始值的数据 **在栈上分配空间**
> 
> **`%rsp` 增加一个适当的量** 可以 **释放空间**
> 

当 x86-64 过程需要的 **存储空间超出寄存器能够存放的大小** 时，就会 **在栈上分配空间**。这个部分称为过程的 **栈帧**。如下图，给出了 **运行时栈的通用结构**，包括它划分为栈帧

![[Pasted image 20241006215440.png]]


> [!tip] 
> 
> **当前正在执行的过程的栈帧总是在栈顶**。**当过程 $P$ 调用过程 $Q$ 时**，会把 **返回地址** 压入栈中，指明当 $Q$ 返回时，要从 $P$ 过程的哪个位置进继续执行
> 
> **我们把这个返回地址当做 $P$ 的栈帧的一部分，应为它存放的是与 $P$ 相关的状态**
> 

> [!tip] 
> 
> **$Q$ 的代码会扩展当前栈的边界**，分配它的栈帧所需要的空间。在这个空间中，它可以 **保存寄存器的值**，**分配局部变量的空间**，**为调用的过程设置参数**。大多数过程的栈帧都是 **定长** 的，在过程开始就分配好了。但是有些过程的栈帧是 **变长** 的
> 

> [!tip] 
> 
> 通过 _寄存器_，过程 $P$ 可以 **_传递 6 个整数值_**（指针和整数）给过程 $Q$
> 
> 如果过程 $Q$ 需要更多的参数，**过程 $P$ 可以在调用过程 $Q$ 之前在自己的栈帧中存储好这些参数**
> 

为了提高空间和时间效率，**x86-64 过程只分配自己需要的栈帧部分**

> [!summary] 
> 
> **过程需要的参数少于等于 $6$ 个时，所有参数都可以通过寄存器传递**。实际上，许多函数甚至根本不需要栈帧。当所有局部变量都可以保存在寄存器中，而且该过程不会调用任何其他过程(有时称为叶子过程)时，就可以这样处理
> 

## 转移控制

将控制 **从函数 $P$ 转移到函数 $Q$** 只需要简单地把 **程序计数器(PC)** 设置为 $Q$ 的代码的  **起始位置**。当从 $Q$ 返回时，处理器必须 **记录好它需要继续 $P$ 的执行的代码位置**

在 x86-64 机器中，记录过程 $P$ 继续执行的代码位置信息是用指令 `call Q` 调用过程 $Q$ 来记录。该指令 **会把地址 $A$ 压入栈中**，并 **将 PC 设置为 $Q$ 的起始地址**。压入的地址 $A$ 被称为 **返回地址**，是紧跟在 `call` 指令后面那条指令的地址。`call` 对应的 **指令 `ret`** 会 **从栈中弹出地址 $A$，并把 PC 设置为 $A$**

下表给出了`call` 和 `ret` 指令的一般形式

| 指令              | 描述        |
| :-------------- | :-------- |
| `call Lable`    | 过程调用，直接调用 |
| `call *Operand` | 过程调用，间接调用 |
| `ret`           | 从过程调用中返回  |

> [!tip]
> 
> **call 指令** 有一个 **目标**，即指明被调用过程起始的指令地址。与跳转一样，调用可以是 **直接调用**，也可以是 **间接调用**

下面一段反汇编代码是 `mulstore` 和 `main` 函数的 `call` 和 `ret` 指令的执行情况

```c
0000000000400540 <multstore>:
    400540:	53                   	push   %rbx
    400541:	48 89 d3             	mov    %rdx,%rbx
    ...
    40054d:	c3                   	ret

    
000000000040055f <main>:
    ...
    400563:	e8 3c 00 00 00       	call   400540 <multstore>
    400568:	48 8b 34 24          	mov    (%rsp),%rsi
    ...
```

在 `main` 函数中，地址 `0x400563` 的 `call` 指令调用函数 `multstore`。此时的状态如下图 `a` 所示，指明了栈指针 `%rsp` 和程序计数器(`PC`) `%rip` 的值

![[Pasted image 20241006223427.png]]

> [!summary] 
> 
> `call` 的效果是将返回地址 `0x400568` 压入栈中，并跳转到函数 `multstore` 的第一条指令，地址为 `0x0400540`(图 `b`)
> 
> 函数 `multstore` 继续执行，直到遇到地址 `0x40054d` 出的 `ret` 指令。该指令从栈中弹出值 `0x400568`, 然后跳转到这个地址，就在 `call` 指令之后，继续 `main` 函数的执行
> 

## 传递数据

当调用一个过程时，**除了要控制传递** 给它并在过程返回时在传递回来之外，过程调用还可能包括 **把数据作为参数传递**，而 **从过程返回还有可能包括返回一个值**。x86-64 中，大部分过程间的数据传送时通过寄存器实现的。例如，参数在寄存器 `%rdi, %rsi` 和其他寄存器中传递

当过程 $P$ 调用过程 $Q$ 时，$P$ 的代码必须首先把参数复制到适当的寄存器中。类似的，当 $Q$ 返回到 $P$ 时，$P$ 的代码可以访问寄存器 `%rax` 中的返回值

**x86-64 中，可以通过寄存器最多传递 $6$ 个整型(例如整数和指针)参数**。**寄存器的使用是有特殊顺序的**，寄存器使用的名字取决于要传递的数据类型的大小，如下图所示。会根据参数在参数列表中的顺序为它们分配寄存器

![[Pasted image 20241006223801.png]]

假设 **过程 $P$ 调用过程 $Q$**，有 $n$ 个整型参数且 $n > 6$，**那么 $P$ 的代码分配栈帧必须能容纳 $7$ 到 $n$ 号参数的存储空间**

> [!tip]
> 
> 把参数$1\sim 6$ 复制到对应的寄存器，把参数 $7\sim n$ 放到栈上，而参数 $7$ 位于栈顶。**通过栈传递参数时，所有的数据大小都向 8 的倍数对齐**
> 
> 相应的，如果 $Q$ 也调用了某个超过 $6$ 个参数的函数，它也需要在自己的栈帧中为超过 $6$ 个部分的参数分配空间
> 

考虑如下函数，作为参数传递示例。该函数有 `8` 个参数, 包括字节数不同的整数（`8,4,2`和`1`）和不同类型的指针(每个指针都是八字节)

```c
void proc(long a1, long *a1p, int a2, int *a2p, short a3, short *a3p, char a4, char *a4p)
{
    *a1p += a1;
    *a2p += a2;
    *a3p += a3;
    *a4p += a4;
}


int main() {
    long    a1 = 0;
    int     a2 = 0;
    short   a3 = 0;
    char    a4 = 0;
    proc(0x4d2l, &a1, 0x20, &a2, (short) 0xc, &a3, (char) 0x60, &a4);
    return 0;
}
```

GCC 生成的汇编代码如下

```c
// void proc(long a1, long *a1p, int a2, int *a2p, short a3, short *a3p, char a4, char *a4p)
// a1  	in 	%rdi 		(64 bits)
// a1p 	in 	%rsi 		(64 bits)
// a2  	in 	%edx 		(32 bits)
// a2p 	in 	%rcx 		(64 bits)
// a3  	in 	%r8w 		(16 bits)
// a3p 	in 	%r9  		(64 bits)
// a4  	in 	%rsp + 8 	(8 bits)
// a4p 	in 	%rsp + 16 	(64 bits)
0000000000001139 <proc>:
    1139:	48 8b 44 24 10       	mov    0x10(%rsp),%rax  // 读取 a4p 的值存入 %rax
    113e:	48 01 3e             	add    %rdi,(%rsi)      // *a1p += a1
    1141:	01 11                	add    %edx,(%rcx)      // *a2p += a2
    1143:	66 45 01 01          	add    %r8w,(%r9)       // *a3p += a3
    1147:	8b 54 24 08          	mov    0x8(%rsp),%edx   // 将栈中的 0x8(%rsp) 的值存入 %edx
    114b:	00 10                	add    %dl,(%rax)       // *a4p += a4
    114d:	c3                   	ret

000000000000114e <main>:
    114e:	48 83 ec 28          	sub    $0x28,%rsp       // 为栈分配 0x28 字节的空间
    1152:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    1159:	00 00 
    115b:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    1160:	31 c0                	xor    %eax,%eax        // 将 %eax 置为 0：开始准备参数
    1162:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)  // a1 = 0
    1169:	00 00 
    116b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%rsp)   // a2 = 0
    1172:	00 
    1173:	66 c7 44 24 0a 00 00 	movw   $0x0,0xa(%rsp)   // a3 = 0
    117a:	c6 44 24 09 00       	movb   $0x0,0x9(%rsp)   // a4 = 0
    117f:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx   // 将栈中的 0xc(%rsp) 的地址存入 %rcx  第四个参数(a2p)
    1184:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi  // 将栈中的 0x10(%rsp) 的地址存入 %rsi 第二个参数(a1p)
    1189:	48 8d 44 24 09       	lea    0x9(%rsp),%rax   // 将栈中的 0x9(%rsp) 的地址存入 %rax
    118e:	50                   	push   %rax             // 将 %rax 的值存入栈中  第八个参数(a4p) %rsp = %rsp - 0x8
    118f:	6a 60                	push   $0x60            // 将 $0x60 的值存入栈中 第七个参数(a4)  %rsp = %rsp - 0x8
    1191:	4c 8d 4c 24 1a       	lea    0x1a(%rsp),%r9   // 将栈中的 0x1a(%rsp) 的地址存入 %r9 第六个参数(a3p) 
    1196:	41 b8 0c 00 00 00    	mov    $0xc,%r8d        // 第五个参数(a3)
    119c:	ba 20 00 00 00       	mov    $0x20,%edx       // 第三个参数(a2)
    11a1:	bf d2 04 00 00       	mov    $0x4d2,%edi      // 第一个参数(a1) 参数准备完毕
    11a6:	e8 8e ff ff ff       	call   1139 <proc>      // 调用 proc 函数，将返回地址存入栈中
    11ab:	48 83 c4 10          	add    $0x10,%rsp       // 返回地址
    ....
    
高地址   栈帧                       %rsp 的变化         main 指令            进入 proc 时 %rsp 位置
|---------------------------|                   |                       |
|                           |                   |                       |
|---------------------------|                   |                       |
|                           |                   |                       |
|---------------------------|                   |                       |
|                           |                   |                       |
|---------------------------|                   |                       |
|                           |                   |                       |
|---------------------------| <- %rsp + 0x18    |                       |
|       long a1 = 0         |                   |                       |
|---------------------------| <- %rsp + 0x10    |movq   $0x0,0x10(%rsp) |
|        int a2 = 0         |                   |                       |
|---------------------------| <- %rsp + 0xc     |movl   $0x0,0xc(%rsp)  |
|      short a3 = 0         |                   |                       |
|---------------------------| <- %rsp + 0xa     |movw   $0x0,0xa(%rsp)  |
|      char a4 = 0          |                   |                       |
|---------------------------| <- %rsp + 0x9     |movb   $0x0,0x9(%rsp)  |
|                           |                   |                       |
|---------------------------|                   |                       |
|                           |                   |                       |
|---------------------------|                   |                       |
|                           |                   |                       |
|---------------------------| <- %rsp           |                       |
|       0x9(%rsp) &a4       |                   |                       |
|---------------------------| <- %rsp - 0x8     | push   %rax           |
|       0x60                |                   |                       |
|---------------------------| <- %rsp - 0x10    | push   $0x60          |
|       0x11ab              |                   |                       |
|---------------------------| <- %rsp - 0x18    | call   1139 <proc>    | <- %rsp
```

前面 `6` 个参数通过寄存器传递，后面两个参数通过栈传递。栈帧结构如下图

![[Pasted image 20241006224443.png]]

可以看到，这个两个参数位于相对于栈指针距离为 `8` 和 `16` 的位置

##  栈上的局部存储

有些时候，**局部数据必须存放在内存中**，常见的情况如下

-  寄存器不足够存放所有本地数据
- 对局部变量使用 **取地址运算符&**, 因此必须能够为它产生一个地址
- 某些局部变量是 **数组或结构**，必须能够通过数组或结构引用被访问到。

> [!tip]
> 
> 通过 **减小栈指针** 在栈上分配空间。分配的 结果作为栈帧的一部分，标号为 局部变量
> 

现在来看一个关于 处理取地址运算符的例子。如下代码中，函数 `swap_add` 交换指针 `xp` 和 `yp` 指向的两个值，并返回这两个值的和；函数 `caller` 创建到局部变量 `arg1` 和 `arg2` 的指针，把它们传递给 `swap_add`

```c
// 交换指针 xp 和 yp 指向的两个值，并返回它们的和
long swap_add(long *xp, long *yp) {
    long x = *xp;
    long y = *yp;
    *xp = y;
    *yp = x;
    return x + y;
}

// 展示如何用栈帧来实现这些变量
long caller() {
    long arg1 = 534;
    long arg2 = 1057;
    long sum = swap_add(&arg1, &arg2);
    long diff = arg1 - arg2;
    return sum * diff;
}
```

`GCC`生成的汇编代码如下

```c
0000000000001139 <swap_add>:
    1139:	48 8b 07             	mov    (%rdi),%rax
    113c:	48 8b 16             	mov    (%rsi),%rdx
    113f:	48 89 17             	mov    %rdx,(%rdi)
    1142:	48 89 06             	mov    %rax,(%rsi)
    1145:	48 01 d0             	add    %rdx,%rax
    1148:	c3                   	ret

0000000000001149 <caller>:
    1149:	48 83 ec 28          	sub    $0x28,%rsp           // 在栈上分配 0x28 = 40 字节的空间
    114d:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax        // 获取栈底指针
    1154:	00 00 
    1156:	48 89 44 24 18       	mov    %rax,0x18(%rsp)      // 保存栈底指针
    115b:	31 c0                	xor    %eax,%eax            // 将 %eax 置为 0
    115d:	48 c7 44 24 08 16 02 	movq   $0x216,0x8(%rsp)     // arg1 = 534
    1164:	00 00 
    1166:	48 c7 44 24 10 21 04 	movq   $0x421,0x10(%rsp)    // arg2 = 1057
    116d:	00 00 
    116f:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi      // &arg2
    1174:	48 8d 7c 24 08       	lea    0x8(%rsp),%rdi       // &arg1
    1179:	e8 bb ff ff ff       	call   1139 <swap_add>      // swap_add(&arg1, &arg2)
    117e:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx       // 
    1183:	48 2b 54 24 10       	sub    0x10(%rsp),%rdx
    1188:	48 0f af c2          	imul   %rdx,%rax
    ...
```

> [!summary] 
> 
> 函数 `caller` 的汇编代码展示了是如何用栈帧来实现这些局部变量的。`caller` 的代码的开始的时候把指针减掉 `40(0x28)`；实际上就是在栈上分配 `40` 个字节。用 `S` 表示栈指针的值，可以看到这段代码计算`&arg2`  为 `S+16`；`&arg1`为 `S + 8`；可以推断出局部变量 `arg1` 和 `arg2` 存放在相对于栈指针`%rsp`偏移量为 `8` 和 `16` 个字节
> 
> 当 `swap_add` 调用完成后，会从栈上取出这两个值，计算它们的差，在再乘以 `swap_add` 在 `%rax` 中存放的值(`117e-1188`)
> 

下面函数 `call_proc` 是一个更复杂的例子，说明 `x86-64` 栈行为的一些特性。

```c
void proc(long a1, long *a1p, int a2, int *a2p, short a3, short *a3p, char a4, char *a4p) {
    *a1p += a1;
    *a2p += a2;
    *a3p += a3;
    *a4p += a4;
}

long call_proc() {
    long x1 = 1;	// 64bits(8 bytes)
    int x2 = 2;		// 32bits(4 bytes)
    short x3 = 3;	// 16bits(2 bytes)
    char x4 = 4;	// 8bits (1 byte)
    proc(x1,&x1, x2, &x2, x3, &x3, x4, &x4);
    return (x1 + x2) * (x3 - x4);
}
```

下图给出了必须在栈上分配局部变量存储空间的函数，同时还要向有 `8` 个参数的函数 `proc` 传递值。该函数创建一个栈帧，如下图

![[Pasted image 20241006225043.png]]

GCC 生成的汇编代码如下

```c
0000000000001139 <proc>:
    1139:       48 8b 44 24 10          mov    0x10(%rsp),%rax
    113e:       48 01 3e                add    %rdi,(%rsi)
    1141:       01 11                   add    %edx,(%rcx)
    1143:       66 45 01 01             add    %r8w,(%r9)
    1147:       8b 54 24 08             mov    0x8(%rsp),%edx
    114b:       00 10                   add    %dl,(%rax)
    114d:       c3                      ret
// void proc(long a1, long *a1p, int a2, int *a2p, short a3, short *a3p, char a4, char *a4p)
// long call_proc()
000000000000114e <call_proc>:
    114e:       48 83 ec 28             sub    $0x28,%rsp		// 为 call_proc 申请 40 字节的栈帧
    1152:       64 48 8b 04 25 28 00    mov    %fs:0x28,%rax
    1159:       00 00 
    115b:       48 89 44 24 18          mov    %rax,0x18(%rsp)
    1160:       31 c0                   xor    %eax,%eax
    1162:       48 c7 44 24 10 01 00    movq   $0x1,0x10(%rsp)	// 存储 1 到 &x1
    1169:       00 00 
    116b:       c7 44 24 0c 02 00 00    movl   $0x2,0xc(%rsp)	// 存储 2 到 &x2
    1172:       00 
    1173:       66 c7 44 24 0a 03 00    movw   $0x3,0xa(%rsp)	// 存储 3 到 &x3
    117a:       c6 44 24 09 04          movb   $0x4,0x9(%rsp)	// 存储 4 到 &x4
    117f:       48 8d 4c 24 0c          lea    0xc(%rsp),%rcx	// [第4个参数]获取 x2 的地址
    1184:       48 8d 74 24 10          lea    0x10(%rsp),%rsi	// [第2个参数]获取 x1 的地址
    1189:       48 8d 44 24 09          lea    0x9(%rsp),%rax	// 获取 x4 的地址
    118e:       50                      push   %rax				// [第8个参数]x4 的地址压入栈
    118f:       6a 04                   push   $0x4				// [第7个参数]把 4 压入栈
    1191:       4c 8d 4c 24 1a          lea    0x1a(%rsp),%r9	// [第6个参数]
    1196:       41 b8 03 00 00 00       mov    $0x3,%r8d		// [第5个参数]
    119c:       ba 02 00 00 00          mov    $0x2,%edx		// [第3个参数]
    11a1:       bf 01 00 00 00          mov    $0x1,%edi		// [第1个参数]
    11a6:       e8 8e ff ff ff          call   1139 <proc>		// 调用 proc
    11ab:       48 63 44 24 1c          movslq 0x1c(%rsp),%rax	// 获取 x2 并转为 64 位
    11b0:       48 03 44 24 20          add    0x20(%rsp),%rax	// 获取 x1 并与 x2 相加
    11b5:       0f bf 54 24 1a          movswl 0x1a(%rsp),%edx	// 获取 x3 并转为 32 位
    11ba:       0f be 4c 24 19          movsbl 0x19(%rsp),%ecx	// 获取 x4 并转为 32 位
    11bf:       29 ca                   sub    %ecx,%edx		// 计算 x3 - x4
    11c1:       48 63 d2                movslq %edx,%rdx		// 将 x3 - x4 的结果转为 64 位
    11c4:       48 0f af c2             imul   %rdx,%rax		// 计算 (x1 + x2) * (x3 - x4)
    11c8:       48 83 c4 10             add    $0x10,%rsp		// 清楚 x4 和 &x4 的栈帧
    11cc:       48 8b 54 24 18          mov    0x18(%rsp),%rdx
    11d1:       64 48 2b 14 25 28 00    sub    %fs:0x28,%rdx
    11d8:       00 00 
    11da:       75 05                   jne    11e1 <call_proc+0x93>
    11dc:       48 83 c4 28             add    $0x28,%rsp		// 销毁call_proc栈帧
    11e0:       c3                      ret
```

## 寄存器中的局部存储空间

**寄存器组 是 _唯一_ 被所有过程共享的资源**。虽然 **在给定时刻只有 一个过程 是活动的**，我们仍然必须确保当一个过程（调用者）调用另一个过程（被调用者）时，**被调用者不会覆盖调用者稍后会使用的寄存器值**。为此，x86-64 采用了一组统一的寄存器使用惯例，所有过程（包括程序库）都必须遵守

x86-64 将寄存器分为两类：**被调用者保存(Callee Saved)** 和 **调用者保存(Caller Saved)**

> [!tip] Callee Saved
> 
> **被调用者保存寄存器**，包括 **%rbx,  %rbp, %r12, %r13, %r14, %r15** ：当过程 $P$ 调用过程 $Q$ 时，**$Q$(被调用者) 必须保存这些寄存器的值**，保证它们的值在 $Q$ 返回到 $P$ 时与 $Q$ 被调用时是一样的
> 
> 过程 $Q$ 保存这一个寄存器的值不变，**要么就是根本 _不去改变他_**，**要么把 _原始值压入栈_ 中，改变寄存器的值，然后 _在返回前从栈中弹出旧值_**
> 

> [!tip] Caller Saved
> 
> **调用者保存寄存器** 可以被任何函数修改，**除了被调用者寄存器和 `%rsp `之外**。可以这样理解 **调用者保存**：过程 $P$ 在某个此类寄存器中有局部数据，然后调用过程 $Q$。因为 $Q$ 可以随意修改这个寄存器，所以调用前首先 **保存好这个数据是 $P$(调用者) 的责任**
> 

下面来看一个例子，如下函数 $P$，它调用两次 $Q$

```c
long Q(long x) {
    return x * x;
}

long P(long x, long y) {
    long u = Q(y);  // 第一次调用中，必须保存 x 的值以备后面使用
    long v = Q(x);  // 第二次调用，必须保存 Q(y) 的值
    return u + v;
}
```

`GCC` 生成的汇编代码如下

```c
// long Q(long x)
// x in %rdi
Q:
	leaq	0(,%rdi,8), %rax
	ret

// long P(long x, long y)
// x in %rdi, y in %rsi
P:
	pushq	%rbp        // save callee's %rbp (frame pointer)
	pushq	%rbx        // save callee's %rbx
	movq	%rdi, %rbp  // save x in %rbp
	movq	%rsi, %rdi  // save y in %rdi
	call	Q           // call Q(y)
	movq	%rax, %rbx  // save Q(y) in %rbx
	movq	%rbp, %rdi  // restore x in %rdi
	call	Q           // call Q(x)
	addq	%rbx, %rax  // add Q(y) to Q(x)
	popq	%rbx        // restore caller's %rbx
	popq	%rbp        // restore caller's %rbp
	ret
```

使用了两个被调用者保存寄存器：`%rbp` 保存 `x` 和 `%rbx` 保存计算出来的`Q(y)` 的值。在函数的开头，把这两个寄存 (`%rbp` 和 `%rbx`) 保存到栈中。在第 一 次调用 $Q$ 之前，把参数 `x` 复制到 `％rbp`。在第二次调用 `Q` 之前，把这次调用的结果复制到 `％rbx`。在函数结尾，把它们从栈中弹出，恢复这两个被调用这保存寄存器的值

> [!attention] 
> 
> 注意它们的弹出顺序与斥入顺序相反，说明了栈的后进先出规则 。
> 
