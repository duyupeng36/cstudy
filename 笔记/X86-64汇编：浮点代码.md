# 浮点代码

处理器的 **浮点体系结构** 包括多个方面，会影响对浮点数据操作的程序如何被映射到机器上，包括

+ 如何存储和访问浮点数值，通常是同某种寄存器方式完成
+ 对浮点数据操作的指令
+ 向函数传递浮点数参数和从函数返回浮点数结果的规则
+ 函数调用过程中保存寄存器的规则

在 1997 年出现了 Pentium/MMX, Intel 和 AMD 都引入了持续代数的媒体指令，支持图形和图像处理。这些指令允许 **多个** 操作以 **并行模式** 执行，称为 **单指令多数据流(SIMD)**, 对多个不同的数据执行同一个操作

这些扩展从 `MMX` 到 `SSE(流式 SIMD 扩展)` 以及最新的 `AVX(高级向量扩展)`。每一代都有不同的版本，每个扩展都是管理寄存器组中的数据，这些寄存器组在 `MMX` 中称为 `MM` 寄存器（ 64 位），在 `SSE` 中称为 `XMM` 寄存器（128 位），在 `AVX` 中称为 `YMM` 寄存器（256 位）。每个 `YMM` 寄存器可以存放 `8` 个 `32` 位值，或 `4` 个 `64` 位值，它们可以是整数，也可以是浮点数

`2000` 年的 `SSE2` 媒体指令包括那些对 **标量** 浮点数进行操作的指令，使用 `XMM` 和 `YMM` 的低 `32` 位 或 `64` 位 中的单个值。类似于其他处理器支持浮点数的方式，所以能够执行 `x86-64` 代码的处理器都支持 `SSE2` 或更高版本。

如下图所示, `AVX2` 浮点体系结构允许存储数据在 `16` 个 `YMM` 寄存器中，名字分别为 `%ymm0~%ymm15`。每个 `YMM` 寄存器都是 `256` 位(`32` 字节)

![[Pasted image 20241006232033.png]]

## 浮点传送和转换操作

如下表，给出了一组在 **内存** 和 **XMM 寄存器** 之间以及一个 **XMM 寄存器** 到另一个不做任何转换的传送浮点数指令

![[Pasted image 20241006232208.png]]

> [!tip] 
> 
> 引用内存的指令是 **标量** 指令，意味着它们 **只对单个** 而不是一组封装好的 **数据值** 进行操作
> + 数据要么保存在内存中，上表中表示为 $M_{32}$ 或 $M_{64}$
> + 要么保存在 `XMM` 寄存器中，上表表示为 `X`
> 
> 

数据对齐与否，这些指令都能正确执行。不过代码优化规则建议：`32` 位内存数据满足 `4` 字节对齐，`64` 位内存数据满足 `8` 字节对齐

> [!tip]
>  **内存引用的指令方式与整数 MOV 指令一样**，包括偏移量、基址寄存器、变址寄存器和伸缩因子的所有可能组合
>  

**GCC 只用标量传送**  操作 **从内存传送数据到 XMM 寄存器** 或 **从 XMM 寄存器传送数据到内存**。对于两个 **XMM 寄存器之间传送数据**，`GCC` 会使用 **`vmovaps` 传送单精度浮点数** 和 **`vmovapd` 传送双精度浮点数**

> [!tip] 
> 上述两个指令(`vmovaps` 和 `vmovapd`)复制整个寄存器还是只复制低位值不会有任何影响。指令名中的 `a` 表示 `aligned` 表示对齐
> 
> 当用于读写内存时，如果 **地址不满足 16 字节对齐，它们会导致异常**。在两个寄存器之间传送数据，不会出现错误对齐的状况
> 

下面是一个不同浮点传送操作的实例

```c
float float_mov(float v1, float *src, float *dst) {
    float v2 = *src;
    *dst = v1;
    return v2;
}
```

GCC 生成的汇编代码如下

```c
// float float_mov(float v1, float *src, float *dst)
// v1 in %xmm0, src in %rdi, dest in %rsi
float_mov:
	movaps	%xmm0, %xmm1        // xmm1 = xmm0
	movss	(%rdi), %xmm0       // xmm0 = *src
	movss	%xmm1, (%rsi)       // *dst = xmm1
	ret
```


下面给出的指令是 _在浮点数值和整数数据类型之间_ 以及 _不同浮点格式之间_ 进行 **转换** 的指令集合。这些都是对单个数据值进行操作的 **标量指令**

> [!tip] 浮点数转换为整数
> 
> **把一个从 XMM寄存器或内存中读出的浮点数进行转换，并将结果写入一个通用寄存器**
> 
> ![[Pasted image 20241006232820.png]]
> 
> 浮点数转换为整数时，通常会执行 截断，值向 0 进行舍入
> 


> [!tip] 整数转换为浮点数
> 
> 这类指令需要三个操作数，两个源操作数和一个目的操
> 
> ![[Pasted image 20241006233040.png]]
> + 第一个操作数 **读自于内存**，或一个 **通用目的寄存器**
> + 第二个操作数可以忽略，它的值只会影响高位字节
> + 第三操作数（目标操作数）**必须是 XMM 寄存器**
> 

## 浮点运算

下表描述了一组执行算术运算的标量 `AVX2` 浮点指令。

![[Pasted image 20241006233250.png]]

- 每条指令有一个($S_1$)或两个($S_1,S_2$)源操作数和一个目的操作数($D$)
- 第一个源操作数 $S_1$ 可以是一个 `XMM` 寄存器或内存位置
- 第二个原操作 $S_2$ 和目的操作 $D$ 都 **必须** 是 `XMM` 寄存器。

如下是浮点数运算的示例

```c
double funct(double a, float x, double b, int i) {
    return a * x - b / i;
}
```

GCC 生成的汇编代码为

```c
0000000000000000 <funct>:
   0:   f3 0f 5a c9             cvtss2sd %xmm1,%xmm1  // float --> double
   4:   f2 0f 59 c8             mulsd  %xmm0,%xmm1	  // a * x --> %xmm1
   8:   66 0f ef c0             pxor   %xmm0,%xmm0	  // xmm0置位0
   c:   f2 0f 2a c7             cvtsi2sd %edi,%xmm0   // int --> double
  10:   f2 0f 5e d0             divsd  %xmm0,%xmm2	  // b / i --> %xmm2
  14:   f2 0f 5c ca             subsd  %xmm2,%xmm1	  // a * x - b / i  --> %xmm1
  18:   66 0f 28 c1             movapd %xmm1,%xmm0	  // %xmm1 --> %xmm0 设置返回值
  1c:   c3                      ret
```

## 浮点数比较

`AVX2` 提供了两条用于比较浮点数值的指令

![[Pasted image 20241006233535.png]]

> [!tip]
> 
> **类似于 CMP 指令**，都比较操作数 $S_{1}$ 和 $S_{2}$，并设置条件码指示它们相对值。
> 
> **S2 必须在 XMM 寄存器**，$S_1$ 可以在 XMM 寄存器, 也可以在内存中
> 

浮点比较指令会设置三个条件码：**ZF 零标志位**，**CF 进位标志位** 和 **PF 奇偶标志位**

> [!tip] 
> 对于整数操作，当最近一次算术或逻辑运算产生的值的最低位字节是偶校验的（这个字节中有偶数个 `1`，那么才会设置该标志位
> 

