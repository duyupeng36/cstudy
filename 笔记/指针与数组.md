# 指针和数组

在 C 语言中，指针不仅仅可以指向变量，还能 **指向数组元素**

```c
int a[10], *p;
p = &a[0]; // p 指向数组的第 0 个元素
```

上述代码执行后的结果可以由下图表示

![[Pasted image 20240927212737.png]]

在可以通过 `p` 访问 `a[0]`。例如，可以通过下列写法把值 `5` 存入 `a[0]` 中

```c
*p = 5;
```

![[Pasted image 20240927212823.png]]

> [!hint] 
> 
> 指针只是指向数组的元素并没有任何特别的作用，但是 C 语言中 **指针支持算算术运算**，通过指针的算术运算可以访问数组中的任意元素了
> 

## 指针算术运算

### 指针加整数

如果指针 `p` 指向了`type` 类型长度为 $10$ 的数组 `a` 中的某个元素。指针 `p` 加上整数 `j` 产生指向特定元素的指针，这个特定元素是 `p` 原先指向的元素后的 `j` 个位置

```c
p = &a[2];  // p 指向 a 的第 2 个元素

type *q;
q = p + 3; // q 指向 a 的第 5 个元素

p += 6; // p 指向 a 的第 8 给元素
```

下图显示了上述代码的执行结果


![[Pasted image 20240927213918.png]]

> [!tip]
> 
> 如果指针变量 `pa` 指向数组 `a` 中的某个元素，无论数组 `a` 中的元素类型或者数组长度是什么，**指针加 1** 就意味着，`pa + 1` 指向 `pa` 所指对象的下一个对象
> 
> 相应的，`pa + i` 指向 `pa` 所指对象之后的第 `i` 个对象
> 

> [!warning] 
> 
> 如果指针 `p` 没有指向一个数组，对其进行算术运算通常是无意义的
> 

### 指针减整数

如果指针 `p` 指向了`type` 类型长度为 $10$ 的数组 `a` 中的某个元素。指针 `p` 减去整数 `j` 产生指向 `p` 原先指向的元素前的 `j` 个位置

```c
p = &a[8]; // p 指向 a 中的第 8 个元素

q = p - 3; // p 指向 a 中的第 5 个元素

p -= 6; // p 指向 a 中第 2 个元素
```

下图显示了上述代码的执行结果

![[Pasted image 20240927215523.png]]

### 两个指针相减

当两个指针相减时，结果为指针之间的距离（用数组元素的个数来度量）

> [!tip] 
> 
> 两个指针的类型必须相同
> 

因此，如果 `p` 指向 `a[i]` 且 `q` 指向 `a[j]` ，那么 `p - q` 就等于 `i - j`

```c
p = &a[5];
q = &a[1];

i = p - q;  // i = 4
j = q - p;  // j = -4
```

![[Pasted image 20240927215838.png]]

### 指针比较

**当两个指针指向同一个数组时**，可以使用 [[基本概念#关系运算符]] 和 [[基本概念#判等运算符]] 进行指针比较。比较的结果依赖于数组中两个元素的相对位置

例如，在下面的赋值后 `p <= q` 的值是 `false`，而 `p >= q` 的值是 `true`

```c
p = &a[5];
q = &a[1];
```

下面的例程中就涉及了指针的算术运算和比较运算

```c
int main() {  
  
    int arr[10] = {1,2,3,4,5,6,7,8,9,10};  
  
    int sum = 0;  
  
    for(int *p = &arr[0]; p < &arr[10]; p++) {  
        sum += *p;  
    }  
  
    printf("sum = %d\n", sum);  
  
    return 0;  
}
```

> [!tip]
> 
> `&arr[10]` 只是获取 `arr[10]` 的地址，并不会发生解引用，因此不会造成未定义行为
> 
> 还需要注意一点，控制表达式不能是 `p <= &arr[10]`，因为 `arr[10]` 不在数组的内存空间中
> 

### `*` 运算符和 `++` 运算符的组合

C 程序员经常在处理数组元素的语句中组合 `*` 运算符和 `++` 运算符

把值存入一个数组元素中，然后前进到下一个元素。利用 **数组下标** 可以这样写

```c
a[i++] = j;
```

利用 **指针+偏移量** 可以这样写

```c
*pa++ = j;
```

因为 **后缀 `++` 的优先级高于 `*`**，所以编译器把上述语句看作

```c
*(pa++) = j;
```

> [!tip]
> 
> **`pa++` 的值是`pa`**。（因为使用后缀`++`，所以 `pa` 只有在表达式计算出来后才可以自增。）因此，`*(pa++)` 的值将是 `*p`，即 `p` 当前指向的对象


`*` 和 `++` 运算符的所有组合形式如下表

| 表达式             | 描述                        |
| :-------------- | ------------------------- |
| `*p++` `*(p++)` | 自增前表达式的值是 `*p`，以后再自增 `p`  |
| `(*p)++`        | 自增前表达式的值是 `*p`，以后再自增 `*p` |
| `*++p` `*(++p)` | 先自增`p`，自增后表达式的值是 `*p`     |
| `++*p` `++(*p)` | 先自增`*p`，自增后表达式的值是 `*p`    |

```c
int main() {

    int arr[10] = {1,2,3,4,5,6,7,8,9,10};

    int sum = 0;

    int *p = &arr[0];

    while (p < &arr[10]) {
        sum += *p++;
    }

    printf("sum = %d\n", sum);

    return 0;
}
```

## 指针与数组的关系

在 C 语言中，指针和数组之间的关系十分密切。在 [[数组]] 中我们知道 `a[i]` 表示数组的第 `i` 个元素。如果指针 `pa` 指向 `a[0]`，则 `pa + i` 指向 `a[i]`

> [!important] 下表和指针运算之间具有密切的对应关系
> 

这里，我们有一个比较显然的结论：**数组类型的变量或者表达式的值是该数组第 $0$ 个元素的地址**

```c
#include <math.h>
#include <stdio.h>


int main() {

    int arr[10];

    printf("   arr: %p\n", arr);     //    arr: 0x7ffe6a90cc10
    printf("arr[0]: %p\n", &arr[0]); // arr[0]: 0x7ffe6a90cc10
    
    return 0;
}
```

> [!tip] 数组名代表的就是该数组第 $0$ 个元素的地址
> 

由于数组名代表数组第 $0$ 个元素的地址，那么赋值语句 `pa = &a[0]` 可以简单的写成下列形式

```c
pa = a; // a 的类型会进行赋值隐式类型转换，从而转换为 type * 类型
```

> [!tip] 
> 
> 既然数组名代表了第 $0$ 个元素的地址，那么 `a[i]` 等价于 `*(a + i)`。程序中，这两种形式是等价的，并且编译器会将 `a[i]` 转换为 `*(a + i)` 的形式进行求值
> 

对 `a[i]` 和 `*(a + i)` 分别进行取地址运算，可以得到 `&a[i]` 与 `a + i` 是等价的

> [!tip]
> 如果指针变量 `pa` 指向数组元素 `a[0]`，那么 `a[i]` `*(a + i)` 和  `pa[i]` `*(pa + i)` 这四种表达式都是等价的 
> 

> [!summary] 
> 
> 通过数组和下标实现的表达式可以等价的通过指针和偏移量实现
>

我们必须要牢记：**数组名和指针是完全不同**

> [!attention]
> 
> + 指针是一个变量，语句 `pa = a` 和 `pa++` 是合法的 
> 
> + 数组名不是变量(而是一个指向数组第$0$个元素的 **指针常量**)，语句 `a = pa` 和 `a++` 都是非法语句
> 

```c
int main() {

    int arr[10] = {1,2,3,4,5,6,7,8,9,10};

    int sum = 0;

    // int *p = &arr[0];
    int *p = arr;

    while (p < arr + 10) {
        sum += *p++;
    }

    printf("sum = %d\n", sum);

    return 0;
}
```

### 数组实参

**数组名作为实参传递给函数时，实际上传递的是该数组第 $0$ 个元素的地址**。在被调用函数中，该参数是一个局部变量，因此，数组名参数必须是一个指针，也就是一个存储地址值的变量

利用该特性，可以编写一个 `sum_array` 函数

```c
#include <math.h>
#include <stdio.h>


int sum_array(int *arr, int size)
{
    int sum = 0;
    for(;arr < arr + size; arr++) {
        sum += *arr;
    }
    return sum;
}

int main() {

    int arr[10] = {1,2,3,4,5,6,7,8,9,10};
    int sum = sum_array(arr, 10);
    printf("sum = %d\n", sum);
    return 0;
}
```

因为 `arr` 是一个指针，所以对其进行自增是合法的

> [!tip] 数组形式参数
> 
> 在函数定义中，形式参数
> 
> ```c
> int sum_array(int arr[], int size);
> ```
> 
> 和
> 
> ```c
> int sum_array(int *arr, int szie);
> ```
> 
> 是完全等价
> 

## 指针与多维数组

二维数组是特殊的一维数组，那么 **二维数组名** 表示的就是二维数组中 **第 $0$ 个元素的指针**，即 **指向数组的指针**

数组需要两个基本属性：**存储元素的类型** 和 **元素的个数**。因此，下面的声明是一个指向存有 `size` 个 `int` 类型元素的数组的指针

```c
int (*pa)[size]; // 指向数组的指针，该数组存储 size 个 int 类型的元素
```

```c
#include <stdio.h>

int main() 
{
	int m[5][9] = {
		{1, 1, 1, 1, 1, 0, 1, 1, 1}, 
		{0, 1, 0, 1, 0, 1, 0, 1, 0}, 
		{0, 1, 0, 1, 1, 0, 0, 1, 0},
		{1, 1, 0, 1, 0, 0, 0, 1, 0}, 
		{1, 1, 0, 1, 0, 0, 1, 1, 1}
	};
	/* 
	m 的值是指向 m[0] 的指针。而 m[0] 是一个元素类型为 int 长度为 9 的数组

	从而，指向 m[0] 的指针类型为 int (*)[9]
	*/
	int (*pm)[9] = m;
	printf("m = %p\n", m);
	printf("&m[0] = %p", &m[0]);
}
```
