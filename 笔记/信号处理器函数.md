# 信号处理器函数

## 设计信号处理器函数

一般而言，将信号处理器函数设计得 **越简单越好**。这会 **降低引发竞争条件的风险**

下面是针对信号处理器函数的两种常见设计

> [!tip] 信号处理器函数 **设置全局性标志变量并退出**
> 
> 主程序 **周期性检查** 该全局标志，一旦 **置位** 随即采取相应动作
> 
> 主程序若因监控一个或多个文件描述符的 IO 状态而无法进行这种周期性检查时，则可令信号处理器函数向一专用管道写入一个字节的数据，同时将该管道的读取端置于主程序所监控的文件描述符范围之内
> 

> [!tip] 信号处理器函数 **执行某种类型的清理动作**，接着**终止进程** 或者 **使用非本地跳转**
> 
> 使用非本地跳转会将栈解开并将控制返回到主程序中的预定位置
> 

### 再论信号的非队列化处理

在 [[信号集]] 中知晓，在 **执行** 某个信号的信号处理器函数时会 **阻塞** 同类信号的传递

> [!tip] 
> 
> 如果需要触发执行信号处理函数的信号不被临时阻塞，就需要使用 `sigaction()` 的 `SA_NODEFER` 标志
> 

如果在执行处理器函数时再次产生同类信号，那么会将该信号标记为等待状态并在处理器函数返回之后再行传递。同时指出，**不会对信号进行排队处理**

> [!tip] 
> 
> 在处理器函数执行期间，如果 **多次产生同类信号**，那么仍然会将其 **标记为等待状态**，但 **稍后 _只会传递一次_**
> 

信号的这种丢失方式无疑将影响对信号处理器函数的设计。首先，**无法对信号的产生次数进行可靠计数**。其次，**设计信号处理器函数时需要考虑 _同类信号的多次传递_**

### 可重入函数和异步信号安全函数

**在信号处理器函数中，并非所有系统调用以及库函数均可予以安全调用**。要了解来龙去脉，就需要解释一下以下两种概念：**可重入**（re-entrant）函数和 **异步信号安全**（async-signal-safe）函数

#### 可重入和非可重入函数

在解释可重入函数之前，我们先来了解 **多线程程序**

> [!tip] 
> 
> 典型 UNIX 程序都 **具有一条执行线程**，贯穿程序始终，CPU 围绕 **单条执行逻辑** 来处理指令
> 
> 对于 **多线程程序** 而言，同一进程却 **存在多条独立、并发的执行逻辑流**。后续在 [[多线程]] 编程中介绍
> 
> 
> 

多执行线程的概念与使用了信号处理器函数的程序也有关联。因为 **信号处理器函数** 可能会 **在任一时点异步中断程序的执行**，从而在同一个进程中实际形成了两条独立的执行逻辑流，即 _主程序_ 和 _信号处理器函数_

> [!attention] 
> 
> 虽然主程序和信号处理器函数是两条独立执行的逻辑流，但是 **不是并发的**
> 

如果同一个进程的多条线程可以同时 **安全** 地调用某一函数，那么该函数就是可重入的。此处，“安全”意味着，**无论其他线程调用该函数的执行状态如何，函数均可产生预期结果**。

> [!tip] 可重入函数的定义
> 
> SUSv3 对可重入函数的定义是：函数由两条或多条线程调用时，即便是 **交叉执行**，其 **效果** 也与各线程以 **未定义顺序依次调用时一致**。
> 

根据可重入函数的定义，更新全局变量或静态数据结构的函数可能是不可重入的。**只用到本地变量的函数肯定是可重入的**。

> [!tip] **可重入函数** 的特征：**只更新本地自动变量**
> 
> 涉及更新共享资源的函数也不是可重入的。例如，在 [[数据结构：线性表#插入元素]] 中设计的两个函数
> 

如果对函数是非可重入的，函数的两个调用由两条执行线程发起，同时试图更新同一全局变量或数据类型，那么二者很可能会相互干扰并产生不正确的结果。

> [!example] 
> 
> 假设 **某个线程正在执行为一个链表数据结构插入** 一个新的链表项，例如执行 [[数据结构：线性表#插入元素]] 中设计的函数。而 **另一线程也正试图更新同一链表**
> 
> 由于为链表添加新项涉及对多枚指针的更新，一旦另一线程中断这些步骤并修改了相同的指针，结果就会产生混乱
> 

#### 异步信号安全函数

异步信号安全的函数是指当 **从信号处理器函数调用** 时，可以 **保证其实现是安全的**

> [!tip]  异步信号安全函数：**可重入** 或信号处理器函数 **无法中断该函数的调用**
> 
> 如果某一函数是可重入的，又或者信号处理器函数无法将其中断时，就称该函数是异步信号安全的
> 

下表列出了 POSIX.1-1990 SUSv2 和 SUSv3 标准要求实现为异步信号安全的函数

![[Pasted image 20241109173246.png]]

> [!tip] 
> 
> 上表中，函数名后面的 `v2` 表示 SUSv2 标准加入，`v3` 表示 SUSv3 标准加入。其中没有指出的是由 POSIX1.-1990 规定的异步信号安全函数
> 
> 所有符合标准的 UNIX 实现都 **必须保证至少表中这些函数是异步信号安全的**
> 

SUSv4 标准做出来如下修改

> [!attention] 移除函数
> + `fpathconf()`
> + `pathconf()`
> + `sysconf()`

> [!attention] 添加函数
> 
> + `execl()` `execv()`
> + `faccessat()` `fchmodat()` `fchownat()` `fexecve()` `fstatat()` `futimens()`
> + `linkat()` `mkdirat()` `mkfifoat()` `mknod()` `mknodat()`
> + `openat()` 
> + `readlinkat()` `renameat()` 
> + `symlinkat()` `unlinkat()` `utimensat()` `utimes()`
> 

除了上述列出的函数，其他函数对于信号而言都是不安全的

> [!summary] 
> 
> 仅当 **信号处理器函数 _中断_ 了不安全函数的执行**，且 **处理器函数自身也 _调用_ 了这个不安全函数** 时，该函数才是不安全的
> 

换言之，编写信号处理器函数有如下两种选择

+ 确保信号处理器函数代码**本身是可重入**的，且 **只调用异步信号安全的函数**
+ 当 **主程序执行不安全函数** 或是去操作 **信号处理器函数也可能更新的全局数据结构** 时，**阻塞信号的传递**

> [!attention] 
> 
> 想要确保主程序对不安全信号调用不被信号处理器函数中断是不可能的。因此，通常的选择就是 **信号处理函数中绝对不调用非异步信号安全的函数**
> 

#### 信号处理函数内部对 errno 的使用

由于 [[#异步信号安全函数]] 中列出的异步信号安全函数可能会修改 `errno` 的值，因此在信号处理器函数中调用异步信号安全函数也会导致信号处理函数不可重入

> [!tip] 
> 
> 由于异步信号处理函数可能会更新 `errno`，从而在信号处理函数中调用这些函数时，会导致信号处理函数时不可重入的
> 

> [!attention] 上述问题的解决方案
> 
> + 进入信号处理器函数立即保存 `errno` 的值
> + 退出信号处理器函数恢复 `errno` 的值
> 

```c
void handler(int sig) {
	// 保存 errno
	int savedErrno;
	savedErrno = errno;
	
	/*
	此处调用异步信号安全函数
	*/
	
	// 恢复 errno
	errno = savedErrno;
}
```

### 全局变量和 sig_atomic_t 数据类型

尽管存在可重入问题，有时仍需要在主程序和信号处理器函数之间共享全局变量。 **信号处理器函数可能会随时修改全局变量**。只要主程序能够正确处理这种可能性，共享全局变量就是安全的。

> [!tip] 信号处理程序和主程序共享全局变量方案
> 
> + 信号处理器函数只做一件事情，设置 **全局标志**
> + 主程序则会周期性地检查这一标志，并采取响应的动作来响应信号传递，同时清除标志
> 
> 这个全局标志应该声明为 `volatile` 的，从而防止编译器将其优化到寄存器中
> 

对全局变量的读写可能不止一条机器指令，而信号处理器函数就可能会在这些指令序列之间将主程序中断，即，**变量的访问是非原子性** 的

> [!important] 
> 
> 解决变量访问非原子性的问题，C 标准和 SUSv3 定义了一个整数类型 `sig_atomic_t`，意在 **保证变量读写操作的原子性**
> 

例如在 [[信号集#等待信号集]] 中的列出使用了该类型

```c
static volatile sig_atomic_t gotSigint = 0;
```

## 终止信号处理器函数

目前，我们所看到的信号处理器函数都是以返回主程序而终结。有时候这种简单的返回并不能满足需求，甚至没什么用处

> [!tip] 从信号处理器函数中终止的其他一些方法
> 
> + 调用 `_exit()` 终止进程。信号处理器函数可以事先完成一下清理工作
> + 使用 `kill()` 发送信号来杀掉进程
> + 从信号处理器函数中执行非本地跳转
> + 使用 `abort()` 函数终止进程，并产生核心转储
> 

这里关注 **执行非本地跳转** 和 **调用 `abort()` 函数**

### 在信号处理器函数中执行非本地跳转

在 [[C 语言：错误处理#非局部跳转]] 中介绍了使用 `setjmp()` 和 `longjmp()` 来执行 **非本地跳转**，以便 **从一个函数跳转至该函数的某个调用者**

在信号处理器函数中也可以使用这种技术。这也是因硬件异常（例如内存访问错误）而导致信号传递之后的一条恢复途径，**允许将信号捕获并把控制返回到程序中某个特定位置**。

> [!example] 
> 
> 例如，一旦收到 `SIGINT` 信号（通常由键入 `Ctrl-C `产生），shell 执行一个非本地跳转，将控制返回到主输入循环中（以便读取下一条命令）。
> 

然而，这里我们并不能使用 `setjmp()` 和 `longjmp()`。因为信号处理函数正常返回会将自动加入信号掩码的信号移除。然而使用 `longjmp()` 离开信号处理器函数时，是否自动将信号从信号掩码中移除取决于具体实现

> [!attention] 在 System V 一脉中，`longjmp()` 不会将信号掩码恢复，亦即 **在离开信号处理器函数时不会对遭阻塞的信号解除阻塞**
> 
> Linux 遵循 System V 的这一特性
> 

> [!attention] 在 BSD 一脉中，`setjmp()` 会保存信号掩码，并在 `longjmp()` 时恢复
> 
> 在 System V 系统中也存在类似的两个函数 `_setjmp()` 和 `_longjmp()`
> 

换言之，使用 `longjmp()` 来退出信号处理器函数将有损于程序的可移植性

鉴于两大 UNIX 流派之间的差异，POSIX.1-1990 选择不对 `setjmp()` 和 `longjmp()` 的信号掩码处理进行规范，而是定义了一对新函数：`sigsetjmp()` 和 `siglongjmp()`，针对执行非本地跳转时的信号掩码进行显式控制

```c
#include <setjmp.h>

int sigsetjmp(sigjmp_t env, int savesigs);
/* 初始化时返回 0；之后返回 siglongjmp() 指定的值  */

void siglongjmp(sigjmp_t env, int val);
```

> [!tip] 参数 `savesigs` : 指定是否保存进程信号掩码
> + `savesigs` 指定为 $0$ 时，不会保存信号掩码
> + `savesigs` 指定为非 $0$ 时，会保存信号掩码 

函数 `longjmp()` 和 `siglongjmp()` 都不是异步信号安全的函数。

> [!tip] 
> 
> 如果信号处理器函数中断了正在更新数据结构的主程序，那么执行非本地跳转退出处理器函数后，这种不完整的更新动作很可能会将数据结构置于不一致状态。
> 

**规避上述问题的一种技术** 是在程序对敏感数据进行更新时，借助于 `sigprocmask()` **临时将信号阻塞起来**

### 执行 abort() 函数

函数 `abort()` 终止其调用进程，并生成核心转储

```c
#include <stdlib.h>

void abort(void);
```

函数 `abort()` 通过产生 `SIGABRT` 信号来终止调用进程。对 `SIGABRT` 的默认动作是产  
核心转储文件并终止进程。调试器可以利用核心转储文件来检测调用 `abort()` 时的程序状态

`SUSv3` 要求，**无论 _阻塞_ 或者 _忽略_ `SIGABRT` 信号，`abort()`调用均不受影响**。同时规定，除非进程捕获 `SIGABRT` 信号后信号处理器函数尚未返回，否则 `abort()` 必须终止进程

## 备选栈中处理信号

在调用信号处理器函数时，内核通常会在进程栈中为其创建一帧。不过，如果进程对栈的扩展突破了对栈大小的限制时，这种做法就不大可行了

> [!tip] 
> 
> 当进程对栈的扩展突破上限是，内核会向进程发送 `SIGSEGV` 信号。由于栈空间已耗尽，内核无法安装信号处理器程序并创建栈帧
> 
> 从而导致处理器函数得不到调用，进程被终止
> 

如果希望在这种情况下确保对 `SIGSEGV` 信号处理器函数的调用，就需要做如下工作

> [!tip] 处理 `SIGSEGV` 信号的步骤，其他信号也可以这样做
> 
> + 分配一块被称为 **备选信号栈** 的内存区域，作为信号处理器函数的栈帧
> + 调用 `sigaltstack()`，告之内核该备选信号栈的存在
> + 在创建信号处理器函数时指定 `SA_ONSTACK` 标志，亦即通知内核在备选栈上为处理器函数创建栈帧
> 

利用 **系统调用 `sigaltstack()`**，既可以**创建一个备选信号栈**，也可以将已创建 **获取备选信号栈的相关信息**

```c
#include <signal.h>

int sigaltstack(const stack_t *sigstack, stack_t *old_sigstack);
/* 成功返回0；错误返回-1*/
```

> [!tip] 参数 `sigstack` : 指向 `stack_t` 结构的指针，代表新的备选信号栈
> 
> `stack_t` 类型代表了备选信号栈的位置及属性，其定义如下
> 
> ```c
> typedef struct
> {
> 	void *ss_sp;  // 备选栈的开始地址
> 	int ss_flags; // SS_ONSTACK, SS_DISABLE
> 	size_t ss_size; // 备选栈的尺寸
> } stack_t;
> ```
> 

下表对每个字段进行总结

| 字段         | 描述                                                   |
| :--------- | :--------------------------------------------------- |
| `ss_sp`    | 备选栈开始的位置. 自动对齐到合适的地址边界                               |
| `ss_size`  | 备选栈的大小. `SIGTKSZ` 备选栈大小的典型值；`MINSSIGSTKSZ` 最小值       |
| `ss_flags` | 获取备选栈时被设置. `SS_ONSTACK`: 存在备选栈 ; `SS_DISABLE`:不存在备选栈 |

> [!tldr] 补充说明
> 
> 常量 `SIGSTKSZ` 和 `MINSSIGSTKSZ` 有 SUSv3 规定。在 Linux 上的值分别为 $8192$ 和 $2048$
> 
> **内核不会重新划分备选栈的大小**。如果栈溢出了，就会产生混乱。这通常不是一个问题。
> 
> 因为一般情况下会利用备选栈来处理标准栈溢出的特殊情况，常常只在这个栈上分配为数不多的几帧。`SIGSEGV` 处理器函数的工作不是在执行清理动作后终止进程，就是使用非本地跳转解开标准栈
> 

> [!tip] 参数 `old_sigstack`: 指向 `stack_t` 结构的指针，代表上一个备选信号栈
> 

将参数 `sigstack` 设为 `NULL` 并且 `old_sigstack` 不会 `NULL` 时，可以获取现有备选信号栈，并且不用将其改变

## SA_SIGINFO 标志

如果在使用 `sigaction()` 创建处理器函数时设置了 `SA_SIGINFO` 标志，那么在收到信号时处理器函数可以 **获取该信号的一些附加信息**。为获取这一信息，需要将处理器函数声明如下

```c
void handler(int sig, siginfo_t *siginfo, void *ucontext);
```

> [!tip] 参数 `sig`：触发信号处理器调用的信号
> 
> 参考 [[信号基本概念#信号类型和默认行为]]
> 

> [!tip] 参数 `siginfo`：指向 `siginfo_t` 结构的指针
> 
> `siginfo_t` 代表了一个 **信号附加信息** 的结构。定义在头文件 `<siginfo_t.h>` 中
> 
```c
typedef struct {
    int si_signo;  /* 信号编号: 触发信号处理器函数的信号编号，例如 SIGSEGV */
    int si_errno;  /* 错误码: 与信号相关的错误 */
    int si_code;   /* 信号来源: 更详细的信号的原因 */
    int __pad0;    /* 填充字段，用于对齐 */

    union {
        int _pad[((128 / sizeof(int)) - 4)]; /* 填充数组 */
        
        struct {
            __pid_t si_pid;  // 发送信号进程的 PID
            __uid_t si_uid;  // 发送信号进程的 UID
        } _kill; /* 信号由 kill() 或其他系统调用发送的 */

        struct {
            int si_tid;          // 定时器 ID
            int si_overrun;      // 计数器，定时器到期次数
            __sigval_t si_sigval; // 信号值
        } _timer; /* POSIX 定时器到期 */
        
        struct {
            __pid_t si_pid;  // 发送信号进程的 PID
            __uid_t si_uid;  // 发送信号进程的 UID 
            __sigval_t si_sigval; // 实时信号的附加数据
        } _rt; /* 发送实时信号 */
        
        struct {
            __pid_t si_pid;   // 子进程的 PID
            __uid_t si_uid;   // 子进程的 UID
            int si_status;    // 子进程的退出状态或者停止信号
            __clock_t si_utime; // 子进程的用户 CPU 时间
            __clock_t si_stime; // 子进程的内核 CPU 时间
        } _sigchld; /* 子进程状态改变 */
        
        struct {
            void *si_addr;  // 发送错误的内存地址
            short int si_addr_lsb; // 导致错误的内存地址的最低有效位数
            union {
                struct {
                    void *_lower;
                    void *_upper;
                } _addr_bnd;  // 边界地址
                __uint32_t _pkey; // 内存访问保护键
            } _bounds; // 内存边界信息或保护键
        } _sigfault; /* 段错误或内存相关信号 */
        
        struct {
            long int si_band; // 事件发生的描述符带宽
            int si_fd; // 触发事件的文件描述符
        } _sigpoll; /* IO 相关信号 SIGPOLL */
        
        struct {
            void *_call_addr; // 引发错误的系统调用地址 
            int _syscall;     // 系统调用编号
            unsigned int _arch;// 系统调用的架构
        } _sigsys; /* 系统调用发送错误 SIGSYS */
    } _sifields;
} siginfo_t;
```

关于 `si_code` 字段的可以设置的值如下表

| 信号            | `si_code` 的值    | 信号来源                                         |
| ------------- | --------------- | -------------------------------------------- |
| **任意 (所有)**   | `SI_ASYNCIO`    | 异步 I/O (AIO) 操作已经完成                          |
|               | `SI_KERNEL`     | 从内核发送 (例如，来自终端驱动程序的信号)                       |
|               | `SI_MESGQ`      | 消息到达 POSIX 消息队列 (自 Linux 2.6.6)              |
|               | `SI_QUEUE`      | 使用 sigqueue() 从用户进程发送的实时信号                   |
|               | `SI_SIGIO`      | SIGIO 信号 (仅 Linux 2.2 支持)                    |
|               | `SI_TIMER`      | POSIX (实时) 定时器到期                             |
|               | `SI_TKILL`      | 调用 tkill() 或 tgkill() 的用户进程 (自 Linux 2.4.19) |
|               | `SI_USER`       | 调用 kill() 或 raise() 的用户进程                    |
|               |                 |                                              |
| **SIGBUS**    | `BUS_ADRALN`    | 无效的地址对齐                                      |
|               | `BUS_ADRERR`    | 不存在的物理地址                                     |
|               | `BUS_MCEERR_A0` | 硬件内存错误，动作为可选 (自 Linux 2.6.32)                |
|               | `BUS_MCEERR_AR` | 硬件内存错误，动作为必需 (自 Linux 2.6.32)                |
|               | `BUS_OBJERR`    | 对象特有的硬件错误                                    |
|               |                 |                                              |
| **SIGCHLD**   | `CLD_CONTINUED` | 因 SIGCONT 信号，子进程得以继续执行 (自 Linux 2.6.9)       |
|               | `CLD_DUMPED`    | 子进程异常终止，并产生核心转储                              |
|               | `CLD_EXITED`    | 子进程退出                                        |
|               | `CLD_KILLED`    | 子进程异常终止，且不产生核心转储                             |
|               | `CLD_STOPPED`   | 子进程停止                                        |
|               | `CLD_TRAPPED`   | 受到跟踪的子进程停止                                   |
|               |                 |                                              |
| **SIGFPE**    | `FPE_FLTDIV`    | 浮点除 0                                        |
|               | `FPE_FLTINV`    | 无效的浮点操作                                      |
|               | `FPE_FLTOVF`    | 浮点溢出                                         |
|               | `FPE_FLTRES`    | 浮点结果不精确                                      |
|               | `FPE_FLTUND`    | 浮点下溢                                         |
|               | `FPE_INTDIV`    | 整型除 0                                        |
|               | `FPE_INTOVF`    | 整型溢出                                         |
|               | `FPE_SUB`       | 下标超出范围                                       |
|               |                 |                                              |
| **SIGILL**    | `ILL_BADSTK`    | 内部栈错误                                        |
|               | `ILL_COPROC`    | 协处理器错误                                       |
|               | `ILL_ILLADR`    | 非法地址模式                                       |
|               | `ILL_ILLOPC`    | 非法操作码                                        |
|               | `ILL_ILLOPN`    | 非法操作数                                        |
|               | `ILL_ILLTRP`    | 非法陷入                                         |
|               | `ILL_PRVOPC`    | 特权级操作码                                       |
|               | `ILL_PRVREG`    | 特权级寄存器                                       |
|               |                 |                                              |
| SIGPOLL/SIGIO | `POLL_ERR`      | I/O 错误                                       |
|               | `POLL_HUP`      | 设备断开                                         |
|               | `POLL_IN`       | 输入数据有效                                       |
|               | `POLL_MSG`      | 输入消息有效                                       |
|               | `POLL_OUT`      | 输出缓冲区有效                                      |
|               | `POLL_PRI`      | 高优先级输入有效                                     |
|               |                 |                                              |
| **SIGSEGV**   | `SEGV_ACCERR`   | 映射对象的无效权限                                    |
|               | `SEGV_MAPERR`   | 未映射为对象的地址                                    |
|               |                 |                                              |
| **SIGTRAP**   | `TRAP_BRANCH`   | 进程分支陷入                                       |
|               | `TRAP_BRKPT`    | 进程断点                                         |
|               | `TRAP_HWBKPT`   | 硬件断点 / 监测点                                   |
|               | `TRAP_TRACE`    | 进程跟踪陷入                                       |

> [!tip] 参数 `ucontext`：`ucontext_t` 类型的指针
> 
> SUSv3 并未规定该参数的任何细节，所以将其定义为 `void` 类型指针
> 
> 该结构提供了所谓的 **用户上下文信息**，用于描述 **调用信号处理器函数前的进程状态**
> 
> 包括上一个进程 **信号掩码** 以及 **寄存器的保存值**，例如 **程序计数器**(`cp`)和 **栈指针寄存器**(`sp`)。信号处理器函数很少用到此类信息，所以此处也略而不论
> 

## 系统调用的中断和重启

首先，为某信号创建处理器函数。然后，**发起一个阻塞的系统调用**，例如，从终端设备调用的 `read()` 就会阻塞到有数据输入为止。如果 **系统调用遭到阻塞** 时，**接收到了捕获信号**，随即引发对处理器函数的调用，从而 **导致阻塞系统调用被中断**

> [!important] 信号处理器返回后又会发生什么？默认情况下，系统调用失败，并将 `errno` 置为 `EINTR`
> 
> 在 [[定时器与休眠]] 将描述一种该特性的用法。即，使用定时器产生 `SIGALRM` 信号，设置像 `read()` 之类阻塞系统调用的超时
> 

不过，更为常见的情况是 **希望遭到中断的系统调用得以继续运行**。为此，可在系统调用被信号处理器中断的事件中，利用如下代码来 **手动重启系统调用**

```c
while((cnt = read(fd, buf, BUF_SIZE)) == -1 && errno == EINTR)
	continue;

if(cnt == -1) // 系统调用失败，但不是因为 EINTR
{
	// 错误处理
}
```

如果需要频繁使用上述代码，那么定义成如下宏会很方便

```c
#define NO_EINTR(stmt) while((stmt) == -1 && errno == EINTR);
```

使用宏，可以将早先对 `read()` 的调用改写如下：

```c
NO_EINTR(cnt = read(fd, buf, BUF_SIZE));

if(cnt == -1) // 系统调用失败，但不是因为 EINTR
{
	// 错误处理
}
```

> [!tip] 如果需要重启被信号中断的阻塞系统调用，那么每个阻塞的系统调用都要添加上述代码
> 
> 一种更好的方式就是使用指定了 `SA_RESTART` 标志的 `sigaction()` 创建信号处理器函数。这会 **让内核代表进程自动重启系统调用**，还无需处理系统调用可能返回的 `EINTR` 错误
> 

标志 `SA_RESTART` 是 **针对每个信号** 的设置。换言之，允许某些信号的处理器函数中断阻塞的系统调用，而其他系统调用则可以自动重启

### 可重启的系统调用

并非所有的系统调用都可以通过指定 `SA_RESTART` 来达到自动重启的目的

在 Linux 中，如果采用 `SA_RESTART` 标志来创建系统处理器函数，则如下阻塞的系统调用，以及构建于其上的库函数在被中断时是可以自动重启的

> [!tip] 监控子进程的系统调用
> 
> 在 [[监控子进程]] 中介绍的下列系统调用
> + `wait()` 和 `waitpid()`
> + `waitid()` 
> + `wait3()` 和 `wait4()` 
> 

> [!tip] 访问慢速设备的 IO 系统调用
> 
> 在 [[文件 IO：通用 IO 模型]] 和 [[深入文件 IO]] 中介绍的系统调用
> 
> + `read()` 和 `write()`
> + `readv()` 和 `writev()`
> + `iocntl()`
> 
> 如果在收到信号时已经传递了部分数据，那么还是会中断 IO 系统调用，但会返回成功状态：一个整型值，表示已成功传递数据的字节数
> 

> [!tip] 访问套接字的系统调用
> 
> 在 [[SOCKET 概览]] 中介绍的系统调用
> 
> + `accept()` 和 `accept4()`
> + `connect()`
> + `send()` `sendmsg()` `sendto()`
> + `recv()` `recvfrom()` `recvmsg()`
> 
> 在 Linux 中，如果使用 `setsockopt()` 来设置超时，这些系统调用就不会自动重启
> 

> [!tip] POSXI 消息队列的 IO 系统调用
> 
> 在 [[POSIX 消息队列]] 中介绍
> 
> + `mq_receive()` 和 `mq_timedreceive()`
> + `mq_send()` 和 `mq_timedsend()`
> 

> [!tip] 设置文件锁的系统调用
> 
> 在 [[文件锁]] 中介绍
> + `flock()` 
> + `fcntl()`
> + `lockf()`
> 

> [!tip] 减少 POSIX 信号量的系统调用
> 
> 在 [[POSIX 信号量]] 中介绍
> 
> + `sem_wait()`
> + `sem_timedwait()`
> 

> [!tip] 同步 POSIX 线程的函数
> 
> 在 [[互斥量]] 中介绍
> 
> + `pthread_mutex_lock()` 和 `pthread_mutex_timedlock()`
> + `pthread_mutex_trylock()`
> + `pthread_cond_wait()` 和  `pthread_cond_timedwait()`
> 

### 修改 SA_RESTART 标志

函数 `siginterrupt()` 用于改变信号的 `SA_RESTART` 设置

```c
#include <signal.h>

int siginterrupt(int sig, int flag);
/* 成功返回 0；失败返回 -1*/
```

> [!tip] 参数 `sig`：信号编号

> [!tip] 参数 `flag`：控制 `siginterrupt()` 的行为
> 
> `flag` 为 `true`，则 `sig` 的信号处理器函数则会中断系统调用
> 
> `flag` 为 `false`，则 `sig` 的信号处理器函数中断的系统调用会被自动重启
> 

函数 `siginterrupt()` 的工作原理是：调用 `sigaction()` 获取信号当前处置的副本，调整自结构 `oldact` 中返回的 `SA_RESTART` 标志，接着再次调用 `sigaction()` 来更新信号处置

```c
struct sigaction old_sa;

sigaction(sig, NULL, &old_sa);
old_sa.sa_flag = SA_RESTART;
sigaction(sig, &old_sa, NULL);
```
