# 协程

**协程** 可以看作是一种 **特殊的函数**，它可以 **在任意时刻暂停或者恢复执行**，而不需要像线程那样频繁地进行上下文切换

> [!NOTE] 维基百科
> 
> 协程（英语：coroutine）是计算机程序的一类组件，推广了 **协作式多任务** 的 **子例程(函数)**，**允许执行被挂起与被恢复**
> 
> 相对函数而言，协程更为一般和灵活，但在实践中使用没有函数那样广泛。协程更适合于用来实现彼此熟悉的程序组件，如 **协作式多任务**、**异常处理**、**事件循环**、**迭代器**、**无限列表** 和 **管道**。

## 协程

我们已经知道 **线程是进程中的执行体**，拥有一个执行入口以及从进程虚拟地址空间中分配的栈(包括内核栈和用户栈)，操作系统会记录线程控制信息，当线程获得 CPU 时间片之后才可以执行

> [!seealso] 
> 
> 参考 [[操作系统：多线程概念]] 和 [[操作系统：进程调度]]
> 

当线程获得 CPU 时间片之后，CPU 中的栈指针寄存器(`%rsp`)、栈基寄存器(`%rbp`) 和 程序计数器(`%rip`) 等都要切换到对应的线程

![[Pasted image 20250707230534.png]]

线程也可以创建自己的执行体，它们也拥有自己的执行入口和自己的执行栈。这样线程就可以按需调度自己的执行体了。为了切换这些执行体，线程就需要记录这些执行体的控制信息，包括
+ 执行体标识符
+ 执行栈的位置
+ 执行入口地址
+ 执行s上下文
+ ...

线程可以选择一个执行体来执行，此时 CPU 中的程序计数器(`%rip`) 就会执行这个执行体的执行入口，栈指针寄存器(`%rsp`)和栈基寄存器(`%rbp`) 也会指向线程给它分配的执行栈。

![[Pasted image 20250707232030.png]]

要切换执行体时，需要先保存当前执行体的执行上下文，然后才切换到另一个执行体

![[Pasted image 20250707232310.png]]

通过同样的方式，可以恢复到之前的执行体，从而可以在上次中断的地方继续执行。如下图所示

![[Pasted image 20250707232633.png]]

> [!tip] 
> 
> 这些由线程创建的执行体就是所谓 **协程**。因为用户程序不能操作内核空间，所以只能为协程分配用户栈，而且操作系统对协程一无所知。因此，协程也被称为 **用户态线程**
> 

协程的思想在很早就提出了，并且由不同的实现方式。例如，Windows中的纤程、Lua 中的 coroutine。可是无论被赋予什么样的名字，在创建协程时都要指定执行入口；底层都要分配协程执行栈和控制信息，否则用户态调度无法执行。而让出执行权时，也都要保存当前协程的执行现场，否则就无法恢复

> [!important] 
> 
> 协程思想的关键就在于 **主动让出控制流** 和 **恢复到让出时的状态**。每个协程用于自己的执行栈，可以保存自己的执行现场
> 

因此，可以让用户程序按需创建协程；协程在合适的位置主动让出控制流，此时，会保存执行上下文；然后，将控制流切换到其他协程。协程恢复执行时，会根据之前保存的执行上下文恢复到让出控制流时的状态。这样就实现了即 **轻量** 又 **灵活** 的由 **用户态进行调度** 的多任务模型

![[Pasted image 20250707235106.png]]

尽管协程具有轻量灵活的优点，但是因为只要一个协程阻塞，整个线程都阻塞的缺点，导致了协程没有及时得到应用。然而，随着高并发成为主流趋势，瞬间抵达的海量请求会导致多进程模型下内存资源不足，多线程模型下内核态用户态之间快速切换。因此，协程这种灵活且轻量的用户态调度模型又重新回到了我们的视野中，并且此时 **IO 多路复用** 也变得非常成熟了。目前，协程结合 IO 多路复用是一个炙手可热的高并发解决方案

> [!seealso] 
> 
> 关于 IO 多路复用参考 [[Linux 系统编程：IO 多路复用]] 和 [[Linux 系统编程： epoll]]
> 

