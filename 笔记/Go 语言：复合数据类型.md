# 复合数据类型

## 数组

**数组是一个由固定长度的特定类型元素组成的序列**，一个数组可以由零个或多个元素组成。数组的 **每个元素可以通过 _索引下标_ 来访问**，索引下标的范围是从 $0$ 开始到数组长度减 $1$ 的位置

> [!tip] 
> 
> 内置的 `len()` 函数将返回数组中元素的个数
> 

因为数组的长度是固定的，因此在 Go 语言中很少直接使用数组。和数组对应的类型是 `Slice`（切片），它是可以增长和收缩动态序列，`Slice` 功能也更灵活，但是要理解 `Slice` 工作原理的话需要先理解数组

### 数组的声明与初始化

在 Go 语言中， `[size]Type` 称为长度为 `size` ，元素为  `Type` 类型的数组。由于 Go 语言的零值初始化机制，当我们声明一个 `Type` 类型的数组时，Go 会自动将数组的元素全部初始化为 `Type` 类型的零值

```go
var a [3]int  // 声明长度为 3 元素为 int 类型的数组

fmt.Println(a[0])         // 首元素：0
fmt.Println(a[len(a)-1])  // 尾元素：0
```

在声明数组时，我们可以提供 **初始值**，初始值使用 `[size]Type{value, ...}` 形式提供。例如

```go
var a [3]int = [3]int{1,2,3}

fmt.Println(a[0])         // 首元素：1
fmt.Println(a[len(a)-1])  // 尾元素：3
```

与声明普通变量一样，在提供初始值的情形下，可以省略类型

```go
var a = [3]int{1,2,3} // 编译器自动推断类型
```

Go 语言还支持 **指定索引初始化**，类似于 C99 标准中的指示器 ^[[[C 语言：数组#指示器]]]。上述初始化称为 **顺序初始化**，本质上就是按顺序指定索引。

```go
var a = [3]int{2: 3, 1: 2, 0: 1}
fmt.Printf("%#v\n", a) // [3]int{1, 2, 3}
```

> [!tip] 
> 
> 指定索引初始化与按顺序初始化可以混用
> 

编译器可以自动推断数组元素的个数

```go
var a = [...]int{1,2,3}   // [3]int
var b = [...]int{4:2, 4}  // [6]int
```

**数组的长度是数组类型的一个组成部分**，因此 `[3]int` 和 `[4]int` 是两种不同的数组类型。**数组的长度必须是常量表达式**，因为数组的长度需要在编译阶段确定

```go
q := [3]int{1, 2, 3}
q = [4]int{1, 2, 3, 4} 
// compile error: cannot assign [4]int to [3]int
```

### 遍历

Go 语言有两种遍历数组方式：**使用索引** 和 **range 关键字**

我们首先来看使用索引的方式


```go
var a [10]int

for i := 0; i < len(a); i++ {
	fmt.Printf("a[%d]= %d\n", i, a[i])
}
```

### 比较

回忆 [[C 语言：数组]] 中介绍的内容，在  C 语言中，数组是不可以比较的。因为编译器将数组名视为其首元素的地址。

然而，在 Go 语言中却是不同的，Go 语言中的数组和基本类型的变量相同，即 **Go 将数组视为一个值**。

```go
var a = [3]int{1, 2, 3}
var b = a

a[0] = 3

fmt.Printf("%#v\n", a)  // [3]int{3, 2, 3}
fmt.Printf("%#v\n", b)  // [3]int{1, 2, 3}
```

如果一个数组的元素类型是可以相互比较的，那么数组类型也是可以相互比较的；这时候我们可以直接通过`==` 比较运算符来比较两个数组，只有当两个数组的所有元素都是相等的时候数组才是相等的。不相等比较运算符 `!=` 遵循同样的规则

```go hl:6,7
a := [2]int{1, 2}
b := [...]int{1, 2}
c := [2]int{1, 3}
fmt.Println(a == b, a == c, b == c) // "true false false"

d := [3]int{1, 2}
fmt.Println(a == d) // compile error: cannot compare [2]int == [3]int
```

> [!attention] 
> 
> 再次强调，Go 语言中的运算符的两个操作数必须是相同类型的
> 

## 切片

**切片代表变长的序列**，序列中 **每个元素都有相同的类型**。切片类型一般写作 `[]Type`，其中`Type` 代表 切片中元素的类型；切片的语法和数组很像，只是没有固定长度而已。

**数组和切片之间有着紧密的联系**。一个切片是一个轻量级的数据结构，提供了访问数组子序列（或者全部）元素的功能，而且 **切片的底层确实引用一个数组对象**。切片由三个部分构成：**指针**、**长度** 和 **容量**

> [!tip] 
> 
> + **指针** 指向第一个切片元素对应的底层数组元素的地址，要注意的是切片的第一个元素并不一定就是数组的第一个元素
> 
> + **长度** 对应切片中元素的数目；长度不能超过容量
> 
> + **容量** 一般是从切片的开始位置到底层数据的结尾位置
> 
> 内置的 `len()` 和 `cap()` 函数分别返回切片的长度和容量。
> 

### 声明切片

切片的类型为 `[]Type`，为了声明一个切片，其语法如下

```go
var s []int  // 声明 int 类型的切片
```

> [!tip]
>  
> 此处，Go 语言的零值初始化机制发送作用
> + 指针被初始化为 `nill`
> + 长度和容量均被初始化为 $0$
> 

```go
package main

import (
	"fmt"
)

func main() {
	var s []int            // nil 切片：指针为 nil 的切片对象
	fmt.Printf("%#v\n", s) // []int(nil)
	
	fmt.Println(s[0])      
	// runtime error: index out of range [0] with length 0
	
	fmt.Println(s == nil)  // true
}

```

> [!attention] 
> 
> 使用 `var` 声明的切片对象并没有引用任何底层数组，无法通过索引进行操作
> 

因此，在声明切片时，我们应该显式初始化。初始值使用 `[]Type{value, ...}` 的方式提供

```go
var s = []int{1,2,3}

fmt.Printf("len(s) = %d\t cap(s) = %d", s, s) 
// len(s) = [1 2 3] cap(s) = [1 2 3]
```

注意：使用 `[]Type{}` 初始化的切片对象长度和容量都为 $0$；但是，指针部分并不是 `nil`

```go
var s []int    // len(s) == 0, s == nil
s = nil        // len(s) == 0, s == nil
s = []int(nil) // len(s) == 0, s == nil
s = []int{}    // len(s) == 0, s != nil
```

> [!tip] 
> 
> 如果你需要测试一个切片是否是空的，使用 `len(s) == 0` 来判断，而不应该用 `s == nil` 来判断。
> 

请注意：`nil` 切片除了不能索引操作外，其余操作是完全没有问题的

#### make() 函数

通常，我们期望切片对象已经持有一个底层数组。提前分配需要的空间，可以避免在程序执行过程中浪费时间去分配内存

为切片分配底层数组使用内置的 `make()` 函数，它需要提供 $3$ 个参数：`Type`、长度和容量。容量可以省略，此时容量等价于长度

```go
make([]T, len)
make([]T, len, cap) // same as make([]T, cap)[:len]
```

> [!attention] 
> 
> 请注意：使用 `make()` 函数创建的切片底层数组中的每个元素被初始化为类型 `T` 的零值
> 

### append() 函数

内置的 `append()` 函数用于向切片追加元素，当切片无法容纳新追加的元素时，就会分配新的底层数组，将原来的元素拷贝到新底层数组后才追加新元素

> [!tip] 
> 
> 这意味着可以直接向 `nil` 切片中 `append` 元素
> 

```go
package main

import "fmt"

func main() {
	var s []rune
	for _, v := range "hello, 世界" {
		s = append(s, v)
	}
	fmt.Printf("%#v\n", s) 
	// []int32{104, 101, 108, 108, 111, 44, 32, 19990, 30028}
	
	fmt.Printf("%#q\n", s) // ['h' 'e' 'l' 'l' 'o' ',' ' ' '世' '界']
}
```

在循环中使用 `append()` 函数构建一个由九个 `rune` 字符构成的切，当然对应这个特殊的问题我们可以通过 Go 语言内置的 `[]rune("Hello, 世界")` 强制类型转换操作完成。




