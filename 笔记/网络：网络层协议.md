# 网络：网络层协议

网络层使用的协议是 **IP**，即 **Internet 协议**。该协议中使用地址称为 **Internet 地址**，也称为 **IP 地址**。这里，我们首先介绍 IP 地址的结构

**连接到 Internet 的设备至少有一个 IP 地址**。基于 TCP/IP 协议的专用网络中使用的设备也需要 IP 地址。

> [!tip] 任何情况下，IP 路由器实现的转发程序 **使用 IP 地址来识别流量去向**
> 
> 同时，IP 地址也表示流量来源。也就是说，IP 地址与电话号码有些相似，只要知道设备的 IP 地址，就可以直接向设备发送数据
> 
> 实际上，IP 地址被 Internet 中的 DNS 屏蔽在用户视线之外，DNS 让大多数用户使用名字而不是数字地址
> 

为了了解 Internet 如何识别主机和路由器，并在它们之间实现流量交换，必须了解 IP 地址的作用。因此，我们对 IP 地址的管理、结构和用户感兴趣

> [!tip] 当一台设备连接到全球性的 Internet 时，为它们分配地址就必须经过协调，这样就不会重复使用网络中的其他地址
> 
> 对于专用网络，使用的 IP 地址必须经过协调，从而避免在专用网络中出现类似的重复
> 
> 成组的 IP 地址被分配给用户或组织，这些地址的拥有者再将它们分配舍设备
> 

对于全球性 Internet 地址，一个分层结构管理实体帮助用户和服务提供商分批地址。个人用户由 **Internet 服务提供商(ISP)** 分配地址，通过支付费用来获得地址和执行路由

## 表示 IP 地址

IP 地址在计算机中使用的是一个二进制数表示。然而，这样的整数对于人类而言是不可读的

对于 IPv4 地址，使用 $32$ 位二进制数表示。为了让人类可读，通常采用将 $32$ 位划分为 $4$ 字节，每字节使用十进制整数表示，并在相邻两字节间用点(`.`) 进行分隔。这种表示方法称为 **点分十进制表示法** 

> [!tip] IPv4 地址采用 $32$ 位二进制数表示。为了人类可读，采用 **点分十进制** 表示 IPv4 地址 
> 
> 例如，IPv4 地址 `165.195.130.107` 是点分十进制表示，其二进制表示为 `10100101 1100011 10000010 01101011`
> 
> 

对于 IPv6 地址，使用 $128$ 位二进制数表示。它是 IPv4 地址长度的 $4$ 倍。IPv6 地址的人类可读表示法采用 **分段表示**，每 $4$ 个十六进制数为一段(即 $16$ 位为一段)，每段由冒号(`:`)分隔

> [!tip] IPv6 地址采用 $128$ 位二进制数表示。为了人类可读，采用 **分段** 表示 IPv6 地址：$16$ 位为一段，每段由冒号(`:`)分隔
> 
> 例如，IPv6 地址 `5f05:2000:80ad:5800:0058:0800:2023:1d71`
> 

IPv6 地址的表示法虽然不像点分十进制那样清晰，但是十六进制数更容易转换为二进制数。另外，**一些已取得共识 IPv6 地址简化表示已被标准化**
+ 每段中的前导 $0$ 不必书写
+ 全为 $0$ 的端可以省略，并使用 `::` 代替。为了避免歧义，`::` 只允许在 IPv6 地址中出现 $1$ 次
+ 在 IPv6 格式中嵌入 IPv4 地址可以混合符号形式，紧挨着 IPv4 部分的地址块的值为 `ffff`，地址的其余部分使用点分十进制表示。这种表示法称为 **IPv4映射的 IPv6 地址**
+ IPv6 地址的低 $32$ 位通常采用点分十进制表示。这是 **IPv4 兼容的 IPv6 地址**

## 基本的 IP 地址结构

IPv4 地址空间有 $2^{32}$ 个可能的地址，而 IPv6 的地址空间有 $2^{128}$ 个可能的地址。由于拥有大量地址，可以方便地将地址空间划分成块。IP 地址可根据类型和大小分组

> [!tip] 
> 
> 大多数 IP 地址块最终被细分为一个地址，用于标识连接 Internet 或某些专用的内联网的计算机网络接口，这些地址被称为 **单播地址**
> 
> IPv4 地址空间中大部分是单播地址
> 

### 分类寻址

最初定义 IP 地址结构时，每个单播地址都有一个 **网络地址**，称为 **网络号**，用于标识接口使用的 IP 地址在哪个网络中可以被发送；以及一个 **主机地址**，称为 **主机号**，用于识别网络号给出的网络中的特定主机。如下图，展示一个 IP 地址中网络号和主机号的分布

![Pasted image 20241117234808|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784311237-cf5305043d93438d82b500ac3a8affed.png)

现实中的不同网络可能有不同数量的主机，**每台主机都需要一个唯一的 IP 地址**。一种划分方法是基于当前或预计的主机数量，将不同大小的 IP 地址空间分配给不同的站点

**地址空间的划分涉及 $5$ 类**。每类都 **基于网络中可容纳主机数量**，确定在一个 $32$ 位的 IPv4 地址中分配给网络号和主机号的位数。下图展示了这个分类方式的基本思路

![Pasted image 20241117235629|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784311237-21abe477d1ee49449f7b513522d0db19.png)

IP 地址的 $5$ 个类被命名为 A B C D E。其中 A B C 类空间用于单播地址，即分配给网络接口卡(网卡)的地址。下表给出了这 $5$ 个类的地址范围和用途

![Pasted image 20241118000028|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784311238-201357810c46418b8e162238aaf9abe0.png)

类划分基于给定的可用网络数和给定网络中可分配主机数之间的折中。例如，某个站点分配了一个 A 类网络号 `18.0.0.0`，其中有 $2^{24}$ 个地址分配主机，但是整个 Internet 中只有 $127$ 个 A 类网络

> [!warning] 
> 
> 通常，地址块中的 **第一个地址** 和 **最后一个地址** 是不使用的
> 
> ![Pasted image 20241118110629|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784311241-dc246e01d6bd458abbdf79da17c02a7a.png)
> 
> + 第一个地址的主机号全是 $0$，用于标识网络本身
> + 最后一个地址的主机号全是 $1$，用于在地址块中广播
> 

### 子网寻址

分类寻址的方法在经历了 Internet 增长过程中出现了 **规模问题**，当每个新的网段被添加到 Internet 中，集中协调为其分配一个新的 A类、B类 或 C 类网络号及其不方便。此外，A 类和 B 类网络号通常会浪费太多的主机号，而 C 类网络不能为很多站点提供足够的主机号

> [!attention] 规模问题：当每个新的网段被添加到 Internet 中，集中协调为其分配一个新的 A类、B类 或 C 类网络号及其不方便

为了解决上述问题，人们很自然想到一种方式，**在一个站点接入 Internet 后为其分配一个网络号，然后由站点管理员进一步划分本地的子网数**。在不改变 Internet 核心路由基础设施的情况下解决这个问题将会更好

实现这个想法就需要 **改变一个 IP 地址的网络号和主机号的限制**，但这样做 **只是针对一个站点自身而言**；Internet 的其余部分将只能看到传统的 A 类、B 类和 C 类部分。支持此功能的方法称为 **子网寻址**

> [!tip] 子网寻址：一个站点被分配一个 A 类、B 类或 C 类的网络号，保留一些剩余主机号进一步用于站点内分配
> 

站点可能将基础地址中的主机部分进一步划分为一个 **子网号** 和 **主机号**。也就是说，子网寻址为 IP 地址结构增加了一个额外的部分，但没有为地址增加长度。因此，一个站点管理员能在子网数和每个子网中预期主机数之间折中，同时不需要与其他站点协调

由于当前的 **子网字段** 和 **主机字段** 的定义是 **由站点指定的**，不是由网络号分类决定，一个站点中的所有路由器和主机需要一种新的方式，以确定地址总子网部分和其中的主机部分。下图展示了使用子网寻址的例子，显示了一个 IPv4 地址可能的格式

![Pasted image 20241118120503|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784311241-d9c8774c9dfe4b8786a19d6e7cf6459d.png)

假设 Internet 中的一个站点已被分配一个 B 类网络号。该站点的前 $16$ 位固定，这位被分配给核心机构。后 $16$ 位可以由站点的网络管理员按需分配。上图例子中，$8$ 位选定为子网号，剩余 $8$ 位选定为主机号。这样可以支持 $256$ 个子网，每个子网最多包含 $254$ 台主机

> [!tip] 每个子网的第一个地址标识子网，而最后一个地址是子网的广播地址
> + 第一个地址：主机号全为 $0$
> + 最后一个地址：主机号全为 $1$
> 

> [!attention] 
> 
> 只有划分子网的网络中的主机和路由器才知道子网结构。在需哟进行子网寻址前，Internet 的其他部分仍将它作为站点相关地址看待
> 

下图展示子网寻址是如何工作

![Pasted image 20241118121343|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784311242-7c8ce0059ce04e8fbc615f1006290a8d.png)

某个站点被分配了一个典型的 B 类网络号 `128.32`。网络管理员决定用于站点范围内的 **子网掩码** 为 `255.255.255.0`，提供了 $256$ 个子网，每个子网可以容纳 $256-2 = 254$ 台主机。同一个子网中每台设备的 IPv4 地址拥有相同的子网号。

上图中，站点使用一个 **边界路由器** 连接 Internet 和两个内部局域网。每个以太网是一个 IPv4 子网，整体分配为 B 类地址的网络号 `128.32`。Internet 中的其他站点要访问这个站点，目的地址以 `128.32` 开始的所有流量直接由 Internet 路由系统交给边界路由器

> [!important] 边界路由器：连接到 Internet 的路由器，它是另一个网络中的子网中的一台设备
> 
> 上图中，边界路由器接口的 IPv4 地址为 `137.164.23.30`
> 

**边界路由器必须区分 `128.32` 网络中的不同子网**。特别是，它必须能区分和分离目的地址为 `128.32.1.x` 和目的地址为 `128.32.2.x` 的流量。这些地址分别表示子网号 $1$ 和 $2$，它们都采用 `128.32` 的 BN 类网络号。为了做到这点一，**路由器必须知道在地址中如何找到子网 ID**

### 子网掩码

**子网掩码是由一台主机或路由器使用的分配位，以确定如何从一台主机对应的 IP 地址中获得网络和子网信息**。IP 子网掩码与对应的 IP 地址长度相同。它们通常在一台主机或路由器中以 IP 地址相同的方式配置，既可以是静态的，也可以是动态的

> [!tip] 动态配置主机的 IP 地址和 IP 子网掩码需要使用 **动态主机配置协议(DHCP)**
> 

当前子网掩码是由一些 $1$ 后紧跟一些 $0$ 构成，这样安排就可以用容易记忆的格式表示掩码，只需要给出一些连续位的 $1$ 的掩码。下表给出了 IPv4 子网掩的例子

![Pasted image 20241118144342|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784311244-300ef983be4e4550b50ac0e47f266c5d.png)

掩码由路由器和主机使用，以确定一个 IP 地址的 **网络/子网部分的结束** 和 **主机部分的开始**。子网掩码中的一位设为 $1$ 表示一个 IP 地址的对应位于一个地址的网络和子网部分对应位相结合，并将结果做我转发数据报的基础。相反，子网掩码中的一位设为 $0$ 表示一个 IP 地址的对应位作为主机 ID 的一部分

> [!tip] 子网掩码中前面的 $1$ 表示网络/子网部分，后面的 $0$ 代表主机 ID 部分
> 

下图展示一个子网掩码是如何从 IP 地址中获取 **网络/子网标识符(前缀)**

![Pasted image 20241118145022|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784311247-3d11926c3a5d4902831980b0be8931bc.png)

一个 IP 地址于一个子网掩码执行 **位与** 操作，结果就形成了路由的地址的网络/子网标识符。上图显示的 IP 地址 `128.32.1.14` 使用长度为 $24$ 位的掩码得到的前缀为 `128.32.1.0/24`

## 网络地址转换 

**NAT（Network Address Translation，网络地址转换）** 是一种网络技术，用于在网络设备（如路由器、防火墙）上，将内部网络（私有地址）和外部网络（公共地址）之间的 IP 地址进行转换。**NAT 广泛用于缓解 IPv4 地址短缺问题**，同时提供了一定程度的网络安全性。

> [!important] NAT的工作原理
> 
> **私有地址与公共地址的映射**：
> + 内网设备使用私有IP地址（如192.168.0.1），这些地址无法直接在互联网中使用
> + 当数据包从内网发送到外网时，NAT设备将私有IP替换为公共IP
> + 返回的数据包通过NAT设备，将目标地址还原为内网设备的私有IP
> 
> **转换表(Translation Table)**
> + NAT设备维护一个映射表，记录 **内部私有 IP 和端口** 与 **外部公共 IP 和端口** 的对应关系，用于数据包的正确转发
> 

下图展示了 NAT 技术的工作流程

![Pasted image 20241118151825|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784311249-08863931498c43ab8f07b197490e0a05.png)

## Internet 协议 IP

IP 是 TCP/IP 协议族中核心协议。所有 TCP、UDP、ICMP、IGMP 数据都通过 **IP 数据报** 传输。IP 提供了一种**尽力而为**、**无连接** 的数据包交付服务

> [!tip] 尽力而为：无法保证 IP 数据报能成功到达目的地
> 
> 虽然 IP 不是简单丢弃不必要的流量，但是它也不对自己尝试交付的数据包提供保证
> 
> 当错误发生时，IP 提供一个简单的错误处理方法：**丢弃一些数据**，通常是最后到达的数据报
> 

> [!tip] 无连接：IP 不维护网络单元中数据报相关的任何连接状态信息，每个数据报独立于其他数据报来处理
> 
> IP 数据报可以**不按顺序交付**。也可能发生其他问题：可能在**传输过程中被复制**，可能 **改变内容从而导致错误**
> 

IP 之上的协议需要处理上述潜在的问题，通常是 TCP 协议，以便为应用提供无差错的交付。这里，我们首先看一下 **IPv4 协议数据单元**，如下图所示

![Pasted image 20241118165830|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784311250-84d7290cf4784bc8af65b44e9b0e3b8c.png)


> [!question] 关于 IP 数据报分片问题
> 
> 以太网帧的载荷最大为 $1500$ 字节。然而，IP 数据报最大为 $65535$ 字节。因此，需要对 IP 数据报中的 **载荷进行分片**。每片都是 IP 数据报。被分片的称为**原始 IP 数据报**
> 
> 由于分片在网络中传输过程中，**到达接收方时的顺序可能不同**，并且 **可能接收到多个原始 IP 数据报的分片**。接收方如何识别出同一个IP数据报的分片呢？
> 

解决 IP 数据报分片问题使用了 $3$ 个字段：**标识** **标志** 和 **分片偏移** 

> [!tip] 标识：占 $16$ 位，用于标记每个原始 IP 数据报
> 
> 发送主机每次发送 IP 数据报时将内部计数器加 $1$，并将该计数器的值复制给 IPv4 标识字段
> 

> [!tip] 标志：占 $3$ 位，每位的有特殊用途
> `[第一位 第二位 第三位]`
> + 第一位是保留位，没有被使用
> + 第二位是标识是否不发生分片
> + 第三位是标识是否还有更多分片
> 

> [!tip] 分片偏移：占 $13$ 位，用于标记分片有效载荷在原始 IP 数据报有效载荷中的位置
> 
> 由于分片偏移占 $13$ 位，最大可以表示 $8191$。由于 IP 数据报有效载荷最长为 $65515$ 字节，因此每次最少偏移 $8$ 字节。所有分片中，处理最后一个分片外，其余分片的长度必须是 $8$ 的倍数
>  

> [!attention] 计算分片时，不考虑 IP 数据报头。由于 IP 数据报是以太网帧的有效载荷，因此 IP 数据报最大长度需要保持为 $1500$ 字节


**IPv6 的协议数据单元的头部** 如下图所示

![Pasted image 20241118153333|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784311253-3fd99b399a364aa380aa0f5e3cd00c2d.png)

对比 IPv4 和 IPv6 头部信息。正常的 IPv4 头部大小为 $20$ 字节，IPv6 的大小为 $40$ 字节。在 IP 头部和数据报中，最高位有效位在左侧且编号为 $0$，一个 $32$ 位值的最低有效为在右侧且编号为 $31$。

> [!tip] 网络字节序：高位优先字节序，即 **大端字节序**
> 
> 一个 $32$ 位值的 $4$ 字节按照如下顺序传输
> + 首先，传递 $0 \sim 7$ 位
> + 然后，传递 $8 \sim 15$ 位
> + 接着，传递 $16 \sim 23$ 位
> + 最后，传递 $24 \sim 31$ 位
> 
> 参考 [[计算机组成：信息存储#寻址和字节序]]
> 

计算机的 CPU 使用其他格式存储二进制整数，大多数计算机采用 **小端字节序**，在传输时必须将头部值转换为网络字节序，并在接收时转换回来

#### wireshark 分析 Internet 协议

Internet 协议是 TCP/IP 协议族中的核心协议，Internet 协议的上层协议都会使用该协议。所以，随便抓取一个传输层包就能找到 Internet 协议的报文格式

![Pasted image 20241119163518|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784311255-4fb05d9efb15475a8e6fc0555d39600c.png)

### Internet 校验和

Internet 校验和是一个 $16$ 位的数字和，它能以相当高的概率确定接收的消息或其中部分内容是否与发送的相匹配

> [!warning] 
> 
> Internet 校验和算法与常见的 CRC 不同，后者提供了更强的保护功能
> 

首先将 IPv4 数据报的校验和字段置为 $0$。然后，对头部计算 $16$ 位二进制反码和。这个 $16$ 位二进制反码和被存储在校验和字段中

> [!tip] 二进制反码和计算通过 **循环进位加法** 实现
> 
> 循环进位加法：当使用传统二进制补码加法产生一个进位时，这个进位以二进制值 $1$ 加在高位
> 

下图展示了这个例子

![Pasted image 20241118211410|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784311256-e614df422e154ed1b96cbaaa980fe7ba.png)

当一个 IPv4 数据博被接受时，对整个头部计算出校验和，包括校验和字段自身的值。假设这里没有错误，计算出的校验和值为 $0$，是值 `FFFF` 的反码

## 路由表

将一个 IP 数据报一步一步传递给目标主机使用的核心数据结构是 **路由表**。**在网络中的每台设备上均存储了路由表**。例如，在 Linux 中，可以使用 `route -n` 命令显示本机路由表

```shell
➜  ~ route -n
Kernel IP routing table
# 目标地址       下一跳地址        生成掩码
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         192.168.1.1     0.0.0.0         UG    100    0        0 eth0
192.168.1.0     0.0.0.0         255.255.255.0   U     0      0        0 eth0
10.0.0.0        192.168.1.2     255.255.255.0   UG    200    0        0 eth0
```

路由表中最重要的字段是 **目标地址** **下一跳地址** 和 **生成掩码**

> [!tip] 目标地址：**目标网络** 或 **目标主机** 的地址，通常是 IP 地址
> 
> 该地址可能是一个主机（如 `192.168.1.1`），也可能是一个子网（如 `192.168.1.0/24`）
> 
> 

> [!tip] 生成掩码：用于确定目标地属于那个子网
> 

> [!tip] 下一条地址：数据报转发到的下一台设备的 IP 地址
> 
> 如果目标网络是 **直接连接** 的，下一跳通常为 **空** 或为 **目标地址**
> 

### 路由的工作原理

> [!tip] 提取目标网络/子网标识符
> 
> 路由器收到一个数据包后，提取数据包的 **目标地址**，并将其与 **生成掩码** 进行位与操作，得到 **网络/子网标识符**
>  

> [!tip] 最长匹配原则
> 
> 将目标网络/子网标识符与路由表中的目标地址进行匹配。如果匹配多个条目，选择最长前缀匹配的条目
> 
> 例如，`192.168.1.0/24` vs. `192.168.1.0/16`，选择 `/24`。
> 

> [!tip] 转发数据包
> 
> 查找匹配的条目中的下一跳地址，将数据包转发到下一跳地址指定的网络接口上
> 

下图是路由工作的流程

![Pasted image 20241118181418|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784311258-62486466f8b44c3094828397e032d56a.png)
