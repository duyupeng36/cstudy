# 虚拟内存操作

这里介绍的系统调用需要与 [[内存映射]]  [[System V 共享内存]]  [[POSIX 共享内存]] 结合起来一起使用才能够发挥特别的作用，但它们可以被应用于一个进程的虚拟内存中的任何区域

## 改变保护内存

`mprotect()` 系统调用修改起始位置为 `addr` 长度为 `length` 字节的虚拟内存区域中分页上的保护

```c
#include <sys/mman.h>

int mprotect(void *addr, size_t length, int prot);
/* 成功返回 0；错误返回 -1*/
```

> [!tip] 参数 `addr`：需要修改保护位的虚拟内存起始地址
> 
> 该参数通常是 `mmap` `shmat` 的返回值，因为它们保证返回值 `addr` 是系统分页大小的整数倍 
> 

> [!tip] 参数 `length`：保护内存的长度
> 
> 实际上 `length` 会被向上舍入到系统分页大小的下一个整数倍
> 

> [!tip] 参数 `prot`：新的保护位
> 
> 取值如下表

|    `prot`     | 解释      | 备注                      |
| :-----------: | :------ | :---------------------- |
| ``PROT_NONE`` | 区域无法访问  | 要么取该值，要么时下面三个值的 **按位或** |
|  `PROT_READ`  | 区域内容可读取 |                         |
| `PROT_WRITE`  | 区域内容可修改 |                         |
|  `PROT_EXEC`  | 区域内容可执行 |                         |

> [!tip] 
> 
> 如果一个进程在访问一块内存区域时 **违背了内存保护**，那么内核就会向该进程发送一个 `SIGSEGV` 信号
> 

`mprotect()` 的一个用途是修改原先通过 `mmap()` 调用设置的映射内存区域上的保护

## 内存锁

将一个进程的 **虚拟内存** 的部分或全部 **锁进物理内存** 以确保它们 **总是位于物理内存中** 是非常有用的

> [!tip] 原因
> 
> **它可以提高性能*：**对被锁住的分页的访问可以确保永远不会因为缺页而发生延迟**。这对于那些需要确保快速响应时间的应用程序来讲是很有用的
> 
> **安全**：如果一个包含 **敏感数据的虚拟内存分页永远不会被交换出去**，那么该分页的副本就不会被写入到磁盘
> + 如果该分页被写入到了磁盘，那么从理论上来讲就可以在后面某个时刻直接从磁盘中读取该分页
> + 攻击者可能会故意通过运行一个消耗大量内存的程序来构造这种场景，从而强制其他进程占据的内存被交换到磁盘上
> + 由于内核不保证会清除交换空间中保存的数据，因此即使在进程终止之后也可能从交换空间中读取信息。（一般来讲，只有特权进程才能够从交换设备上读取数据。）
> 

内核会限制锁入物理内存的分页。**`RLIMIT_MEMLOCK`** 是一个进程能够锁进内存的字节数设定了一个上限

> [!tip] 
> 
> 由于 **虚拟内存的管理单位是分页**，因此 **内存加锁会应用于整个分页**。在执行限制检查时，`RLIMIT_MEMLOCK` 限制会 **被向下舍入到最近的系统分页大小的整数倍**
> 

### 给内存区域加锁和解锁

一个进程可以使用 `mlock()` 和 `munlock()` 来给一块内存区域加锁和解锁

```c
#include <sys/mman.h>

int mlock(void *addr, size_t length);
int munlock(void *addr, size_t length);

/* 成功返回 0；错误返回 -1*/
```

`mlock()` 系统调用会锁住调用进程的虚拟地址空间中起始地址为 `addr` 长度为 `length` 字节的区域中的所有分页

由于 **加锁操作的单位是分页**，因此被锁住的区域的结束位置为大于 `length` 加 `addr` 的下一个分页边界

> [!example] 
> 例如，在一个分页大小为 `4096` 字节的系统上，`mlock(2000, 4000)`调用会将 `0` 到 `8191` 之间的字节锁住
> 

`munlock()` 系统调用执行的操作与 `mlock()` 相反，即删除之前由调用进程创建的内存锁

> [!tip] 其他情况，可以自动解锁
> + 在进程终止时
> + 当被锁住的分页通过 `munmap() `被解除映射时
> + 当被锁住的分页被使用 `mmap() MAP_FIXED` 标记的映射覆盖时
> 

### 给进程占据的所有内存加锁和解锁

一个进程可以使用 `mlockall()` 和 `munlockall()` 给它占据的所有内存加锁和解锁。

```c
#include <sys/mman.h>

int mlockall(int flags);
int munlockall(void);
/* 成功返回 0；错误返回 -1*/
```

 `flags` 参数的取值为下面这些常量中的一个或多个的位或

|    `flags`    | 描述                         | 备注                     |
| :-----------: | :------------------------- | :--------------------- |
| `MCL_CURRENT` | 进程的虚拟地址空间中所有映射的分页锁入内存      | 包括文本段，数据段，内存映射，栈分配的所有页 |
| `MCL_FUTURE`  | 将后续映射进调用进程的虚拟地址空间的所有分页锁进内存 |                        |

## 确定内存驻留性

`mincore()` 系统调用是内存加锁系统调用的补充，它 **报告在一个虚拟地址范围中哪些分页当前驻留在 DRAM 中**，因此在访问这些分页时也不会导致分页故障

**SUSv3 并没有规定 `mincore()`**，很多 UNIX 实现都提供了这个函数，但不是所有的 UNIX 实现都提供了这个函数。**在 Linux 上从内核 2.4 开始提供了 `mincore()`**。

```c
#inlude <sys/mman.h>

int mincore(void *addr, size_t length, unisgned char *vec);
/*成功返回 0；错误返回 -1*/
```

内存驻留相关的信息会通过 `vec` 返回，它是一个数组，其大小为 `(length + PAGE_SIZE – 1) / PAGE_SIZE` 字节

## 建议后续的内存使用模式

`madvise()`系统调用通过通知内核调用进程对起始地址为 `addr` 长度为 `length` 字节的范围之内分页的可能的使用情况来提升应用程序的性能
- 内核可能会使用这种信息来提升在分页之下的文件映射上执行的 I/O 的效率

在 Linux 上从内核 2.4 开始提供了 `madvise()`

```c
#include <sys/mman.h>

int madvise(void *addr, size_t length, int advice);

/* 成功返回 0； 错误返回 -1*/
```

`advice` 参数的取值为下列之一

|     `advice`      | 描述                 | 备注                       |
| :---------------: | :----------------- | :----------------------- |
|   `MADV_NORMAL`   | 默认行为               | 分页是以簇的形式传输的，导致预先读和事后读    |
|   `MADV_RANDOM`   | 分页会被随机访问           | 预先读将不会带来任何好处,内核尽可能少的读取数据 |
| `MADV_SEQUENTIAL` | 分页只会被访问一次，并且是顺序访问  | 内核可以激进的预先读，分页被访问后就释放     |
|  `MADV_WILLNEED`  | 预先读取这个区域中的分页       |                          |
|  `MADV_DONTNEED`  | 不再要求这个区域中的分页驻留在内存中 |                          |
