# 整数的表示与运算

## 整数的表示

C 语言支持多种不同种类的整数类型。但是大体上就分为两种：**有符号整数** 和 **无符号整数**

> [!tip] 
> 无符号整数只能表示非负数，而有符号整数能够表示负数、 零 和正数 
> 

### 无符号数编码

假设一个整数数据类型有 $w$ 位。我们可以将位向量 $\vec x = \left[x_{w-1}, x_{w-2} \cdots, x_2,x_1,x_0\right]$ 看作一个二进制表示的数，就获得了 $\vec x$ 的无符号表示

> [!tip]
> 
> 在这个编码中，每个位 $x_i$，都取值为 $0$ 或 $1$。当 $x_i$ 取值为 $1$ 时，意味着数值 $2^i$ 应为数字值的一部分 
> 

无符号数编码的定义为：对于位向量 $\vec x = \left[x_{w-1}, x_{w-2} \cdots, x_2,x_1,x_0\right]$ 

$$
B2U_w(\vec x) = \sum_{i = 0}^{w-1}x_i\cdot2^i
$$

函数 $B2U_w$ 将一个长度为 $w$ 位的 $0, 1$ 串映射到非负整数。例如

$$
\begin{aligned}
&B2U_4([0001]) = 0 \cdot 2^3 + 0 \cdot 2^2 + 0 \cdot 2^1 + 1 \cdot 2^0 = 0 + 0 + 0 + 1 = 1  \\ 
&B2U_4([0101]) = 0 \cdot 2^3 + 1 \cdot 2^2 + 0 \cdot 2^1 + 1 \cdot 2^0 = 0 + 4 + 0 + 1 = 5\\
&B2U_4([1011]) = 1 \cdot 2^3 + 0 \cdot 2^2 + 1 \cdot 2^1 + 1 \cdot 2^0 = 8 + 0 + 2 + 1 = 11 \\
&B2U_4([1111]) =1 \cdot 2^3 + 1 \cdot 2^2 + 1 \cdot 2^1 + 1 \cdot 2^0 = 8 + 4 + 2 + 1 = 15 
\end{aligned}
$$

下图展示上面几种情况下 $B2U$ 给出的从位向量到整数的映射

![[Pasted image 20241005124859.png]]

在图中，我们用长度为 $2^i$ 的指向右侧箭头的条表示每个位的位置 $i$ 。每个位向量对应的数值就等于所有值为 $1$ 的位对应的条长度之和。

让我们来考虑 一 下 $w$ 位所能表示的值的范围

> [!tip] 最小值
> 
> 最小值使用位向量 $[0,0,\cdots, 0,0]$ 表示，也就是整数 $0$
> 

> [!tip] 最大值
> 
> 最大值使用位向量 $[1,1,\cdots,1,1]$ 表示，也就是整数 $UMax_{w}=\sum_{i=0}^{w-1}2^i=2^w-1$
> 

无符号数的二进制表示有一个很重要的属性，也就是每个介于 $0 \sim 2^w - 1$ 之间的数都有唯一一个 $w$ 位的值编码

> [!hint] 
> 
> 无符号数编码的唯一性
> 

### 补码编码

对于许多应用，我们还希望表示负数值。最常见的有符号数的计算机表示方式就是 **补码**。在这个定义中，**将字的最高有效位解释为负权**

补码编码的定义：对于位向量 $\vec x = \left[x_{w-1}, x_{w-2} \cdots, x_2,x_1,x_0\right]$ 

$$
B2T_{w}(\vec{x}) = -x_{w-1}\cdot 2^{w-1} + \sum_{i=0}^{w-2}x_{i}\cdot 2^{i}
$$

> [!tip] 
> 最高有效位 $x_{w-1}$ 也称为 **符号位**，它的 **权重** 为 $—2^{w-1}$ ，是无符号表示中权重的负数
> 

符号位被设置为 $1$ 时，表示值为负，而当设置为 $0$ 时，值为非负。例如

$$
\begin{aligned}
&B2T_4([0001]) = - 0 \cdot 2^3 + 0 \cdot 2^2 + 0 \cdot 2^1 + 1 \cdot 2^0 = 0 + 0 + 0 + 1 = 1  \\ 
&B2T_4([0101]) = - 0 \cdot 2^3 + 1 \cdot 2^2 + 0 \cdot 2^1 + 1 \cdot 2^0 = 0 + 4 + 0 + 1 = 5\\
&B2T_4([1011]) = -1 \cdot 2^3 + 0 \cdot 2^2 + 1 \cdot 2^1 + 1 \cdot 2^0 = -8 + 0 + 2 + 1 = -5 \\
&B2T_4([1111]) =-1 \cdot 2^3 + 1 \cdot 2^2 + 1 \cdot 2^1 + 1 \cdot 2^0 = -8 + 4 + 2 + 1 = -1 
\end{aligned}
$$

下图展示了上述几种情况下 $B2T$ 给出的从位向量到整数的映射

![[Pasted image 20241005152736.png]]

让我们来考虑一下 $w$ 位补码所能表示的值的范围

> [!tip] 最小值
> 
> 补码编码能表示的最小值的位向量为 $[1,0,\cdots,0,0]$，也就是设置这个位为负权，但是清除其他所有的位；其整数值为 $TMin_{w} = -2^{w}-1$
> 

> [!tip] 最大值
> 
> 补码编码能表示的最大值的位向量为 $[0,1,\cdots,1,1]$，也就是清除具有负权的位，而设置其他所有的位；其整数值为 $TMax_{w} = 2^{w-1}-1$
> 

 同无符号表示一样，在可表示的取值范围内的每个数字都有一个唯一的 $w$ 位的补码编码
 
 > [!hint] 
 > 补码编码的唯一性
 > 

> [!question] 
> 如何获将十进制负整数转换为二进制补码表示？
> 

这里我们需要了解两个概念：**补数** 与 **减补数**

> [!important] **补数** 与 **减补数**
> 自然数 $a$ 在给定进制下的 **补数** 定义为：对于给定的 **进制**，与自然数 $a$ 相加后使得得位数增加 $1$ 的最小的数
> 
> + $b$ 进制数 $a$ 关于 **基数的补数** ($b$ 的补数): $b^n−a$
> 
> + $b$ 进制数 $a$ 关于 **减基数的补数** ($b - 1$ 的补数)，简称 **减补数**、侪补数): $b^n-a-1$

对于 $N$ 进制的自然数 $a=a^ra^{r−1}a^{r−2}\cdots a^1a^0$ 规定数 $b$ 的各位为 $b_i=(N+1)+a_i$。称数$b$ 为 $a$ 关于 $N+1$ 的 **补数**

> [!important] 二进制下的 **补数** 与 **减补数**
> 在二进制下，求 $1$ 的补数只需简单地将 $0$ 与 $1$ 相互替换。求 **2补数** (即 **补码**)，只需要将 $1$ 补数加 $1$

所以，为了求一个二进制数的 $2$ 补数，只需要先求 $1$ 补数，然后在加 $1$ 即可

> [!summary] 求十进制负整数的二进制补码表示
> 将该十进制负整数的绝对值转换为二进制表示，然后先对该二进制表示求 $1$ 补数，然后加 $1$ 即可得到该负数的二进制补码表示

例如，对于 $-1$ 采用 $8$ 位位模式表示时，其绝对值 $1$ 的二进制表示为 $00000001$，求 $1$ 补数之后为 $11111110$，在加 $1$ 得到 $11111111$

```
-1 的绝对值 1 的 8 位二进制表示为

0000 0001

其 1 补数为

1111 1110

2补数等于 1补数加1

1111 1111
```

> [!tip] 有符号数的其他表示方法
> 
> **反码**：除了最高有效位的权是 $-(2^{w-1}-1)$ ，其他的和和补码是一样的
> 
> $$
> B2O_{w}(\vec{x}) = -x_{w-1}(2^{w-1}-1) + \sum_{i=0}^{w-2}x_{i}2^{i}
> $$
> 
> **原码**：最高有效位是符号位，用来确定剩下的位应该取负权还是正权
> 
> $$
> B2S_{w}(\vec{x})=(-1)^{x_{w-1}} \cdot \left( \sum_{i=0}^{w-2}x_{i}2^{i} \right)
> $$
> 
> 这两种表示方法都有一个奇怪的属性，那就是对于数字 $0$ 有两种不同的编码方式
> 

为了更好地理解补码表示，考虑下面的代码 ：

```c
short x = 12345;
short mx = -x;

show_bytes((byte_pointer)&x, sizeof(short));  // 0x39 0x30
show_bytes((byte_pointer)&mx, sizeof(short)); // 0xc7 0xcf
```

在小端机器上，输出 `0x39 0x30` 和 `0xc7 0xcf`，指明 `x` 的十六进制表示为 `0x3039`, 而 `mx` 的十六进制表示为 `0xCFC7`。将它们展开为二进制 ，我们得到 `x` 的位模式为 `[0011 0000 0011 1001]` ，而 `mx` 的位模式为 `[1100 1111 1100 0111]`

### 类型转换

#### 补码与无符号数的转换

C 语言允许在各种不同的数字数据类型之间做强制类型转换。

例如，假设变量 `x` 声明为 `int`, `u` 声明为 `unsigned` 。表达式 `(unsigned) x` 会将 `x` 的值转换成一个无符号数值，而 `(int) u` 将 `u` 的值转换成一个有符号整数

> [!question] 
> 将有符号数强制类型转换成无符号数，或者反过来，会得到什么结果呢？
> 

对千大多数 C 语 言 的实现来说，只是改变了底层位模式的解释方式，而非修改了位模式

```c
short int v = 12345;
unsigned short int uv = (unsigned short int) v;

show_bytes((byte_pointer)&v, sizeof(short));           // 0x39 0x30
show_bytes((byte_pointer)&uv, sizeof(unsigned short)); // 0x39 0x30
```

> [!tip] 
> 
> 从输出结果可以看出，**强制类型转换的结果 _保持位模式不变_，只是 _改变了解释这些位的方式_**
> 

给定位模式的 **补码与无符号数之间的关系** 可以表示为函数 $T2U$

$$
T2U_{w}(\vec{x}) = \begin{cases}
x+2^w & x < 0 \\ 
x & x > 0
\end{cases}
$$

给定位模式的 **无符号数与补码之间的关系** 可以表示为函数 $U2T$

$$
U2T_{w}(\vec{x}) = \begin{cases}
u & u \le TMax_{w} \\
u-2^w & u > TMax_{w}
\end{cases}
$$

#### 扩展

一个常见的运算是 **在不同字长的整数之间转换**，同时又 **保持数值不变**

**要将一个无符号数转换为一个更大的数据类型**，只要简单地在表示的 **开头添加 $0$** 。这种运算被称为 **零扩展**

**要将一个补码数字转换为一个更大的数据类型**，可以执行一 个**符号扩展**：在位模式的 **开头添加符号位的值**

#### 截断

如果我们需要减少表示一个数字的位数，即进行 **窄化转换**。我们会丢弃高 $w-k$ 位，得到一个 $k$ 位向量

截断一个数字可能会改变它的值。如果发生值改变称为 **溢出**。对于一个无符号数，我们可以很容易得出其数值结果。

> [!tip] 截断无符号数
> 令 $\vec{x} = [x_{w-1},x_{w-2},\cdots, x_{1},x_{0}]$ ，而了是将其截断为 $k$ 位的结果： $\vec{x}^{\prime} =[x_{k-1},x_{k-2},\cdots, x_{0}]$
> $$
> x^{\prime} = B2U_{k}(x^{\prime}) = B2U_{w}(\vec{x}) \mod{2^k}
> $$
> 

> [!tip] 截断补码
> 
> 补码截断也具有相似的属性，只不过要将最高位转换为符号位
> 
> $$
> B2T_{k}([x_{k-1},\cdots,x_{1},x_{0}]) = B2T_{k}(B2U_{w}([x_{w-1},x_{w-2},\cdots, x_{1},x_{0}]) \mod{2^k})
> $$
> 

## 整数的运算

### 无符号加法

对于两个长度为 $w$ 的无符号数 $x, y$ 的和。如果计算它们的和，一个可能的范围是 $0 \le x + y \le 2^{w+1}-2$，即，这个和可能需要 $w+1$ 位才能表示

> [!tip] 
> 
> 要想完整地表示算术运算的结果，我们不能对字长做任何限制

例如，Python 对整数就没有字长限制。然而，更常见的是，**编程语言支待固定精度的运算**，因此像 “加法” 和 “乘法” 这样的运算不同于它们在整数上的相应运算

定义 $w$ 位的无符号加法表示为 $+_{w}^{u}$，该操作就是把整数和 $x+y$ 截断为 $w$ 位的结果，再把这个结果解释为无符号数

> [!tip]
> 
> 这可以被视为一种形式的模运算，对 $x+y$ 的位级表示，简单丢弃任何权重大于 $2^{w-1}$ 的位就可以计算出 $(x+y) \mod{2^w}$ 的结果

无符号数加法 $+_{w}^{u}$ 定义如下

$$
x +_{w}^{u} = \begin{cases}
x + y & x + y < 2^w (正常)\\
x+y-2^w & 2^w \le x+y\lt 2^{w+1}(溢出)
\end{cases}
$$

> [!tip] 无符号加法的溢出判定条件：$x +_{w}^{u} y < x || x +_{w}^{u} y < y$
> 
> 当执行 C 程序时，不会将溢出作为错误而发信号
> 
> 我们可能希望判定是否发生了溢出。判定无符号加法溢出的原理就是：对于在范围 $0 \le x, y \le UMax_{w}$ 中的 $x$ 和 $y$，令 $s=x+_{w}^{w}y$。如果发生溢出，则 $s < x \Vert s < y$
> 

模数加法形成了一种数学结构，称为 **阿贝尔群**。它是可交换的和可结合的，有一个单位元 $0$，并且且每个元素有一个加法逆元

> [!tip] 无符号加法逆元
>  执行无符号加法 $+_{w}^{u}$，对于每个值 $x$，必定存在某个值 $-_{w}^{u}x$ 满足 $-_{w}^{u}x +_{w}^{u}x = 0$
>  

因此，无符号数求反定义为：对满足  $0\le x \lt 2^w$ 的任意 $x$，其 $w$ 位的无符号逆元$-_{w}^{u}x$ 由下式给出

$$
-_{w}^{u}x = \begin{cases}
x & x = 0 \\
2^w-x & x > 0
\end{cases}
$$

### 无符号乘法

范围在 $0 \le x, y \le 2^{w}-1$ 内的整数 $x$ 和 $y$ 可以被表示为 $w$ 位的无符号数，但是它们的乘积 $x\cdot y$  的取值范围为 $0 \sim 2^{2w} - 2^{w+1}+1$，需要 $2w$ 位表示。C 语言中的无符号乘法被定义为产生 $w$ 位的值，就是 $2w$ 位的整数乘积的低 $w$ 位表示的值

> [!tip] 
> 将一个无符号数截断为 $w$ 位等价于计算该值模 $2^w$
> 

无符号数乘法定义为：对满足 $0 \le x, y \le UMax_{w}$ 的 $x$ 和 $y$ 有

$$
x *_{w}^{u} y = (x \cdot y) \mod{2^w}
$$


### 补码加法

对于补码加法，我们必须确定当结果太大（为正）或者太小（为负）时，应该做些什么。

想要完整表示补码加法 $x+y$ 的结果，就需要 $w+1$ 位。和之前一样，定义 $x+_{w}^{t}y$ 为整数和 $x + y$ 被截断为 $w$ 位的结果，并将这个结果看做是补码数。


补码加法 $+_{w}^{t}$ 定义为：对于满足 $-2^{w-1} \le x, y \le 2^{w-1}-1$ 的整数 $x$ 和 $y$，其补码加法的结果为

$$
x+_{w}^{t}y=\begin{cases}
x+y-2^w & 2^{w-1} \le x + y & (正溢出) \\
x+y & -2^{w-1} \le x+y \lt 2^{w-1}& (正常) \\
x+y+2^w & x + y \lt -2^{w-1} & (负溢出)
\end{cases}
$$

> [!tip] 补码加法溢出判定条件
> + 如果 $x, y > 0$，但是 $x+_{w}^{t}y \le 0$，计算发生正溢出
> + 如果 $x, y < 0$，但是 $x+_{w}^{t}y \ge 0$，计算发生负溢出

> [!tip] 补码加法的逆元
> 对于满足 $TMin_{w} \le x \le TMax_{w}$ 的 $x$，其补码的加法逆元 $-_{w}^{t}x$ 定义为
> $$
> _{w}^{t}x = \begin{cases}
> TMin_{w} & x = TMin_{w} \\
> -x & x \gt TMin_{w}
> \end{cases}
> $$
> 
> 执行位级补码逆元的笫一种方法是对每一位求补，再对结果加 $1$ 。在 C 语言中，我们可以说， 对于任意整数值 $x$, 计算表达式 $-x$ 和 $\sim x+1$  得到的结果完全一样
> 

###  补码乘法

无符号和补码的乘法的位级表示是一样的，只是解释方式不同。也就是说对于满足 $TMin_{w} \le x,y \le TMax_{w}$ 的 $x$ 和 $y$ 有

$$
x *_{w}^{t} y = U2T_{w}((x \cdot y) \mod{2^w})
$$
