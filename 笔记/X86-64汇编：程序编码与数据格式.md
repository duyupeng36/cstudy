# 程序编码与数据格式


计算机执行 **机器代码**，用 **字节序列编码低级的操作**，包括处理数据、管理内存、读写存储设备上的数据，以及利用网络通信

> [!tip] 
> 编译器基于编程语言的规则、目标机器的指令集和操作系统遵循的惯例，经过一系列的阶段生成机器代码
> 

GCC C 语言编译器以 **汇编代码** 的形式产生输出，汇编代码是机器代码的文本表示，给出程序中的每一条指令。然后GCC 调用 **汇编器** 和 **链接器**，根据汇编代码生成可执行的机器代码。

## 程序编码

计算机系统使用了多种不同形式的 **抽象**，利用更简单的抽象模型来隐藏实现的细节。对于机器级编程来说，其中两种抽象尤为重要：**指令集体系结构** 和 **虚拟地址**

> [!tip] 指令集体系结构：定义机器级程序的 **格式和行为**
> 

> [!tip] 虚拟地址：提供了一个字节数字作为内存模型
> 
> 存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来
> 

在整个编译过程中，编译器会完成大部分的工作，将把用 C 语言提供的相对比较 抽象的 **执行模型** 表示的程序转化成 **处理器执行的非常基本的指令**

**汇编代码表示非常接近于机器代码**。与机器代码的二进制格式相比，汇编代码的主要特点是它用 **可读性更好** 的文本格式表示。能够理解汇编代码以及它与原始 C 代码的联系，是理解计算机如何执行程序的关键一步。

x86-64 的机器代码和原始的 C 代码差别非常大。一些通常对 C 语言程序员隐藏的处理器状态都是 **可见的**

> [!tip] **程序计数器** (通常称为 PC ，在 x86-64 中用 `%rip` 表示) 
> `%rip` 中存储了将要执行的下一条指令的地址
> 

> [!tip] **整数寄存器文件**：包含 `16` 个命名的位置，分别存储 `64` 位的值
> + 这些寄存器可以 **存储地址**(对应于 `C` 语言的指针)或 **整数数据**
> + 有的寄存器被用来 记录某些重要的 **程序状态**
> + **保存临时数据**，例如，函数的返回值
> 

> [!tip] **条件码寄存器** 保存着最近执行的 **算术或逻辑指令的状态信息**
> 
> 它们用来实现控制或数据流中的条件变化，比如说用来实现 `if` 和 `while` 语句
> 

> [!tip] 向量寄存器
> 
> 存放一个或多个 **整数** 或 **浮点数值**
> 


例如下面 C 语言代码文件 `mstore.c`, 包含如下的函数定义

```c
long mult2(long l1,long l2);
void multstore(long x, long y, long *dest) {
    long t = mult2(x, y);
    *dest = t;
}
```

在命令行上使用`"-S"`  选项，就能看到 GCC  C 语言编译器产生的汇编代码

```c
multstore:
	pushq	%rbx
	movq	%rdx, %rbx
	call	mult2
	movq	%rax, (%rbx)
	popq	%rbx
	ret
```

上面代码中每个缩进去的行都对应于一条机器指令。比如，`pushq` 指令表示应该将寄存器 `%rbx` 的内容压入程序栈中。这段代码 **除去了** 所有关于 **局部变量名** 或 **数据类型** 的信息

## 数据格式

由于是从 $16$ 位体系结构扩展位 $32$ 位 体系结构， Intel 用 **字** 表示 $16$ 位数据类型，$32$ 位称为双字，$64$ 位称为四字

GCC 生成的汇编代码指令都有一个字符的后缀，表明操作数的大小
- `movb`(传送字节)
- `movw`(传送字)
- `movl`(传送双字)，`32` 位数被看成是 长字(`long word`)
- `movq` (传送四字)

> [!attention] 
> 
> 注意，后缀 `l` 用来表示 `4` 字节整数 和 `8` 字节浮点数并不会引起歧义，因为 **浮点数使用了一组完成不同的指令和寄存器**
> 

