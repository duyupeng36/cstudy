# System V IPC 介绍

System V IPC 包括 $3$ 种不同的进程间通信机制

> [!tip] **消息队列**：用来在 **进程之间传递消息**
> 
> 消息队列与管道有点像，但存在两个重大差别
> + **消息队列是存在边界的**，这样读者和写者之间以消息进行通信，而不是以字节流
> + 每条消息包括一个整型的 `type` 字段，并且可以通过类型类选择消息而无需以消息被写入的顺序来读取消息
>   

 > [!tip] **信号量**：允许 **多个进程同步它们的动作**
 > 
 > 一个 **由内核维护的整数值**，它对所有具备相应权限的进程可见
 > 
 > 一个进程通过 **对信号量的值进行相应的修改** 来通知其他进程它正在执行某个动作
 > 

> [!tip] **共享内存**：使得 **多个进程能够共享内存的同一块区域**
> 
> 共享内存是 **同一帧物理内存**，被 **映射** 到多个进程的虚拟内存的页帧
> 
> 由于访问用户空间内存的操作是非常快的，因此共享内存是其中一种速度最快的 IPC 方法：**一个进程一旦更新了共享内存，那么这个变更会立即对共享同一个内存段的其他进程可见**
> 

这 $3$ 种 IPC 机制是在同一时间被开发出来的。它们在 $20$ 世纪 $70$ 年代后期首次初夏在 Columbus UNIX 系统中

> [!tip] Columbus UNIX
> 
> 是 Bell 内部实现的一种 UNIX，用于运行电话公司记录保存和管理过程中用到的数据库和事务处理系统

 在 $1938$ 年左右，这些 IPC 机制出现在主流的 System V UNIX 系统上，System V IPC 的名字由此而来

> 将 System V IPC 机制放在一起讨论的一个更加重要的原因是**它们的编程接口都具备一些特征**，因此 **很多同样的概念都适用于所有这些机制**

## 概述

下表对使用 System V IPC 对象需用到的头文件和系统调用进行了总结

| 接口        | 消息队列                                 | 信号量                          | 共享内存                   |
| :-------- | ------------------------------------ | ---------------------------- | ---------------------- |
| 头文件       | `<sys/msg.h>`                        | `<sys/sem.h>`                | `<sys/shm.h>`          |
| 关联数据结构    | `msqid_ds`                           | `semid_ds`                   | `shmid_ds`             |
| 创建或打开对象   | `msgget()`                           | `semget()`                   | `shmget()` 和 `shmat()` |
| 关闭对象      |                                      |                              | `shmdt()`              |
| 控制操作      | `msgctl()`                           | `semctl()`                   | `shemctl()`            |
| 执行 IPC 操作 | 写入消息: `msgsnd()`<br>接收消息: `msgrcv()` | 测试:`semop()`<br>调整:`semop()` | 虚拟内存的访问方式              |
### IPC 对象的生命周期

#### 创建和打开 IPC 对象

每种 System V IPC 机制都有一个相关的 `<IPC>get` 系统调用，给定一个整数 `key`（类似于文件名），`<IPC>get` 调用完成下列某个操作

> [!tip] 创建一个 **新的 IPC 对象**
> 
> 使用给定的 `key` 创建一个新 IPC 对象并返回一个唯一的标识符来标识该对象
> 

> [!tip] 返回既有 **IPC 对象的标识符**
> 
> 返回一个拥有给定的 `key` 的既有 IPC 对象的标识符
> 

IPC 标识符与文件描述符类似，在后续所有引用该 IPC 对象的系统调用中都需要用到它。

> 文件描述符是一个进程特性，而 **IPC 标识符则是对象本身的一个属性** 并且 **对系统全局可见**。所有访问同一对象的进程使用同样的标识符

如果知道一个 IPC 对象已经存在，那么可以跳过 `<IPC>get` 调用，只要能够通过某种机制来获知对象的标识符即可

> [!example] 
> 
> 例如，创建对象的进程可能会将标识符写入一个可供其他进程读取的文件。
> 

```c
id = msgget(key, IPC_CREAT | S_IRUSR | S_IWUSR);
if(id == -1) {
	errExit("msgget");
}
```

与所有的 `get` 调用一样，`key` 是第一个参数，标识符是函数的返回结果。传递给 `get` 调用的最后一个参数(`flags`)使用与文件一样的掩码常量 ^[[[文件属性#文件权限]]] 指定了新对象上的权限。在上面的例子中只给对象的所有者赋予了在队列中读取和写入消息的权限

> [!attention] 
> 
> 进程 `umask` 值不会对创建新的 IPC 对象上的权限产生影响
> 

所有需访问同一个 IPC 对象的进程在执行 `<IPC>get` 调用时会指定同样的 `key` 以获取该对象的同一个标识符

> [!tip] 创建 IPC 对象的条件
> 
> 如果没有与指定的 `key` 对应的 IPC 对象，并且 `flags` 参数中指定了 `IPC_CREAT`，那么 `<IPC>get` 调用会创建 IPC 对象
> 
> 如果没有与指定的 `key` 对应的 IPC 对象，并且  `flags` 中没有指定 `IPC_CREAT`，那么 `<IPC>get` 调用将失败并设置 `errno` 为 `ENOENT` 错误
> 

 进程可以指定 `IPC_EXECL` 标志确保它是创建 IPC 对象的进程。如果指定了 `IPC_EXECL` 并且与给定 `key` 对应的 IPC 对象已存在，那么 `<IPC>get` 调用失败并设置 `errno` 为 `EEXIST`

#### IPC 对象的持久性

System V IPC 对象具备 **内核持久性**。一旦被创建之后，一个对象就一直存在直到它被显式地删除或系统被关闭

System V IPC 对象的这个属性是非常有用的。因为一个进程可以创建一个对象、修改其状态、然后退出并使得在后面某个时刻启动的进程可以访问这个对象

> [!warning] 内核持久性的缺点
> 
> + 系统对每种类型的 IPC 对象的数量是有限制的。如果没有删除不用的对象，那么应用程序最终可能会因达到这个限制而发生错误
> + 在删除一个消息队列或信号量对象时，多进程应用程序可能难以确定哪个进程是最后一个需要访问对象的进程，从而导致难以确定何时可以安全地删除对象
> 

#### IPC 对象的删除

各种 System V IPC 机制的 `<IPC>ctl` 系统调用在对象上执行一组控制操作，其中一个操作是 `IPC_RMID` 控制操作，可以用来删除一个对象

```c
if(shmctl(id, IPC_RMID, nullptr) == -1) {
	// 错误处理
}
```

对于消息队列和信号量来讲，IPC 对象的删除是立即生效的，对象中包含的所有信息都会被销毁，不管是否有其他进程仍然在使用该对象。

共享内存对象的删除的操作与消息队列和信号量不同。在 `shmctl(id, IPC_RMID, nullptr)`  调用之后，要等待所有使用该内存段的进程与该内存段分离之后才会删除该共享内存段

> [!summary] 
> 
> 消息队列和信号量的删除是立即生效的，其中包含的信息会被销毁，不管进程是否仍在使用该对象
> 
> 共享内存的删除需要等待所有使用该共享内存的进程与共享内存段分离后才会被删除
> 

## IPC Key

System V **IPC key** 是一个整数值，其数据类型为 `key_t`。`<IPC>get` 调用将一个 `key` 转换成相应的整数 **IPC 标识符**

> [!important] `<IPC>get` 调用能够确保下面两个事情的发生
> 
> + 如果创建的是一个新 IPC 对象，那么对象能够得到一个唯一的标识符
> 
> + 如果指定了一个既有对象的 `key`，那么总是会取得该对象的（同样的）标识符
> 

**那么如何产生 _唯一的 IPC key_ 呢**？即一种 **确保不会偶然地取得其他应用程序所使用的一个既有 IPC 对象的标识符**。有三种解决方法

> [!tip] 随机整数值作为 IPC key
> 
> 将整数值存放在一个头文件中，所有使用该 IPC 对象的程序都需要包含该头文件
> 
> 这个方法的难点在于可能会无意中选取了一个已被另一个应用程序使用的值
> 

> [!tip] 使用 `IPC_PRIVATE` 作为 IPC key
> 
> 在创建 IPC 对象的 `<IPC>get` 调用中将 `IPC_PRIVATE` 常量作为 key 的值
> 
> 缺点就是每个调用都会创建一个全新的 `IPC` 对象，从而确保每个对象都拥有一个唯一的 `key`
> 

> [!tip] 使用 `ftok()` 函数生成一个几乎唯一的 `key`

### IPC_PRIVATE 作为 key

在创建一个新 `IPC` 对象时必须要像下面这样将 `key` 指定为 `IPC_PRIVATE`。无需在 `flags` 中指定 `IPC_CREAT` 和 `IPC_EXCL` 标记

```c
id = msgget(IPC_PRIVATE, S_IRUSR | S_IWUSR);
```

这项技术对于 **父进程在执行 `fork()` 之前创建 IPC 对象从而导致子进程继承 `IPC` 对象标识符** 的多进程应用程序是特别有用的

### ftok() 产生 key

`ftok()`(file to key)函数返回一个适合在后续对某个 System V IPC 对象的 `<IPC>get` 系统调用进行调用时使用的 `key` 值

```c
#include <sys/ipc.h>

key_t ftok(char *pathname， int proj);
/* 成功返回 key; 错误返回 -1*/
```

`key` 值是使用实现定义的算法 **根据提供的 `pathname` 和 `proj` 值生成的**

> [!tip] 参数 `pathnae`：指定一个既有文件并且可以应用 `stat()` 系统调用
> 
> 注意 `ftok()` 使用 $\text{i-node}$ 号来生成 IPC key，而不是使用 `pathname`

> [!tip] 参数 `proj`
> 
> 生成 IPC key 的算法只使用 `proj` 的最低 $8$ 位。目的仅仅是允许从同一个 $\text{i-node}$ 号中生成多个 IPC Key
> 


> [!attention] 相同 $\text{i-node}$ 号的不同 `pathname` 和 相同的 `proj` 值，生成的 IPC key 也必须相同 
> 
> 也就是说，函数 `ftok()` 使用一个 **文件的真实路径名** 或 **符号链接路径名** 与同一个 `proj` 值作为参数 ，其返回值是相同的
> 

> [!tip] 返回值：在 `Linux` 上，`ftok()`返回的 `key` 是一个 $32$ 位的值，它包含
> 
> + `proj` 参数的最低 `8` 个有效位
> + 文件所在的文件系统的设备的设备号的最低 $8$ 位，即 **次要设备号的最低 $8$ 位**
> + 文件的 $\text{i-node}$ 号的最低 $16$ 位
> 
> 设备号和 $\text{i-node}$ 号通过 `stat()` 获取
> 

## IPC 对象关联数据结构和权限

内核为 System V IPC 对象的每个实例都维护着一个 **关联数据结构**。这个数据结构的形式因 IPC 机制的不同而不同。后续在详细讨论关联数据结构

一个 IPC 对象的关联数据结构会在通过相应的 `<IPC>get` 系统调用创建对象时进行初始化。对象一旦被创建之后，程序就可以通过指定 `IPC_STAT` 操作类型使用合适的 `<IPC>ctl` 系统调用来获取这个数据结构的一个副本。使用 `IPC_SET` 操作能够修改这个数据结构中的部分数据

除了各种 IPC 对象特有的数据之外，所有 System V IPC 机制的关联数据结构都包含一个子结构 `ipc_perm`，它保存了用于确定对象之上的 **权限** 的信息

```c
struct ipc_perm
{
  key_t __key;				    /* IPC Key.  */
  uid_t uid;					/* Owner's user ID. 属主 */
  gid_t gid;					/* Owner's group ID. 属组 */
  uid_t cuid;					/* Creator's user ID. 创建者 UID */
  gid_t cgid;					/* Creator's group ID. 创建者 GID */
  mode_t mode;				/* Read/write permission.  读写权限 */
  unsigned short int __seq;			/* Sequence number. 序号 */
};
```

最开始用户与和创建者 ID 是相同的，其中 创建者 ID 是不变的，用户 ID 是可以通过 `IPC_SET` 修改

```c
struct shmid_ds shmds;  // shmid_ds 是共享内存对象的描述符

if(shmctl(id, IPC_STAT, &shmod) == -1)
{
	// 错误处理
}

shmds.shm_perm.uid = newuid;
if(shmctl(id, IPC_SET, &shmod) == -1)
{
	// 错误处理
}
```

IPC 对象的权限与文件权限类似，只不过执行权限对于 IPC 对象是没有意义的


## IPC get 使用的算法

下图为内核内部使用的一些表示 System V IPC 对象的相关数据结构，以信号量为例

![Pasted image 20241106221650|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755783115014-9b1d71b8dcf744b6950616700d6957f2.png)

对于每种 IPC 机制，内核都会维护一个 `<ipc>_ids` 结构，它记录着该 IPC 机制的所有实例的各种 **全局信息**，包括一个大小会动态变化的指针数组 `entries`，数组中的每个元素指向一个对象实例的 **关联数据结构**（在信号量中是 `semid_ds` 结构）。`entries` 数组的当前大小记录在 `size` 字段中，`max_id` 字段记录着当前使用中的元素的最大下标

> [!tip] `<ipc>_ids` 结构：IPC 机制的全局信息
> 
> `entries` 数组：大小动态变化的数组，其中的元素是一个指向 `<ipc>id_ds` 结构的指针
> + `<ipc>id_ds` 是 IPC 工具的关联数据结构
> 
> `max_id` 字段：当前 `entries` 数组中最大的元素下标
> 
> `in_use` 字段：当前 `entries` 数组中被使用的个数
> 
> `size` 字段：`entries` 数组的大小
> 

在执行一个 `<IPC>get` 调用时，Linux 所采用的算法近似如下（其他系统使用了类似的算法）

> [!tip] 第一步：在 `<ipc>_ids` 的 `entries` 字段中搜索 `<ipc>id_ds` 中`<ipc>_perm.__key` 字段与 `<IPC>get` 调用中指定 `key` 匹配的结构
> + 如果没有找到匹配的结构并且没有指定 `IPC_CREAT`，那么返回 `ENOENT` 错误
> + 如果找到了一个匹配的结构，但同时指定了 `IPC_CREAT` 和 `IPC_EXCL`，那么返回`EEXIST` 错误
> + 否则在找到一个匹配的结构的情况下跳过下面的步骤
> 

> [!tip] 第二步：没找到指定 `key`  的 `<ipc>id_ds` 结构，分配全新的 `<ipc>id_ds` 结构并初始化
> 在这个操作中还会更新 `<ipc>_ids` 结构中的各个字段，并且可能还会重新设定 `entries` 数组的大小，指向新结构的指针会被放在 `entries` 中 **第一个未被占用的位置处**
> 
> 在这个初始化的过程中包含两个子步骤
> 
> +  传递给 `get` 调用的 `key` 值被复制到新分配的结构的 `<ipc>_perm.__key` 字段中
> + `<ipc>_ids` 结构中 `seq` 字段的当前值被复制到关联数据结构的 `xxx_perm.__seq` 字段中，将 `seq` 字段的值加 $1$
> 

> [!tip] 第三步：计算 IPC 对象的标识符
>  使用下面的公式计算 IPC 对象的标识符
>  
>  `<ipc>_identifier ::= index + <ipc>_perm.__seq * SEQ_MULTIPLIER`
>  + `index` 表示对象实例在 `entries` 数组中的下标
>  + `SEQ_MULTIPLIER` 是一个值为 `32768` 的常数
>  
> 上图中 `key = 0x4b079002 `的信号量生成的标识符为 `(2 + 5 * 32768) = 163842`
> 

## ipc 命名

`ipcs` 和 `ipcrm` 命令是 System V IPC 领域中类似于 `ls` 和 `rm` 文件命令的命令

使用 `ipcs` 能够获取系统上 IPC 对象的信息。在默认情况下，`ipcs` 会显示出所有对象。

使用 `ipcrm` 可以删除一个 IPC 对象。有两种形式

```shell
ipcrm [options] key/ID

ipcrm [shm|msg|sem] ID ...
```
