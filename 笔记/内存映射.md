# 内存映射

没有与 **物理地址** 建立映射关系的虚拟地址属于无效的虚拟地址，引发 **段错误** ^[[[虚拟内存#Linux 虚拟内存系统#缺页异常处理]]] 。通过调用 `mmap()` 系统调用可以将虚拟内存地址和物理地址之间建立映射关系

> [!tip] 
> 
> 这里的物理地址可以是 **主存的地址**，也可以是 **磁盘上的文件**
> 

`mmap()` 系统调用在调用进程的虚拟地址空间中创建一个新内存映射。映射分为两种 ^[[[虚拟内存#内存映射]]]：**文件映射** 和 **匿名映射**

> [!tip] 
> 
>文件映射将 **文件的一部分直接映射到调用进程的虚拟内存中**
>
>+ 文件被映射之后就可以通过在相应的内存区域中操作字节来访问文件内容了
>
> 映射的分页会 **在需要的时候从文件中 自动 加载**。这种映射也被称为 **基于文件的映射** 或 **内存映射文件**
>

> [!tip] 
> 
> 匿名映射 **没有对应的文件**。相反，这种映射的分页会被初始化为 $0$
> 

一个进程的映射中的内存可以与其他进程中的映射共享 (即各个进程的页表条目指向 DRAM 中相同分页)

> [!tip] 
> 
> 当两个进程映射了 **同一个文件的同一个区域** 时它们会共享物理内存的相同分页
> 
> 通过 **`fork()` 创建的子进程会继承其父进程的映射的副本**，并且这些映射所引用的物理内存分页与父进程中相应映射所引用的分页相同
> 

当两个或更多个进程共享相同分页时，每个进程都有可能会看到其他进程对分页内容做出的变更

![[Pasted image 20241028231159.png]]

> [!tip] 
> 
> 当然进程能否看到其他进程对映射分页的变更取决于映射是 **私有** 的还是 **共享** 的
> 
> **私有映射**（`MAP_PRIVATE`）：在映射内容上发生的 **变更对其他进程不可见**
> +  对于文件映射来讲，**变更将不会在底层文件上进行**。对映射内容所做出的变更对各个进程来讲则是私有的，内核使用了 **写时复制**（copy-on-write）技术完成了这个任务
> + **写时复制**：当一个进程试图修改一个分页的内容时，内核首先会为该进程创建一个新分页并将需 修改的分页中的内容复制到新分页中（以及调整进程的页表）
> 
> **共享映射**（`MAP_SHARED`）：在映射内容上发生的 **变更对所有共享同一个映射的其他进程都可见**，对于文件映射来讲，**变更将会发生在底层的文件上**
> 

**文件映射、匿名映射** 和 **私有映射、共享映射** 可以有四种方式加以组合

![[Pasted image 20241028231534.png]]

这四种不同的内存映射的创建和使用方式如下所述

|    内存映射    | 创建                           | 备注                                                            |
| :--------: | :--------------------------- | ------------------------------------------------------------- |
| **私有文件映射** | 映射的内容被初始化为一个文件区域中的内容         | 多个映射同一个文件的进程初始时会共享同样的内存物理分页。**写时复制技术** 使得多个进程之间对同一个文件映射的变更不可见 |
| **私有匿名映射** | 每次创建私有匿名映射都会产生一个新映射          | 无论是同一个进程还是不同的进程创建的其他匿名映射是不同的，不会共享物理分页。`fork()` 后会执行写时复制       |
| **共享文件映射** | 所有映射一个文件的同一区域的进程会共享同样的内存物理分页 | 对映射内容的修改将直接在文件中进行。两种用途：**允许内存映射 I/O** 和 **允许无关进程共享一块内容**      |
| **共享匿名映射** | 与私有匿名映射一样                    | 差别在于映射的分页不会被写时复制。子进程在 `fork()` 之后继承映射时，父进程和子进程共享同样的 `RAM` 分页  |

## 创建映射

系统调用 `mmap()` 在调用进程的虚拟地址空间中创建一个新映射

```c
#include <sys/mman.h>

void *mmap(void *vaddr, size_t length, int prot, int flags, int fd, off_t offset);
/* 成功返回起始的虚拟地址；失败返回 MAP_FAILED */
```

> [!tip] 参数 `vaddr`：映射被放置的虚拟地址
> 
> 通常该参数指定为 `NULL`，让内核自动选择虚拟地址
> 
> 如果不为 `NULL`，内存将他作为参考值，舍入到最近的一个分页边界
> 

> [!tip] 参数 `length`：映射的字节数
> 
> 内核自动将字节数调整为大于 `length` 的最小系统分页的倍数。分页大小: `sysconf(_SC_PAGESIZE)`
> 

> [!tip] 参数 `prot`：施加于映射之上的保护信息
> 
> 参数值有下表给出。如果一个进程在访问一个内存区域时违反了该区域上的保护位，那么内核会向该进程发 送一个 `SIGSEGV` 信号 ^[[[信号]]]
> 
> 标记为 `PROT_NONE` 的分页内存的一个用途是作为一个进程分配的内存区域的起始位置或结束位置的 **守护分页**。进程意外访问量守护分页，内存会发生 `SIGSEGV` 信号通知进程
> 
> 系统调用 `mprotect()` 可以修改内存保护位
> 

|    `prot`     | 解释      | 备注                      |
| :-----------: | :------ | :---------------------- |
| ``PROT_NONE`` | 区域无法访问  | 要么取该值，要么时下面三个值的 **按位或** |
|  `PROT_READ`  | 区域内容可读取 |                         |
| `PROT_WRITE`  | 区域内容可修改 |                         |
|  `PROT_EXEC`  | 区域内容可执行 |                         |

> [!tip] 参数 `flags`：指定创建映射的类型和其他标志
> 
> `MAP_ANONYMOUS` 匿名映射
> 
> `MAP_PRIVATE` 私有映射；`MAP_SHARED` 共享映射
> 
> `MAP_HUGETLB` 映射巨大的页
> 
> `MAP_LOCKED` 映射分页锁定到物理内存，参加 [[虚拟内存操作#内存锁]]
> 
> `MAP_NORESERVE` 控制是否提前为映射的交换空间执行预留操作
> 
> `MAP_POPULATE` 充一个映射的分页，对于文件映射来讲，这将会在文件上执行一个超前读取
> 
> `MAP_UNINITIALIZED` 防止一个匿名映射被清零
> 

> [!tip] 参数 `fd`：标识被映射的文件的文件描述符

> [!tip] 参数 `offset`：映射在文件中的起点

> [!tip] 返回值
> 
> 成功时 `mmap()` 会返回新映射的起始地址
> 
> 发生错误时 `mmap()` 会返回 `MAP_FAILED`
> 

## 解除映射区域

`munmap()` 系统调用执行与 `mmap()` 相反的操作，即从调用进程的虚拟地址空间中删除一个 映射

```c
#include <sys/mman.h>

int munmap(void *addr, size_t length);
/* 成功返回 0；失败返回 -1 */
```

> [!tip] 参数 `addr`：待解除映射的起始虚拟地址
> 
> 该参数通过是 `mmap()` 系统调用的返回值
> 

> [!tip] 参数 `length`：待解除映射区域的字节数
> 
> 系统分页大小的下一个倍数的地址空间将会被解除映射
> 

**一般来讲通常会解除整个映射**。因此可以将 `addr` 指定为上一个 `mmap()` 调用返回的地址， 并且 `length` 的值与 `mmap()` 调用中使用的 `length` 的值一样

```c
addr = mmap(NULL, lenght, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);
if(addr == MAP_FAILED)
{
	// 错误处理
}

if(munmap(addr, lenght) == -1)
{
	// 错误处理
}
```

## 文件映射


要创建一个文件映射需要执行下面的步骤

> [!tip] 
> 首先，获取文件描述符，通常通过 `open()` 来完成
> 
> 然后，将文件描述符作为 `mmap()` 的 `fd` 参数。文件映射完成后，可以立即关闭文件，并不会对映射产生任何影响。但是，我们通常让文件描述符保存打开状态
> 
> 最后，解除文件映射
> 

执行上述步骤之后 `mmap()` 会将打开的文件的内容映射到调用进程的地址空间中。**一旦 `mmap()` 被调用之后就能够关闭文件描述符了，而不会对映射产生任何影响**。但在一些情况下，将这个文件描述符保持在打开状态可能是有用的

`offset` 参数指定了 **从文件区域中的哪个字节开始映射**，它必须是 **系统分页大小的倍数**。将 `offset` 指定为 $0$ 会导致从文件的起始位置开始映射

`length` 参数指定了 **映射的字节数**。`offset` 和 `length` 参数一起确定了文件的哪个区域会被映射进内存

![[Pasted image 20241028234248.png]]

> [!tip] 
> 
> 在 Linux 上，**一个文件映射的分页会在首次被访问时被映射进内存**。这意味着如果在 `mmap()` 调用之后修改文件区域，但是映射的对应分页还没有被访问，那么如果相应的分页还没有加载进内存的话，变更对这个进程是否可见依赖于具体实现
> 
> 应当尽量避免这种场景
> 

### 私有文件映射


私有文件映射最常见的两个用途

- 允许多个执行同一个程序或使用同一个共享库的进程共享同样的（只读的）文本段， 它是从底层可执行文件或库文件的相应部分映射而来的
- 映射一个可执行文件或共享库的初始化数据段。这种映射会被处理成私有使得对映射数据段内容的变更不会发生在底层文件上

`mmap()` 的这两种用法通常 **对程序是不可见的**，因为这些映射是由程序加载器和动态链接器创建的
- `/proc/PID/maps` 的输出中发现这两种映射

下面是使用私有文件映射的一个例子：使用文件映射实现 `cat` 命令

```c title:mmap/mmcat.c

#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

#include "base.h"

int main(int argc, char *argv[]) {

    if(argc != 2 || strcmp(argv[1], "--help") == 0) {
        usageErr("%s <pathname>", argv[0]);
    }

    int fd = open(argv[1], O_RDONLY);
    if(fd == -1) {
        errExit("open error");
    }

    struct stat st;
    if(fstat(fd, &st) == -1) {
        errExit("fstat error");
    }

    char *addr = mmap(nullptr, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
    if(addr == MAP_FAILED) {
        errExit("mmap error");
    }

    // 建立完映射就可以关闭文件
    close(fd);

    if(write(STDOUT_FILENO, addr, st.st_size) != st.st_size) {
        errExit("write error");
    }

    munmap(addr, st.st_size);

    return 0;
}
```

### 共享文件映射

当多个进程创建了同一个文件区域的 **共享映射** 时，它们会 **共享同样的内存物理分页**。此 外，**对映射内容的变更将会反应到文件上**。实际上，这个文件被当成了该块内存区域的分页 存储

![[Pasted image 20241028234857.png]]

共享文件映射存在两个用途：**内存映射 I/O** 和 **IPC** ^[[[IPC介绍]]]。目前，我们只介绍 **内存映射 IO**
 
由于共享文件映射中的内容是从文件初始化而来的，并且对映射内容所做出的变更都会自动反应到文件上，因此可以 **简单地通过访问内存中的字节来执行文件 I/O**，而依靠 **内核来确保对内存的变更会被传递到映射文件中**。

 > [!tip] 
 > 
 > 一般来讲，一个程序会定义一个结构化数据类型来与磁盘文件中的内容对应起来，然后使用该数据类型来转换映射的内容
 > 

这项技术被称为 **内存映射 I/O**，它是使用 `read()` 和 `write()` 来访问文件内容这种方法的替代方案

> [!tip] 内存映射 I/O 的优势
> 
> + 使用内存访问来取代 `read()` 和 `write()` 系统调用能够 **简化一些应用程序的逻辑**
> 
> + 它能够比使用传统的 I/O 系统调用执行文件 I/O 这种做法 **提供更好的性能**
> 

内存映射 I/O 之所以能够带来性能优势的原因如下

正常的 `read() `或 `write()` 需要两次传输：一次在文件和内核高速缓冲区之间，另一次是在高速缓冲区和用户空间缓冲区之间。**使用 `mmap()` 就无需第二次传输了**
- 对于输入来讲，一旦内核将相应的文件块映射进内存之后用户进程就能够使用这些数据了
- 对于输出来讲，用户进程仅仅需要修改内存中的内容，然后可以依靠内核内存管理器来自动更新底层的文件

除了节省了内核空间和用户空间之间的一次传输之外，**`mmap()` 还能够通过减少所需使用的内存来提升性能**
- 当使用 `read()` 或 `write()` 时，数据将被保存在两个缓冲区中：一个位于用户空间，另一个位于内核空间。**当使用 `mmap()` 时，内核空间和用户空间会共享同一个缓冲区**
- 此外，如果多个进程正在在同一个文件上执行 I/O，那么它们通过使用 `mmap()` 就能够共享同一个内核缓冲区，从而又能够节省内存的消耗

### 边界情况

在很多情况下，一个映射的大小是系统分页大小的整数倍，并且映射会完全落入映射文件的范围之内。但这种要求不是必需的，下面来看一下当这些条件不满足时会发生什么事情

下图描绘了 **映射完全落入映射文件的范围之内** 但区域的大小并不是系统分页大小的一个整数倍的情况。这里 **假设分页大小为 4096 字节**

![[Pasted image 20241028235721.png]]

由于映射的大小不是系统分页大小的整数倍，因此它会被向上舍入到系统分页大小的下一个整数倍。由于文件的大小要大于这个被向上舍入的大小因此文件中对应字节会像上图中那样被映射

试图访问映射结尾之外的字节将会导致 `SIGSEGV` 信号的产生（假设在该位置处不存在其他映射）。这个信号的默认动作是终止进程并打印出一个 `core dump`

下图描绘了 **当映射扩充过了底层文件的结尾处** 时情况，此时问题更加复杂了

![[Pasted image 20241028235900.png]]

与之前一样，由于映射的大小不是系统分页大小的整数倍，因此它会被向上舍入。但在这种情况下，虽然在 **向上舍入区域（即图中 $2200$ 字节和 $4095$ 字节）中的字节是可访问的，但它们不会被映射到底层文件上**（由于在文件中不存在对应的字节），并且它们会被初始化为 $0$（SUSv3 对此进行了规定）

> [!tip] 
> 
> 当然，这 些 **字节也不会与映射同一个文件的其他进程共享**，即使它们指定了足够大的 `length` 参数。**对这些字节做出的变更不会被写入到文件中**。
> 

如果映射中包含了超出向上舍入区域中（即上图中 $4096$ 以及之后的字节）的分页，那么试图访问这些分页中的地址将会导致 `SIGBUS` 信号量的产生，即警告进程文件中没有区域与这些地址对应。与之前一样，试图访问超过映射结尾处的地址将会导致 `SIGSEGV` 信号的产生

创建一个大小超过底层文件大小的映射可能是无意义的。但通过**扩展文件的大小（如使用 `ftruncate()` 或 `write()`），可以使得这种映射中之前不可访问的部分变得可用**

### 内存保护和文件访问模式交互

从一般原则来讲，`PROT_READ` 和 `PROT_EXEC` 保护要求被映射的文件使用 `O_RDONLY` 或 `O_RDWR` 打开，而 `PROT_WRITE` 保护要求被映射的文件使用 `O_WRONLY` 或 `O_RDWR` 打开

| `mmap() prot` |     `open() flag`     |
| :-----------: | :-------------------: |
|  `PROT_READ`  | `O_RDONLY`或 `O_RDWR`  |
|  `PROT_EXEC`  | `O_RDONLY`或 `O_RDWR`  |
| `PROT_WRITE`  | `O_WRONLY` 或 `O_RDWR` |

### 同步映射区域

**内核会自动将发生在 `MAP_SHARED` 映射内容上的变更写入到底层文件中**，但在默认情况下，内核 **不保证这种同步操作会在何时发生**

`msync()` 系统调用让应用程序能够显式地控制何时完成共享映射与映射文件之间的同步

```c
#include <sys/mman.h>

int mysnc(void *vaddr, size_t length, int flags);
/*成功返回 0；失败返回 -1*/
```

`vaddr` 和 `lenght` 指定了需同步的内存区域的起始地址和大小

`flags` 参数的可取值为下列值中的一个

|     `flags`     | 解释           | 备注                                                       |
| :-------------: | :----------- | :------------------------------------------------------- |
|    `MS_SYNC`    | 同步的文件写入      | 会阻塞直到内存区域中所有被修改过的分页被写入到底层文件为止                            |
|   `MS_ASYNC`    | 异步的文件写入      | 内存区域中被修改过的分页会在后面某个时刻被写入磁盘并立即对在相应文件区域中执行 `read()` 的其他进程可见 |
| `MS_INVALIDATE` | 使映射数据的缓存副本失效 | 所有被修改过的分页被同步到文件中之后，内存区域中所有与底层文件不一致的分页会被标记为无效             |
同步一个映射与底层文件在多种情况下都是非常有用的。如，为确保数据完整性，一个数据库应用程序可能会调用 `msync()` 强制将数据写入到磁盘上。调用 `msync()` 还允许一个应用程序确保在可写入映射上发生的更新会对在该文件上执行 `read()` 的其他进程可见

## 匿名映射

**匿名映射是没有对应文件的一种映射**

在 Linux 上，**使用 mmap()创建匿名映射存在两种不同但等价的方法**

|               方法               | 备注                                 |
| :----------------------------: | :--------------------------------- |
| `flags=MAP_ANONYMOUS`, `fd=-1` | Linux：指定 `MAP_ANONYMOUS` 自动忽略 `fd` |
|          `/dev/zero`           | 使用打开 `/dev/zero` 文件获得的文件描述符        |

`MAP_PRIVATE` 匿名映射用来分配进程私有的内存块并将其中的内容初始化为 `0`。下面的代码使用 `/dev/zero` 技术创建了一个 `MAP_PRIVATE` 匿名映射

```c
fd = open("/dev/zero", O_RDWR);
if(fd == -1)
{
	// 错误处理
}

addr = mmap(NULL, lenght, PROT_READ | PROT_WRITR, MAP_PRIVATE, fd, 0);
if(addr == MAP_FAILED)
{
	// 错误处理
}
```

`MAP_SHARED` 匿名映射允许相关进程（如父进程和子进程）共享一块内存区域而无需一个对应的映射文件

下面的代码使用 `MAP_ANONYMOUS` 技术创建了一个 `MAP_SHARED` 匿名映射

```c
addr = mmap(NULL, lenght, PROT_READ | PROT_WRITR, MAP_SHARED | MAP_ANONYMOUS, fd, 0);
if(addr == MAP_FAILED)
{
	// 错误处理
}
```

如果在上面的代码之后加上一个对 `fork()` 的调用，那么由于通过 `fork()` 创建的子进程会继承映射，两个进程就会共享内存区域
