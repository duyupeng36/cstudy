# 指针

在 [[计算机组成原理#主存储器]] 中我们介绍过，大多数现代计算机将内存分割为 **字节**，每个字节可以存储 $8$ 位的信息

每个字节都有唯一的 **地址**，用来和内存中的其他字节相区别。如果内存可以存储 $n$ 个字节，那么可以把地址当做 $0 \sim n-1$ 个整数

> [!tip] 
> 
> **地址也是一种数据**
> 

可执行程序(ELF 文件)由 **代码**（原始 C 程序中与语句对应的机器指令）和 **数据**（原始程序中的变量）两部分构成。程序中的每个变量占有一个或多个字节内存，把 **第一个字节的地址** 称为 **变量的地址**

> [!tip] 第一个字节的地址：对象占用的所有字节中，编号最小的地址
> 
> ![[Pasted image 20240926234808.png]]
> 

> [!important] 
> 
> 这就是指针的出处。**地址使用整数表示**，但是 **地址并不等同于整数**。所以，**_不能使用普通的整型变量存储地址_**
> 
> **C 语言中，用 _指针变量_ 存储地址**。也就是说，**指针就是地址**，而指针变量就是存储地址的变量
> 

> [!hint] `p` 指向 `i`
> 
> 当指针变量 `P` 中存储了变量 `i` 的地址时，称 `p` 指向变量 `i` 
> 

## 指针变量

对指针变量的声明与对普通变量的声明基本一样，唯一的不同就是 **必须在 _指针变量名字_ 前放置星号**

```c
int *p; // p 指向 int 类型的对象
```

> [!tip] 
> `int *p` 中的 `int` 指示了通过指针变量 `p` 读取它指向的内存区域时应当读取的字节数，即读取 `sizeof(int)` 个字节。因为，指针只保存了对象的第一个字节的地址
> 

指针变量可以和其他变量一起出现在声明中

```c
int *p, i, j, a[10], *q;
```

在上述声明中 `p` 和 `q` 是指向 `int` 类型对象的指针，`i` 和 `j` 是 `int` 类型的变量，`a` 是数组

> [!tip]
> 
> 变量 `p` 和 `q` 的类型是 `int *`；`i` 和 `j` 的类型是 `int`；`a` 的类型是 `int[10]`
> 
> 在声明语法中 `*` 优先和变量名结合，而不是和类型结合
> 


> [!attention] 
> 
> C 标准要求每个 **指针变量只能指向一种特定类型的对象**。指针能指向任何类型的对象
> 
> 也就是说，指针甚至可以指向另一个指针，即指向指针的指针
> 

## 取值地址和解引用运算

为了获取一个变量的地址，需要使用 **取地址运算符**(`&`)。如果 `x` 是变量，那么 `&x` 就是 `x` 在内存中的地址

为了获得对指针所指向对象的访问，可以使用 **解引用运算符**(`*`)。如果 `p` 是指针，那么 `*p` 表示 `p` 当前指向的对象

### 指针变量初始化

声明指针变量是为指针留出空间，但是并没有把它指向对象

```c
int *p;
```

> [!tip]
> 
> `p` 指向了一个未知的内存空间。**在使用指针变量 `p` 之前进行初始化是非常重要的**
> 

**一种初始化指针变量的方法是使用 `&` 运算符把某个变量的地址赋给它**

```c
int i, *p;

p = &i;
```

![[Pasted image 20240927160423.png]]

在声明指针变量的同时对它进行初始化是可行的

```c
int i;
int *p = &i;
```

> [!danger] 
> 
> 指针变量的初始化不能使用一个整数字面值进行初始化，因为这会导致悬空指针问题
> 

```c
int *p = 0x75; // Danger 0x75 指向的内存空间可能不受程序控制
```

### 通过指针访问对象内容

一旦指针变量指向了对象，就可以使用 **解引用运算符**(`*`) 访问存储在对象中的内容

如果指针变量 `p` 指向了 `int` 类型变量 `i`，那么通过 `*p` 就能读取到 `i` 的值

```c
printf("%d\n", *p);
```

> [!tip] `&` 和 `*` 互为逆运算
> 

```c
j = *&i; // 等价于 j = i;
```

> [!tip] 
>
> 指针变量 `p` 指向了某个对象 `i`，那么 `*p` 就是 `i` 的 **别名**
> + `*p` 拥有和 `i` 相同的值
> + 对 `*p` 的改变也会改变的 `i` 值
>   
>`*p` 是左值，所以对它赋值是合法的
>


```c
#include <stdio.h>


int main() {

    int i;
    int *p = &i;
    printf("%d\n", *p);  // 开始是一个随机的值
    i = 10; // 对 i 赋值
    printf("%d\n", *p); 
    *p = 100;
    printf("%d\n", *p);
}
```

![[Pasted image 20240927161535.png]]

> [!tip] 直接访问和间接访问
> 
> 使用对象的名字访问对象的内容，称为直接访问
> 
> 通过对象的指针访问对象的内容，称为间接访问
> 

## 指针赋值

**C 语言允许使用赋值运算符进行指针的复制**，前提是两个指针具有相同的类型

假设 `i` `j` `p` 和 `q` 声明如下

```c
int i, j, *p, *q;

p = &i; // 把 i 的地址赋值给 p

q = &j; // 把 j 的地址赋值给 q

q = p; // 把 p 的值复制给 q
```

上述三条语句的执行过程如下图

![[Pasted image 20240927185738.png]]

现在，使用 `*p` 或者 `*q` 都能修改变量 `j` 的值

> [!hint] 
> 
> 任意数量的指针变量都可以指向同一个对象
> 

### 悬空指针

**悬空指针变量**：指向未分配给进程的内存空间。即，**指向未知的内存区域**

> [!attention] 
> 
> 一个未初始化的指针变量是悬空的，即，**指向未知的内存空间**
> 
> 访问未知的内存空间会导致未定义的行为
> 

```c
int *p; // p 未初始化

printf("%d", *p); // 未定义行为
```

> [!danger] 
> 
> 更危险的操作就是对未初始化的指针变量指向的内存进行赋值。
> 

```c
int *p; // p 未初始化，它的值是未知的

*p = 1; 
```

如果上述赋值改变的内存单元属于该程序，那么可能会导致出乎意料的行为；如果改变的内存单元属于操作系统，那么很可能会导致系统崩溃

造成指针变量悬空的原因有很多。例如，**指向的内存区域被释放** ^[[[指针高级]]]；**函数返回局部变量的地址**

### 空指针

**空指针变量** ：指向 **零地址** 的内存空间。**零地址** 是一个特殊的地址，进程不能使用这个地址

C 语言使用 `NULL` 宏表示零地址。`NULL` 宏在 `<stddef.h>` 头文件中的定义如下

```c
#define NULL ((void *)0)
```

> [!important] nullptr
> 
> C23 标准新增了一个 `nullptr` 关键字，用于表示 **空指针变量的值**。其类型为 `nullptr_t`

```c
int *p = NULL; // C23 之前
int *q = nullptr; // C23 开始
```

## 指针的应用

C 语言中指针的应用有多种。这里，我们先介绍两个比较简单的应用：作为函数的参数和返回值

### 指针作为实参

C 语言的实参式 **值传递** 的，所以在函数调用中用作实际参数的变量无法改变。当希望函数能够改变变量时，C 语言的这种特性就很讨厌了

> [!example] 
> 例如，在 [[函数#实际参数#值传递]] 中编写的 `swap` 函数，它试图交换两个实参的值，但是它失败了
> 

指针提供了此问题的解决方法：不再传递变量 `a` 和 `b` 作为函数的实际参数，而是提供 `&a` 和 `&b`

> [!hint] 
> 
> 声明相应的形式参数 `p` 和 `q` 为指针。调用函数时，`p` 的值为 `&a` ，因此 `*p`(`p` 指向的对象）将是 `a` 的别名；`q` 的值为 `&b`，因此 `*q` 将会是 `b` 的别名。函数体内 `*p` 和 `*q` 的每次出现都将是对 `a` 和 `b` 的间接引用，而且函数既可以读取 `a` 和 `b` 也可以修改 `a` 和 `b`。

```c
#include <math.h>
#include <stdio.h>


void swap(int *p, int *q) {
    const int temp = *p;
    *p = *q;
    *q = temp;
}

int main() {

    int a = 10, b = 20;
    printf("交换之前：a = %d, b = %d\n", a, b);  // a = 10, b = 20
    swap(&a, &b);
    printf("交换之后：a = %d, b = %d\n", a, b);  // a = 20, b = 10

    return 0;
}
```

![[Pasted image 20240927190519.png]]

> [!attention] 
> 
> 注意，在调用 `swap` 时，实参传递的时 `&a` 和 `&b`。如果调用时没有在 `a` 和 `b` 之前加上 `&` 运算符
> 
> ```c
> swap(a,b);
>```
>
>`swap` 函数期望接收两个指针，传入的确实 `a` 和 `b` 的值。由于 `swap` 无法区分，所以它将 `a` 和 `b` 的值当作指针使用。从而引起向未知内存区域赋值的操作
>

#### `const` 保护参数

如果需要函数不要修改传入的指针指向的对象，在声明时应该使用 `const` 加以限制

```c
void f(const int *p)
{
	// 函数内部不能修改 *p 的值
}
```

### 指针作为返回值

**指针也可以作为函数的返回值**。并且返回指针的函数是相对普遍的，在 [[字符串]] 中我们就会遇到此类函数

例如，当给定指向两个整数的指针时，下列函数返回指向两个整数中较大数的指针

```c
int *max(const int *a, const int *b)
{
	if(*a > *b)
	{
		return a;
	}
	
	return b;
}
```

> [!warning] 
> 
> **永远不要返回指向 _自动局部变量_ 的指针**
> 
> ```c
> int *f()
> {
> 	int i;
> 	// ...
> 	return &i;
> }
> ```
> 
> 一旦 `f` 返回，变量 `i` 就不存在了，所以指向变量 `i` 的指针将是无效的(悬空指针)
> 
