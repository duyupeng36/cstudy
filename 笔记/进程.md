# 进程

下面我们关注进程的结构和进程虚拟内存的布局，同时考察一些进程属性

## 进程和程序

在 [[进程概念]] 中，我们知道 **进程** 是一个 **可执行程序** 的实例

> [!tip] 
> 
> **可执行程序** 是包含了一系列信息的 **文件**；这些信息 **描述了如何在运行时创建进程**。可执行程序中包含了下列内容
> 
> **二进制格式标识**：每个程序文件都包含用于描述可执行文件格式的元信息，内核利用此信息来解释文件中的其他信息。现代 UNIX/Linux 实现采用 **可执行链接格式**(Executable and Linkable Format，**ELF**)
> 
> **机器语言指令**：对程序算法进行编码，参考 [[程序编码与数据格式]] [[访问信息]] [[算术和逻辑操作]] [[控制]] [[过程]] [[浮点代码]]
> 
> **程序入口地址**：标识程序开始执行时的起始指令位置
> 
> **数据**：程序文件包含的 **变量初始值** 和程序使用的 **字面常量值**（比如字符串）
> 
> **符号表及重定位表**：描述程序中函数和变量的位置及名称。这些表格有多种用途，其中包括调试和运行时的符号解析（动态链接）
> 
> **共享库和动态链接信息**：程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以及加载共享库的动态链接器的路径名
> 
> **其他信息**：程序文件还包含许多其他信息，用以描述如何创建进程
> 

显然，一个程序可以创建许多进程，反过来许多进程可以是同一程序

在内核眼中，**进程是由内核定义的抽象的实体**，并为该实体分配用以执行程序的各项系统资源

> [!WARNING] 内核眼中的进程
> 
> 
> 从内核角度看，进程由 **用户内存空间** 和 **一系列内核数据结构** 组成
> - 用户内存空间 包含了 **程序代码** 及 **代码所使用的变量**
> - 内核数据结构则用于维护进程状态信息：记录在内核数据结构中的信息包括
> 	- **与进程相关的标识号(IDs)**
> 	- **虚拟内存表**
> 	- **打开文件的描述符表**
> 	- **信号传递**及处理的有关信息
> 	- **进程资源使用及限制**
> 	- **当前工作目录**
> 	- **其他信息**
> 
## 进程号 和 父进程号

**每个进程都有一个进程号(PID)**，进程号是 **一个正数**，用以 **唯一标识系统中的某个进程**。对各种系统调用而言，进程号有时可以作为传入参数，有时可以作为返回值

> [!example] 
> 
> 系统调用 `kill()` 允许调用者向拥有特定进程号的进程发送一个信号
> 
> 需要创建一个对某进程而言唯一的标识符时，进程号就会派上用场。常见的例子是将进程号作为与进程相关文件名的一部分
> 

系统调用 `getpid()` 返回调用进程的进程号

```c
#include <unistd.h>

pid_t getpid(void);
/*总是成功的返回当前进程的 ID*/
```

`getpid()` 返回值的数据类型为 `pid_t`，这是一个整数类型，专用于存储进程号

> [!tip] 
> 
> 程序与运行该程序进程的进程号之间没有固定关系
> 

**Linux 内核限制进程号需小于等于 $32767$**。新进程创建时，内核会按顺序将下一个可用的进程号分配给其使用。每当进程号达到 $32767$ 的限制时，内核将重置进程号计数器，以便从小整数开始分配

> [!WARNING] 
> 一旦进程号达到 $32767$，会将进程号计数器重置为 $300$，而不是 $1$。之所以如此，是因为 **低数值的进程号为系统进程和守护进程所长期占用**，在此范围内搜索尚未使用的进程号只会是浪费时间
> 
> 在 Linux2.4 版本及更早版本中，进程号的上限 $32767$，由内核常量 `PID_MAX` 所定义
> 
> 在 Linux 2.6 版本中，情况有所改变。尽管进程号的默认上限仍是 $32767$，但可以通过 Linux 系统特有的 `/proc/sys/kernel/pid_max` 文件来进行调整（其值=最大进程号+1）
> + 在 $32$ 位平台中，`PID_MAX` 文件的最大值为 $32768$
> + 在 $64$ 位平台中，该文件的最大值可以高达到 $2^{22}$（约 $400$ 万），系统可能容纳的进程数量会非常庞大
> 

**每个进程都有一个创建自己的父进程**。使用系统调用 `getppid()` 可以检索到 **父进程的进程号**

```c
#include <unistd.h>

pid_t getppid(void);
/*总是成功的返回当前进程的父进程 ID*/
```

每个进程的父进程号属性反映了系统上所有进程间的树状关系。每个进程的父进程又有自己的父进程，以此类推，回溯到 **$1$ 号进程: `init `进程**，即所有进程的始祖

> [!tip] 
> 
> `pstree` 命令可以查看进程树
> 

如果子进程的父进程终止，则子进程就会变成 **“孤儿”**，**`init` 进程随即将收养该进程**，子进程后续对 `getppid()` 的调用将返回进程号 `1`

> [!tip] 
> 
> 现代 Linux 系统中，`systemd` 取代了传统的 `init` 作为系统和服务管理器。`systemd` 同样负责管理孤儿进程，并通过它的子系统进行更高效的资源管理。
> 

通过查看由 Linux 系统所特有的 `/proc/PID/status` 文件所提供的 `PPid` 字段，可以获知每个进程的父进程

## 进程内存布局

每个进程所分配的内存由很多部分组成，通常称之为 **段** 或者 **区域** ^[[[虚拟内存]]] 。如下所示

![[Pasted image 20241013130418.png]]

> [!tip] 文本段：包含了进程执行的 **机器指令**
> 
>  文本段具有 **只读属性**：防止进程通过错误指针意外修改自身指令
> 
> **多个进程可同时运行同一程序**，所以又将文本段设为 **可共享**，这样，一份程序代码的拷贝可以映射到所有这些进程的虚拟地址空间中
> 

> [!tip] 初始化数据段：包含显式 **初始化** 的全局变量和静态变量
> 
> 当程序加载到内存时，从可执行文件中读取这些变量的值
> 

> [!tip] 未初始化数据段：包含 **未初始化** 的全局变量和静态变量
> 
> 程序启动之前，系统将本段内所有 **内存初始化为 0**。出于历史原因，此段常 **被称为 BSS 段**，这源于老版本的汇编语言助记符“`block started by symbol`”
> 
> 初始化数据和未初始化数据分开存储的原因：程序存储在磁盘上时，没有必要为未经初始化的变量分配存储空间
> 
> 相反，可执行文件只需记录未初始化数据段的位置及所需大小，直到运行时再由程序加载器来分配这一空间
> 

> [!tip] 栈：动态增长和收缩的段
> 
> 栈区由 **栈帧** 组成，系统会为每个当前调用的函数分配一个栈帧。栈帧中存储了函数的局部变量，实参和返回值
> 

 > [!tip] 堆：运行时动态分配的一块内存区域
 > 
 > 堆顶端称作 `program break`（程序中断）
 > 

在大多数 UNIX 实现（包括 Linux）中 C 语言编程环境提供了 $3$ 个全局符号（symbol）：`etext`、`edata`  和 `end`，可在程序内使用这些符号以获取相应程序文本段、 初始化数据段和非初始化数据段结尾处下一字节的地址。使用这些符号，必须显式声明如下

```c
extern char etext, edata, end;
```

上图中十六进制的地址会因内核配置和程序链接选项差异而有所不同。图中标灰的区域表示这些范围在进程虚拟地址空间中不可用，也就是说，没有为这些区域创建页表

## 虚拟内存管理

虚拟内存管理请参考 [[虚拟内存]]

## 栈和栈帧

函数的调用和返回使栈的增长和收缩呈线性 ^[[[过程#转移控制]]]。栈驻留在内存的高端并向下增长

专用寄存器(`%rsp`)：**栈指针**，用于跟踪当前栈顶和专用寄存器(`%rbp`)：**帧指针**，用于跟踪当前栈底。每次调用函数时，会在栈上新分配一帧，每当函数返回时，再从栈上将此帧移去

例如，有下面的一个程序

```c
#include <stdio.h>
#include <stdlib.h>

char globBuf[65536];            /* 1. BSS 未初始化区域*/

int prices[] = {2,3,5,7};       /* 2. DATA 初始化区域*/

static int square(int x)  /* 3. 在 square 的栈帧中分配*/
{
    int result;           /* 4. 在 square 的栈帧中分配 */
    result = x * x; 
    return result;      /* 5. 返回值通过寄存器传递*/
}

static void doCalc(int val)  /* 6. 在 doCalc 的栈帧中分配*/
{
    printf("The square of %d is %d\n", val, square(val));
    if (val < 1000) {
        int t;          /* 7. 在 doCalc 的栈区域中分配 */
        t = val * val * val;
        printf("The cube of %d is %d\n", val, t);
    }
}

int main(int arc, char *argv[]) /* 8. 在 main 的栈帧中分配 */
{
    static int key = 9973;  /* 9. DATA 初始化区域*/
    static char mbuf[10240000]; /* 10. BSS 未初始化区域*/
    char *p;  /* 11. 在 main 的栈帧中分配 */
    p = malloc(1024);  /* 12. 在堆中分配 */
    doCalc(key);
    return 0;
}
```

该程序运行时栈的增长方向为

![[Pasted image 20241023180632.png]]

有时，会用 **用户栈** 来表示此处所讨论的栈，以便与内核栈区分开来。内核栈是每个进程保留在内核内存中的内存区域，在执行系统调用的过程中供（内核）内部函数调用使用

> [!tip] 栈帧中保存的信息
> 
> 函数 **实参** 和 **局部变量**：由于这些变量都是在调用函数时自动创建的，因此在 C 语言中称其为自动变量。函数返回时将自动销毁这些变量，因为栈帧会被释放
> 
> **调用的链接信息**：**每个函数都会用到一些 CPU 寄存器**，比如程序计数器，其指向下一条将要执行的机器语言指令。每当一函数调用另一函数时，**会在 _被调用函数_ 的栈帧中保存这些寄存器的副本**，以便函数返回时能为函数调用者将寄存器恢复原状
> 

因为函数能够嵌套调用，所以栈中可能有多个栈帧。若一函数递归调用自身，则该函数在栈中将有多个栈帧

## 命令行参数

关于命令行参数，参考 [[字符串#命令行参数]]

## 环境列表

每一个进程都有与其相关的称之为 **环境列表** 的字符串数组，或简称为 **环境**。其中每个字符串都以 **名称=值（name=value）** 形式定义。常将列表中的 **名称** 称为 **环境变量**

**新进程在创建之时，会继承其父进程的环境副本**：**环境 提供了将信息从父进程传递给子进程的方法**
- 子进程只有在创建时才能获得其父进程的环境副本，所以这一信息传递是单向的、一次性的
- 子进程创建后，父、子进程均可更改各自的环境变量，且这些变更对对方而言不再可见

### 从程序中访问环境

在 C 语言程序中，可以使用 **全局变量** `char **environ` 访问环境列表。`environ` 与 `argv` 参数类似，指向一个以 `NULL` 结尾的指针列表，每个指针又指向一个以空字节终止的字符串

![[Pasted image 20241023181738.png]]

示例：显示进程环境

第一种方式使用全局变量 `char ** environ` 

```c
/**
 * 使用全局变量 char ** environ 访问环境变量
*/

#include <stdio.h>

int main()
{    
    extern char ** environ;  // 声明变量
    char **ep = environ;
    for (; *ep != NULL; ep++)
    {
        puts(*ep);
    }
    return 0;
}
```

使用 `main()` 的第三个参数

```c
int main(int argc, char *argv[], char *envp[]);
```

### 获取环境变量

`getenv()` 函数能够从进程环境中检索单个值

```c
#include <stdlib.h>

char *getenv(const char *name);
/* 成功返回字符串指针；没有查找到name返回 NULL*/
```

> [!tip] 可移植性方面的注意事项
> 
> 程序不应修改 `getenv()` 函数返回的字符串。因为该字符实际上属于 `name=value` 的 `value` 部分。如需修改请使用 `setenv()` 或 `putenv()`
> 
### 修改环境变量

有时，对进程来说，修改其环境很有用处

> [!tip] 
> 
> **修改对该进程后续创建的所有子进程均可见**
> 
> 在于设定某一变量，以求对于 **将要载入进程内存的新程序（“execed”）可见**
> 

环境变量不仅是一种进程间通信的形式，还是程序间通信的方法。下表列出来用于修改环境变量的函数

| 函数           | 描述                  |
| :----------- | ------------------- |
| `putenv()`   | 添加新的环境变量和替换已存在的环境变量 |
| `setenv()`   | 添加新的环境变量和修改已存在的环境变量 |
| `unsetenv()` | 移除环境变量              |
| `clearenv()` | 清空环境变量              |

`putenv()` 向调用进程的环境中 **添加一个新变量**，或者 **修改一个已经存在的变量值**

```c
#include <stdlib.h>

int putenv(char *string);
/*成功返回 0；错误返回非零*/
```

> [!tip] 参数 `string`： 是一指针，指向 `name=value` 形式的字符串
> 
> 环境列表中的某一项指向了 `string` 指向的位置，而非 `string` 指向位置的副本。因此，`string` 参数不应为自动变量
> 

`setenv()`函数可以代替 `putenv()` 函数，向环境中添加一个变量

```c
#include <stdlib.h>

int setenv(const char *name, const char *value, int overwrite);
/* 成功返回 0；错误返回 -1*/
```

> [!tip] `setenv()` 会为 `name=value` 的字符串分配缓冲区
> 
> `name` 和 `value` 所指向的字符串复制到此缓冲区，以此来创建一个新的环境变量。这是与 `putenv()` 最大的不同
> 

> [!attention] 注意
> 
> **不需要（实际上，是绝对不要）在 `name` 的结尾处或者 `value` 的开始处提供一个等号字符**
> 

> [!tip] 参数 `overwrite`：指定环境变量 `name` 存在时的行为
> + 参数 `overwrite` 的值为 $0$，则 `setenv()` 函数将不改变环境
> + 参数 `overwrite` 的值为非 $0$，则 `setenv()` 函数总是改变环境


`unsetenv()` 函数从环境中移除由 `name` 参数标识的变量

```c
#include <stdlib.h>

int unsetenv(const char *name);
/* 成功返回 0；错误返回 -1*/
```

> [!tip] 参数 `name` 不应包含等号字符

有时，**需要清除整个环境，然后以所选值进行重建**。可以通过将 `environ` 变量赋值为 `NULL` 来清除环境

这也正是 `clearenv()`库函数的工作内容

```c
#define _BSD_SOURCE /* #define _SVID_SOURCE */

#include <stdlib.h>
int clearenv(void);
/* 成功返回 0；错误返回 非零*/
```

## 非局部跳转

参考 [[错误处理#非局部跳转]]

### 优化编译器的问题

优化编译器会重组程序的指令执行顺序，并在 CPU 寄存器中，而非 RAM 中存储某些变量。这种优化一般依赖于反映了程序词法结构的 **运行时** 控制流程

由于 `setjmp()` 和 `longjmp()` 的跳转操作 **需在运行时才能得以确立和执行**，并未在程序的词法结构中有所反映，故而编译器在进行优化时也无法将其考虑在内

此外，某些应用程序二进制接口实现的语义要求 `longjmp()` 函数恢复先前 `setjmp()` 调用所保存的 CPU 寄存器副本。这意味着 `longjmp()` 操作会致使经过优化的变量被赋以错误值。如下示例

```c

/**
 * longjmp()函数 和 编译器优化
*/

#include <stdio.h>

#include <stdlib.h>
#include <setjmp.h>

static jmp_buf env;

static void doJump(int nvar, int rvar, int vvar)
{
    printf("Inside doJump(): nvar=%d rvar=%d vvar=%d\n", nvar, rvar, vvar);
    longjmp(env, 1);
}

int main(int argc, char *argv[]){
    int nvar;
    register int rvar;  // 如果可能声明在 寄存器中
    volatile int vvar;  // 易变的，编译器不会优化变量

    nvar = 111;
    rvar = 222;
    vvar = 333;

    if(setjmp(env) == 0)
    {
        nvar = 777;
        rvar = 888;
        vvar = 999;
        doJump(nvar, rvar, vvar);
    }
    else
    {
        printf("After longjmp(): nvar=%d rvar=%d vvar=%d\n", nvar, rvar, vvar);
    }
    return 0;
}
```

下图展示了关闭优化和开启优化的执行结果

![[Pasted image 20241023183541.png]]

> [!tip] 
> 
> **尽可能避免使用 `setjmp()` 函数和 `longjmp()` 函数**
> 

## Linux 操作进程的命令

| 命令名       | 详细信息                |
| :-------- | ------------------- |
| `ps`      | 查看系统当中的进程           |
| `top`     | 动态显示系统当中的进程         |
| `nice`    | 用于shell脚本中，指定程序的优先级 |
| `renice`  | 改变正在运行进程的优先级        |
| `kill`    | 发送信号(可以给后台进程发送)     |
| `crontab` | 控制 **定时任务** 后台进程    |
| `bg`      | 将暂停的进程放到后台          |
| `fg`      | 将后台运行和后台暂停的进程放在前台   |

