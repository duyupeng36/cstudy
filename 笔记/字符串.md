# 字符串

## 字符串字面值

在大多数语言中，字符串字面值都是用一对 **双引号** 括起来的字符序列

```c
"When you come to a fork in the road, take it."
```

如果发现字面串太长而无法放置在单独一行以内，只要把第一行用字符 `\` 结尾，那么 C 语言就允许在下一行延续字面串。除了（看不到的）末尾的换行符，在同一行不可以有其他字符跟在 `\` 后面

```c
"When you come to a fork in the road, take it. \ 
--Yogi Berra" 
// 注意，这里是顶格的
```

> [!tip] 
> 字符 `\` 可以用来把两行或更多行的代码连接成一行。需要注意的是，使用 `\` 有一个缺陷：**字符串字面值必须从下一行的起始位置继续**

当 **两条或更多条字符串字面值相邻** 时（仅用空白字符分割），编译器会把它们 **合并成一条字符串**

```c
"When you come to a fork in the road, take it. "  
       "--Yogi Berra"
```

> [!summary] 
> 
> 编译器会自动把两个 **相邻的字符串字面值** 拼接起来。所谓的相邻的字符串字面值就是字符串字面值 **仅用空白字符分割**
> 

### 字符串字面值如何存储的

就本质而言，C 语言把字符串字面值作为 **字符数组** 来处理

> [!tip]
> 
> 当 C 语言编译器在程序中遇到长度为 $n$ 的字面串时，它会为字面串分配长度为 $n+1$ 的内存空间
> 
> 这块内存空间将用来存储字面串中的字符，以及一个用来标志字符串末尾的额外字符（**空字符**）。空字符是一个所有位都为 `0` 的字节，因此用转义序列 `\0` 来表示

> [!warning] 
> 
> 不要混淆空字符(`'\0'`) 和零字符(`'0'`)。空字符的码值为 `0`，而零字符则有不同的码值（ASCII 中为 `48`）。

字面串 `"abc"` 是作为有 $4$ 个字符的数组来存储的（`'a'` `'b'` `'c'` 和`\0`）

![[Pasted image 20240928115934.png]]
**字面串可以为空**。字符串 `""` 作为单独一个空字符来存储

![[Pasted image 20240928115955.png]]

> [!summary] 
> 
> 既然字面串是作为数组来存储的，那么编译器会把它看作 `const char *` 类型的指针，即 **字符指针常量**
> 
> 

```c
#include <stdio.h>

char digit_to_hex_char(int digit)
{
	return "0123456789abcdef"[digit];
}

int main() 
{
	printf("%c\n", *"abc");  // 对字符串字面值解引用
	printf("%c\n", *("abc" + 1)); // 对字符串字面值进行算术运算
	printf("%c\n", digit_to_hex_char(14)); // 对字符串字面值进行下标运算
}
```

> [!tip] 字符串字面值是按照字符数组来处理的
> 
> 字符串字面值作为函数参数的时候，传递的是首字符的地址
> 

## 字符串变量

C 语言采取了不同的方式：只要保证字符串是以空字符结尾的，任何一维的字符数组都可以用来存储字符串

一些编程语言为声明字符串变量提供了专门的 `string` 类型。C 语言采取了不同的方式：**只要保证字符串是以空字符结尾的，任何一维的字符数组都可以用来存储字符串**。这种方法很简单，但使用起来有很大难度

> [!summary] 
> 
> C 语言的字符串依赖于字符数组，只要在字符数组中出现了 `'\0'` 字符，那么认为字符串结束了
> 

假设需要用一个变量来存储最多有 $80$ 个字符的字符串。由于字符串在末尾处需要有空字符，我们把变量声明为含有 $81$ 个字符的数组

```c
#define STR_LEN 80 

char str[STR_LEN+1];
```

> [!warning] 
> 
> 当声明用于存放字符串的字符数组时，要始终保证数组的长度比字符串的长度多一个字符。这是因为 C 语言规定每个字符串都要以空字符结尾

### 初始化

字符串变量可以在声明时进行初始化

```c
char name[10] = "Allen"; 
```

`"Allen"` 是一个字符串初始化器，用来初始化字符数组。实际上是

```c
char name[10] = {'A', 'l', 'l', 'e', 'n'};
```

> [!tip] 
> 
> 如果初始化器太短以致不能填满字符串变量，编译器会添加空字符
> 

所以，`name` 如下图所示

![[Pasted image 20240928152307.png]]

> [!attention] 
> 
> 初始化器比字符串变量长，显然是非法的。 **C 语言允许初始化器（不包括空字符）与变量有完全相同的长度**。因为没有给空字符留空间，所以 **编译器不会试图存储空字符**
>  

### 字符数组与字符指针

字符串字面值不仅可以用于初始化字符数组，还可以用来初始化字符指针

```c
char amessage[] = "now is the time";

char *pmessage = "now is the time";
```

注意，字符串作为字符指针的初始化器和作为字符数组的初始化器时，它们之间的差别非常巨大。下图展示了它们之间的区别

![[Pasted image 20240928155714.png]]



> [!tip] 
> 
> 任何期望传递字符数组或字符指针的函数都能够接收这两种声明的变量作为参数
> 

需要注意的是，`char amessage[]` 和 `char *pmessage` 是完全不同的

> [!important] 
> 
> + `amessage` 是一个仅仅能存放字符串字面值常量的字符数和 `'\0'` 的一维数组。数组中的单个字符可以修改
> + `pmessage` 是一个指针，其初始值指向一个字符串字面值，之后它可以被修改指向其他地址。但是，视图修改字符串字面值中的内容是未定义的行为
> 

也就是说，**如果希望修改字符串的内容，那么就要建立字符数组来存储字符串**

下面的声明使编译器为指针变量分配了足够的内存空间，它不能为字符串分配空间。因为，我们没有指明字符串的长度

```c
char *p;
```

使用 `p` 作为字符串之前，必须把 `p` 指向字符数组。一种可能是把 `p` 指向已经存在的字符串变量

```c
char str[STR_LEN + 1], *P;

*P = str;
```

另一种可能是让 `p` 指向一个 **动态分配的字符串** ^[[[指针高级]]]

## 字符串的输入与输出

### 字符串输出

转换说明 `%s` 允许 `printf` 函数输出字符串

```c
char str[] = "Are we having fun yet?";
printf("%s\n", str);  // Are we having fun yet?
```

`printf` 会 **逐个写字符串中的字符，直到遇到空字符才停止**。如果空字符丢失，`printf` 函数会越过字符串的末尾继续写，直到最终在内存的某个地方找到空字符为止

如果只想 **显示字符串的一部分**，可以使用转换说明 `%.ps`，这里 `p`  是要显示的字符数量

```c
printf("%.6s\n", str);  // Are we
```

转换说明 `%ms` 会在最小栏宽为 `m`  内显示字符串。对于超过 `m` 个字符的字符串，`printf` 函数会显示出整个字符串，而不会截断

> [!tip] 
> 
> `printf` 输出字符串时，会在栏内 **右对齐输出**
> 
> 如果要 **强制左对齐**，可以在 `m` 前加一个负号(`-`)，即：`%-ms`
> 

C 函数库还提供了 `puts` 函数，此函数可以按如下方式使

```c
puts(str);
```

`puts` 函数只有一个参数，即需要显示的字符串。在写完字符串后，`puts` 函数 **总会添加一个额外的换行符**，从而前进到下一个输出行的开始处

### 字符串输入

转换说明 `%s` 允许 `scanf` 函数把字符串读入字符数组

```c
scanf("%s", str);
```

在 `scanf` 函数调用中，不需要在 `str` 前添加运算符 `&`，因为 `str` 是数组名，编译器在把它传递给函数时会把它当作指针来处理

`scanf` 函数会 **跳过空白字符**，然后读入字符并存储到 `str` 中, 直到遇到空白字符为止

> [!tip] 
> 用 `scanf` 函数读入字符串 **永远不会包含空白字符**。因此，`scanf` 函数通常不会读入一整行输入
> 
> 换行符会使 `scanf` 函数停止读入，空格符 或 制表符也 会产生同样的结果
> 

为了一次读入一整行输入，历史上我们一直使用 `gets` 函数，但是由于安全方面的原因，**从 C11 开始已经将它废除**。并提供另一个标准函数 `gets_s` 替代，该函数可以指定存储字符串的数组大小。

```c
char *gets_s(char * buffer, int size);
```

> [!quote] 
> `gets_s` 函数最多读入 `n-1` 的字符放到数组中，然后存储一个 **空字符**。然而，在其他方面 `gets_s` 函数有些不同于 `scanf` 函数
> 
> `gets_s` 函数 **不会在开始读字符串之前跳过空白字符**（`scanf` 函数会跳过）
> 
> `gets_s` 函数会 **持续读入，直到找到换行符才停止**（`scanf` 函数会在任意空白字符处停止）
> 
> 此外，`gets_s` 函数会 **忽略换行符**，不会把它存储到数组中，并 **用空字符代替换行符**
> 

> [!tip]
> 
> GCC 目前尚未支持该函数。我们需要自行实现类似的效果
> 

### 逐个字符读字符串

实现 C11 标准的 `gets_s` 函数

```c
char *gets_s(char *buffer, int size)
{
    char *result = buffer;

    while (size > 1 && (*buffer = (char)getchar()) != '\n') {
        buffer++;
        size--;
    }
    *buffer = '\0';
    return result;
}
```

> [!attention] 
> 
> 注意，`getchar` 把它读取的字符作为 `int` 类型的值返回。如果需要存储在 `char` 类型的变量中，需要将其转为 `char` 类型
> 

## 访问字符串中的字符

在 `<string.h>` 中提供了许多操作字符串的库函数。这里，我们会实现库函数 `strcpy(dst, src)` 函数，加深理解指针与数组关系，同时学习如何访问字符串中字符

第一个版本使用数组下表实现。由于我们只是希望从 `src` 中复制字符，而不希望修改 `src` 中的字符，因此将 `src` 声明为 `const`  

```c
/** version 1.0.0: 使用数组下标实现
strcpy(dest, src)：将 `src` 指向的字符串中的字符复制给 `des` 指向的位置。并返回 dest
*/
char * strcpy(char * dest, const char * src)
{
	int i = 0;
	while((dest[i] = src[i]) != '\0') i++;
	return dest;
}
```

> [!attention] 
> 
> 在调用时，第一个参数必须指向一个字符数组或者动态分配的内存
> 

为了对比指针与数组，下面使用指针方法实现 `strcpy` 函数

```c
/** version 1.0.1: 使用指针方法实现
strcpy(dest, src)：将 `src` 指向的字符串中的字符复制给 `des` 指向的位置。并返回 dest 指向的第一个位置。
*/
char * strcpy(char *dest, const char * src)
{
	char *temp = dest;
	while((*temp = *src) != '\0')
	{
		temp++;
		src++;
	}
	return dest;
}
```

因为参数是通过值传递的，所以在 `strcpy` 函数内部可以以任意方式使用参数 `dest` 和 `src`。当函数被调用时，`dest` 和 `src` 就以及被它们对饮的实际参数给初始化。循环开始后，每指向一次循环，它们就沿着相应的数组前进一个字符，知道将`src` 中的  `'\0'` 复制到 `dest` 为止 

通常，`strcpy` 函数的实现比上述实现更为简洁

```c
/** version 2.0.0: 使用指针方法实现
strcpy(dest, src)：将 `src` 指向的字符串中的字符复制给 `des` 指向的位置。并返回 dest 指向的第一个位置。
*/
char *strcpy(char *dest, const char *src)
{
	char *temp = dest;
	while((*temp++ = *src++) != '\0');
	return dest;
}
```

将 `temp` 和 `src` 自增的部分放在了循环控制表达式中。根据算术运算符的优先级和结合性表达式 `*temp++` 等价于 `*(temp++)`，因此该表达式的值是指向自增运算之前的 `temp` 指向的位置。同理表达式 `*src++` 的值是 `src` 自增前指向的字符

> [!tip]
> 
> 后缀 `++` 在将字符存储到 `temp` 指向的位置之后才改变 `temp` 的值
> 
> 后缀 `++` 在读取`src` 指向的字符之后才改变 `src` 的值
> 

j将字符的值与 `'\0'` 做比较，以控制循环的指向。最后当 `src` 指向的字符为 `'\0'` 且复制到了 `dest` 中之后结束循环

字符 `'\0'` 在字符集中的编码为 `0x0` 在 C 语言中与布尔值 `0` 等价。因此，我们可以省略判断字符为 `'\0'` 的部分

```c
/** version 2.1.0: 使用指针方法实现
strcpy(dest, src)：将 `src` 指向的字符串中的字符复制给 `des` 指向的位置。并返回 dest 指向的第一个位置。
*/
char *strcpy(char *dest, const char *src)
{
	char *temp = dest;
	while(*temp++ = *src++);
	return dest;
}
```

## 字符串库函数

一些编程语言提供的运算符可以对字符串进行 **复制**、**比较**、**拼接**、**选择子串**等操作，但 C 语言的运算符根本无法操作字符串。在 C 语言中把字符串当作数组来处理，因此对字符串的限制方式和对数组的一样，特别是它们都不能用 C 语言的运算符进行复制和比较操作

**C 语言的函数库为完成对字符串的操作提供了丰富的函数集**。这些函数的原型驻留在 `<string.h>` 头中，所以需要字符串操作的程序应该包含下列内容

```c
#include <string.h>
```

字符串形式参数声明为 `char *` 类型，这使得实际参数可以是字符数组、`char *` 类型的变量或者字面串

### 字符串复制

C 语言的库函数提供了两个用于复制字符串的函数，的函数原型如下

```c
char * strcpy(char *dest, const char *src);
char * strncpy(char *dest, const char *src, size_t n)
```

将 `src` 中的字符(包括空字符)复制到 `dest` 指向的内存中，并且返回 `dest`。

对于 `strcpy` 函数，如果 `src` 的字符数量大于 `dest` 指向内存的大小，将导致未定义行为。为了安全，请使用 `strncpy` 函数

对于 `strncpy` 的第 $3$ 个参数 `n` 用于指定 **复制字符的个数**。只有当 `dest` 能够存储下 `src` 指向字符串中的所有字符(包括空字符)才能复制完成

调用 `strncpy` 函数时，需要指定复制字符的数量为 `dest` 的长度

```c
strncpy(dest, src, sizeof(dest));
```

如果 `src` 中存储的字符串的长度大于 `dest` 数组的长度， `strncpy` 会导致 `des` 中的字符串没有终止的空字符。一种更为安全的调用方式如下

```c
strncpy(dest, src, sizeof(dest) - 1); 
dest[sizeof(str1)-1] = '\0';
```

第二条语句确保 `dest` 总是以空字符结束，即使 `strncpy` 没能从 `src` 中复制到空字符

### 字符串长度

求字符串长度需要调用函数 `strlen`，其函数原型如下

```c
size_t strlen(const char *src);
```

`size_t` 是使用 `typedef` 定义的类型别名，表示 C 语言中的一种无符号整型。我们可以简单的把 `strlen` 的返回值作为整数处理

`strlen` 函数返回字符串 `src` 中第一个空字符之前的字符个数（**不包括空字符**）

```c
int len; 
 
len = strlen("abc");      /* len is now 3 */ 
len = strlen("");          /* len is now 0 */ 
strcpy(strl, "abc"); 
len = strlen(strl);       /* len is now 3 */
```

### 字符串拼接

C 语言库函数同样提供了两个字符串拼接函数

```c
char * strcat(char *dest, const char *src);
char * strncat(char *dest, const char *src, size_t n);
```

函数把 `src` 中的字符追加到 `dest` 的末尾，并且返回 `dest`。

对于 `strcat` 函数，如果 `dest` 指向的数组没有大到足以容纳 `src` 指向的字符串中的字符，那么调用 `strcat(str1, str2)` 将会产生未定义行为

对于 `strncat` 函数的第 $3$ 个参数，指定了复制字符的个数

```c
strncat(str1,  str2, sizeof(str1) – strlen(str1) - 1) ;
```

`strncat` 函数会在遇到空字符时终止 `str1`，第三个参数（待复制的字符数）没有考虑该空字符


### 字符串比较函数

C 标准库中字符串比较有两个函数，它们的原型如下

```c
int strcmp(const char *s1, const char *s2);
int strncmp(const char *s1, const char *s2, size_t n);
```

这两个函数都是从左到右依次比较字符的编码。根据 `s1` 和 `s2` 的大小关系返回一个整数

| 关系         | 返回值          |
| :--------- | ------------ |
| `s1 < s2`  | 小于 $0$ 的整数   |
| `s1 == s2` | 返回 $0$       |
| `s1 > s2`  | 返回大于 $0$ 的整数 |

> [!tip] 
> 
> 返回值通常是确定关系的字符编码的差值
> 

字符串比较规则：**类似于字典中单词的编排方式**

> [!tip] `s1` 小于 `s2` 的规则
> 
>  `s1` 与 `s2` 的前 `i` 个字符一致，但是 `s1` 的第 `i+1` 个字符小于 `s2` 的第 `i+1` 个字符，那么 `strcmp` 函数认为 `s1` 小于 `s2`
>  
>  `s1` 的所有字符与 `s2` 的字符一致，但是 `s1` 比 `s2` 短，那么 `strcmp` 函数认为 `s1` 小于 `s2`
> 

> [!tip] `s1` 等于 `s2` 的规则
> 
> `s1` 和 `s2` 的长度一致，并且所有字符都相等
> 

> [!tip] `s1` 大于 `s2` 的规则
> 
>  `s1` 与 `s2` 的前 `i` 个字符一致，但是 `s1` 的第 `i+1` 个字符大于 `s2` 的第 `i+1` 个字符，那么 `strcmp` 函数认为 `s1` 大于 `s2`
>  
>  `s2` 的所有字符与 `s1` 的字符一致，但是 `s2` 比 `s1` 短，那么 `strcmp` 函数认为 `s1` 大于 `s2`
> 

## 字符串数组

有时我们需要 **存储很多个字符串**，最明显的解决方案就是使用二维数组，然后按照每一行的存储一个字符串方式把字符串存储到数组中。如下定义了一个字符二维数组，用于保存太阳行星的名字

```c
char planets[][8] = {"Mercury", "Venus", "Earth",
                        "Mars", "Jupiter", "Saturn",
                        "Uranus", "Neptune", "Pluto"};
```

注意，虽然允许省略 `planets` 数组的行数（因为这个数很容易从初始化器中元素的数量求出），但是 C 语言要求 **指明列数**

下面给出了 `planets` 数组的可能形式。并非所有的字符串都足以填满数组的一整行，所以C 语言用空字符来填补。因为只有 $3$ 个行星的名字需要用满 $8$ 个字符（包括末尾的空字符），所以 **这样的数组有一点浪费空间**

![[Pasted image 20240928184624.png]]

> [!question] 
> 
> 上述例子暴露了 **使用二维数组存储多个字符串的问题**：并非所有的字符串都是一样长的，这样就会**造成空间浪费**

为了解决上述问题，我们需要一个 **参差不齐的数组**，即 **每一行有不同长度** 的二维数组。同时，在 [[函数]] 中遗留了一个问题：**如何向函数传递任意维数的数组？**

C 语言中，使用 **指针数组** 解决 **存储参差不齐的数组** 和 **向函数传递任意维数的数组的** 的问题

### 指针数组

继续 [[指针与数组#指针与多维数组]] 的内容，我们知道 编译器始终将 **二维数组** 看作 **存储一维数组的一维数组**

在 [[数组]] 中介绍过，声明一个长度为 $n$ 的数组，就相当于声明了 $n$ 个名字；同理，声明一个 $n \times m$ 的二维数组，就相当于声明了 $n$ 个一维数组

```c
int m[5][10];
```

上述声明就相等于声明了 $5$ 个一维数组 `m[0], m[1], m[2], m[3], m[4]`，并且每个数组的长度是 $10$

```c
int main() {

    int m[5][10];
    // 由于数组名是不能修改的，测试
    m[1] = (int[10]){1,2,3,4,5,6,7,8,9,10}; // error: assignment to expression with array type

    return 0;
}
```

数组与指针的密切关系：**数组名** 可以作为指针使用，即数组名的值是第 $0$ 个元素的地址，即 **指向数组第 $0$ 元素的指针常量**。因此，我们可以将上述 $5$ 个数组名保存在一个数组中

```c
int * pm[5] = {m[0], m[1], m[2], m[3], m[4]}
```

声明 `char *pm[4]` 中，名字 `pm` 是一个数组，数组的元素是 `int *` 类型（指向 `int` 类型对象的指针）

> [!question] 现在需要思考：`pm` 的类型是什么？
> 
> `pm` 是数组名，它的值是指向数组第 $0$ 个元素的指针常量，数组 `pm` 的第 $0$ 个元素是一个 **指针**，其类型是 `int *`。因此，`pm` 的类型是 `int **`，即 **指向指针的指针**
> 
> 关于指向指针的指针，将在 [[指针高级]] 中介绍
> 

### 字符指针数组

下面我们就可以声明一个 **元素都是指向字符指针的数组**，用以模拟这种参差不齐的数组类型。如下声明 `planets`

```c
char *planets[] = {"Mercury", "Venus", "Earth", 
                   "Mars", "Jupiter", "Saturn", 
                   "Uranus", "Neptune", "Pluto"};
```

上述声明，对 `planets` 存储方式产生的影响却很大：`planets` 数组中存储的是 **字面串的指针**

![[Pasted image 20240928190521.png]]

`planets` 的每一个元素都是指向以空字符结尾的字符串的指针。虽然必须为 `planets` 数组中的指针分配空间，但是 **字符串中不再有任何浪费的字符**

### 命令行参数

运行程序时经常需要提供一些信息——文件名或者改变程序行为的开关。考虑 UNIX 系统的 `ls` 命令。如果我们按如下方式运行 `ls`，将显示当前目录中的文件名

```shell
ls
```

但是，如果输入 `ls -l`，那么 `ls` 会显示一个“很长的”（详细的）文件列表，

```shell
ls -l
```

为了进一步改变 `ls` 的行为，例如，可以指定只显示一个文件的详细信息

```c
ls –l remind.c
```

> [!tip]
> 
> **命令行信息不仅对操作系统命令可用，而且它对所有程序都是可用的**
> 

为了能够访问这些命令行参数（C 标准中称为 **程序参数**），必须把 `main` 函数定义为含有两个参数的函数，这两个参数通常命名为 `argc` 和 `argv`

```c
int main(int argc, char *argv[])
{
	....
}
```

`argc`（“**参数计数**”）是命令行参数的数量（包括程序名本身）；`argv`（“**参数向量**”）是 **指向命令行参数的指针数组**，这些命令行参数以字符串的形式存储

`argv` 有一个附加元素，即 `argv[argc]`，这个元素始终是一个 **空指针**

> [!tip]
> 
> 空指针是一种 **不指向任何地方的特殊指针**
> 

如果用户输入

```c
ls -l remind.c
```

那么 `argc` 将为 $3$，`argv[0]` 将指向含有程序名的字符串，`argv[1]` 将指向字符串`"-l"`，`argv[2]` 将指向字符串 `"remind.c"`，而 `argv[3]`将为空指针

![[Pasted image 20240928191049.png]]

根据操作系统的不同，程序名可能会包括路径或其他信息。如果程序名不可用，那么 `argv[0]`会指向空字符串

例程：核对行星的名字，检查一系列字符串，从而找出哪些字符串是行星的名字。程序执行时，用户将把待测试的字符串放置在命令行中

```c
/*
例程：核对行星的名字

检查一系列字符串，从而找出哪些字符串是行星的名字。
程序执行时，用户将把待测试的字符串放置在命令行中
*/

#include <stdio.h>
#include <string.h>


int main(int argc, char *argv[]) {
    char *planets[] = {"Mercury", "Venus", "Earth",
                       "Mars", "Jupiter", "Saturn",
                       "Uranus", "Neptune", "Pluto", NULL};
    for(char **p = planets; *p != NULL; p++) {
        for(char **q = argv + 1; *q != NULL; q++) {
            if(strcmp(*p, *q) == 0) {
                printf("%s is a planet\n", *p);
                break;
            }
        }
    }
    return 0;
}
```
