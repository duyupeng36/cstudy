# 文件锁

应用程序的一个常见需求是从一个文件中读取一些数据，修改这些数据，然后将这些数据写回文件。只要在一个时刻只有一个进程以这种方式使用文件就不会存在问题，但当 **多个进程同时更新一个文件** 时问题就出现了。假设各个进程按照下面的顺序来更新一个包含了一个序号的文件
- 从文件中读取序号
- 使用这个序号完成应用程序定义的任务
- 递增这个序号并将其写回文件

这里存在的问题是两个进程在没有采用任何同步技术的情况下可能会同时执行上面的步骤，从而导致出现下图中给出的结果（这里假设序号的初始值为 $1000$）

![[Pasted image 20241108141825.png]]

在执行完上述步骤之后，文件中包含的值为 $1001$，但其所包含的值应该是 $1002$。（这是一种竞争条件。）为防止出现这种情况就需要采用某种形式的进程间同步。 

尽管可以使用信号量来完成所需的同步，但通常文件锁更好一些，因为内核能够自动将锁与文件关联起来

> [!tip] 对文件加锁的 API 有两种
> + `flock()`对整个文件加锁
> + `fcntl()`对一个文件区域加锁

由于 stdio 库会在用户空间进行缓冲，因此在混合使用 stdio 函数与加锁技术时需要特别小心。这里的问题是一个 **输入缓冲器在被加锁之前可能会被填满** 或者一个 **输出缓冲器在锁被删除之后可能会被刷新**。要避免这些问题则可以采用下面这些方法

> [!hint] 
> 
> + 使用 `read()` 和 `write()` 系统调用替换 `stdio` 库
> + 在对文件加锁之后立即刷新 `stdio` 流，并且在释放锁之前立即再次刷新这个流
> + 禁用 `stdio` 缓冲区
> 

## flock(): 文件加锁

`flock()` 系统调用在 **整个文件** 上放置一个锁

```c
#include <sys/file.h>

int flock(int fd, int operation);
/* 成功返回 0； 错误返回 -1 */
```

> [!tip] 参数 `fd`：打开文件描述符
> 
> 指定被加锁的文件
> 

> [!tip] 参数`operation`：指定加锁类型或者解锁
> 
> 参数指定了下表中描述的 `LOCK_SH`、`LOCK_EX` 以及 `LOCK_UN` 值中的一个
> 
> ![[Pasted image 20241108142930.png]]
> 

> [!attention] 
> 
> 默认情况下，如果一个进程已经持有 $\text{fd}$ 指定文件上的一把不兼容锁，那么 `flock()` 调用会阻塞
> 
> 解决上述 `flock()` 阻塞可以在参数 `operation` 上指定 `LOCK_NB` 标记(位或)
> 

任意数量的进程可同时持有一个文件上的共享锁，但在同一个时刻只有一个进程能够持有一个文件上的互斥锁。下表对 `flock()` **加锁的兼容规则** 进行了总结。这里 **假设进程 A 首先放置了锁**，表中给出了 **进程 B** 是否能够放置一把锁

![[Pasted image 20241108142952.png]]

> [!tip] 
> 
> 换句话说，**互斥锁会拒绝其他进程的互斥和共享锁请求**
> 

### 锁继承与释放的语义

通过 `flock()` 调用并将 `operation` 参数指定为 `LOCK_UN` 可以释放一个文件锁。此外，锁会在相应的文件描述符被关闭之后自动被释放

> [!tip] 释放锁时间
> 
> + 调用 `flock(fd, LOCK_UN)`
> + 关闭文件描述符，即调用 `close(fd)`
> 

通过 `flock()` 获取的文件锁是与 **打开的文件描述(系统级 $\text{i-node}$ 表项)** 而不是文件描述符或文件本身($\text{i-node}$)相关联的。这意味着当一个文件描述符被复制时，新文件描述符会引用同一个文件锁

> [!tip] 对一个文件描述符加锁并且创建副本
> 
> 如果已经通过了一个特定的文件描述符 **获取了一个锁** 并 **创建了该文件描述符的副本**，那么 **必须显示的执行一个解锁操作**，否则只有当所有的描述符副本都被关闭之后锁才会被释放
> 

> [!important] 两次打开同一个文件并加锁
> 
> 如下两次打开同一个文件，并加锁
> ```c
> fd1 = open("a.txt", O_RDWR);
> fd2 = open("a.txt", O_RDWR);
> flock(fd1, LOCK_EX);
> flock(fd2, LOCK_EX); // 阻塞，因为 fd1 和 fd2 引用同一个 v-node 节点(系统级 i-node 表项)
> ```
> 第二次加锁会被阻塞，因为 `fd1` 和 `fd2` 引用的是同一个打开文件描述(系统级 $\text{i-node}$ 表项)

> [!tip] `fork()` 子进程会复制父进程的文件描述符，类似于 `dup()`
> 
> 子进程释放文件锁，从而导致父进程的文件锁被释放
> 

## fcntl(): 文件区域加锁

使用 `fcntl()` 能够在一个 **文件的任意部分** 上放置一把锁，这个 **文件部分既可以是一个字节**，也 **可以是整个文件**。这种形式的文件加锁通常被称为 **记录加锁**，但这种称谓是不恰当的，因为 UNIX 系统上的文件是一个字节序列，并不存在记录边界的概念，文件记录的概念只存在于应用程序中

下图显示了如何使用记录锁来同步两个进程对一个文件中的同一块区域的访问。（在这幅图中假设所有的锁请求都会阻塞，这样它们在锁被另一个进程持有时就会等待。

![[Pasted image 20241108143328.png]]

用来创建或删除一个文件锁的 `fcntl()` 调用的常规形式如下

```c
struct flock flock_struct;

/* 设置 flokstr 的字段 */

fcntl(fd, cmd, &flock_struct);
```

> [!tip] 参数 `fd`：文件描述符
> 

> [!tip] 参数 `cmd`：指定 `fcntl` 行为
> + `F_SETLK`：加锁
> + `F_SETLKW`：加锁，阻塞等待加锁完成
> + `F_GETLK`：获取 `flock` 结构的副本
> 
> 在使用 `F_SETLKW` 时需要弄清楚下图中阐述的场景类别。在这种场景中，每个进程的第二个锁请求会被另一个进程持有的锁阻塞。这种场景被称为 **死锁**
> 
> ![[Pasted image 20241108145901.png]]
> 

> [!tip] 参数 `flock_struct`：文件锁结构，是一个 `flock` 结构的指针
> 
> `flock` 结构定义了待获取或删除的锁，其定义如下所示
> 
>```c
> struct flock
> {
> 	short _ltype;  /* F_RDLCK F_WRLCK F_UNLCK */
> 	short l_whence;  /* SEEK_SET  SEEK_CUR  SEEK_END */
>
> 	off_t l_start;  /* 偏移量 */
> 	off_t len;  /* 需要加锁的字节数 */
> 	pid_t l_pid;  /* */
> };
> ```
> 
> `flock.ltype` 的取值如下
>  + `F_RDLCK`：读锁
> + `F_WRLCK`：写锁
> + `F_UNLCK`：释放锁
> 
