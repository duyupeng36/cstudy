# 并发执行

**并发** 指的是程序同时管理多个任务的能力，从而提高性能和响应速度。它包括不同的模型，如 **多线程**、**多进程** 和 **异步任务**，每个模型都提供独特的优势和权衡

> [!tip] 
> 
> 所谓的并发是指在同一个时间段同时执行多个任务的能力。参考 [[操作系统：进程概念]]
> 

在 Python 中，多线程和异步任务只在一个 CPU 核心上执行；只有多进程才可以利用多个 CPU 核心实现真正的 **并行**

> [!tip] 
> 
> 并行是在同一时刻可以同时执行多个任务，它是一种特殊并发
> 

## 并发是什么？

并发在字典中的含义是 **同时发生**。在 Python 中，同时发生的事情有不同的称呼，包括：线程、任务、进程。

本质上，**它们都指一系列按顺序执行的指令**。你可以把它们想象成不同的 _思维列车_。每一个都可以 _在特定点停止_，处理它们的 CPU 可以 _切换到另一个_。每个思维列车的 _状态被保存起来_，以便在 **中断** 的地方恢复。

> [!tip] 
> 
> 虽然 Python 对同一概念使用不同的词汇。但是，实际上，只有在从高层次角度看待时，线程、任务和进程才是相同的。
> 
> 一旦你开始深入研究细节，你会发现它们都代表略有不同的事物
> 

现在，你需要考虑定义中的并发部分。你必须小心一点，因为当你深入到细节时，你会发现只有多个系统进程才能使 Python 在实际上以相同的时间运行这些思维列车。

**线程** 和 **异步任务** 总是在单个处理器上运行，这意味着它们一次只能运行一个。它们只是巧妙地找到 **_轮流执行_** 的方式来加快整体过程。即使它们不能同时运行不同的思维列车，但它们仍然属于并发概念。

> [!attention] 
> 
>   注意：大多数其他编程语言的线程通常并行运行。由于 Python 存在的 GIL（全局解释器锁）保证 Python 解释器进程只有一个线程执行。
>   
>   当然，我们也可以使用 C/C++ 编写扩容绕过 GIL 或者使用 Python3.13 版本的实验性功能：自由线程
> 

在 [[操作系统：多线程概念#线程模型]] 中，介绍了 **用户态线程** 和 **内核线程**。现代操作系统都支持内核线程；也就是说，操作系统可以在任何时候中断它以启动运行不同的线程。这种被称 **抢占式** 多任务处理，因为操作系统可以抢占您的线程或进程以进行切换

抢占式多任务处理很方便，因为线程中的代码不需要做任何特殊操作来切换。这也可能因为任何时间点都可能发生上下文切换而变得困难。上下文切换可能发生在单个 Python 语句的中间，甚至是一个像 `x = x + 1` 这样的简单语句。这是因为 Python 语句通常由多个低级字节码指令组成

> [!tip] 
> 
> CPU 在执行 `x = x + 1` 至少会分为 $3$ 步执行
> + 读取 `x` 的值
> + 计算 `x + 1`
> + 将 `x + 1` 的结果写入内存
> 
> 操作系统可以在这 $3$ 个步骤之间的任意位置切换线程。如果有多个线程共享变量 `x`，那么就可能会得到错误的结果
> 

**异步任务** 被称为协作式多任务(也称为 **协程**)。任务必须通过通知它们何时准备好被切换出来而无需操作系统的参与来相互协作。这意味着任务中的代码需要稍作修改才能实现这一点。

前置额外工作的好处是您始终知道任务将在何处被切换，这使得推理执行流程更容易。在协作式多任务重，除非该语句被标记为让出 CPU，否则任务不会在 Python 语句的中间被切换。

## 并行是什么？

到目前为止，你已经了解了在单个处理器上发生的并发(轮流执行)。那么，关于你那酷炫的新笔记本电脑上的所有 CPU 核心呢？你如何在 Python 中利用它们呢？答案是执行单独的 **进程**

> [!tip] 
> 
> 这意味着，并行需要 CPU 的支持。一台计算机的 CPU 核心数决定了这台计算机能够并行执行的程序的数量
> 

在 [[操作系统：进程概念]] 中，

## 线程








