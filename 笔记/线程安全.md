# 线程安全

## 线程安全函数

若函数 **可同时供多个线程安全调用**，则称之为 **线程安全函数**；反之，如果函数不是线程安全的，则不能并发调用。在 [[互斥量]] 中写的第一个程序 `thread_incr.c` 中的线程函数就不是线程安全的

```c title:threads/thread_incr.c
struct args {
    long loops;
    int id;
};

static int glob = 0;

void *incr(void *arg) {
    const struct args args = *(struct args *)arg;
    for(int i = 0; i < args.loops; i++) {
        int loc = glob;
        loc++;
        glob = loc;
        printf("[Thread %d]: glob = %d\n", args.id, glob);
    }
    return nullptr;
}
```

如果多个线程并发调用该函数，`glob` 的最终值将不得而知

> [!attention] 导致线程不安全的典型原因：使用了在 **线程之间共享** 的全局或静态变量

> [!important] 实现线程安全的方式：将函数与互斥量关联使用。 **在调用函数时将其锁定，在函数返回时解锁**
> 
> 该方法的优点在于 **简单**。但是，这样也意味着调用相同函数的线程只能执行一个，即 **对该函数的访问是串行的**
> 
> 如果各线程在执行此函数时都耗费了相当多的时间，那么 **串行化会导致并发能力的丧失**，所有线程将不再并发执行
> 

> [!important] 实现线程安全的方式：将共享变量与互斥量关联起来。**在临界区入口点加锁，在临界区结束点解锁**
> 
> 这将允许多线程同时执行一个函数并实现并行，除非出现多个线程需要同时执行同一临界区的情况
> 

### 非线程安全的函数

为便于开发多线程应用程序，下表列出的函数在 SUSv3 标准中 **不要求** 是线程安全的

![[Pasted image 20241112232554.png]]

除了上表中的函数外，其他函数均是线程安全的。SUSv3 还有额外的规定

+ 函数 `ctermid()` 和 `tmpname()` 的参数如果为 `NULL`，那么这两函数不是线程安全的
+ 函数 `wcrtomb()` 和 `wcsrtombs()` 的最后一个参数为 `NULL`，那么这两个函数也不是线程安全的

SUSv4 对上表中的函数做了以下修改

+ `ecvt()` `fcvt()` `gcvt()` `gethostbyname()` 以及 `gethostbyaddr()` 被移除，标准删除了这些函数
+ 增加函数 `strsignal()` 和 `system()`

### 可重入和不可重入函数

较之于对整个函数使用互斥量，使用临界区实现线程安全虽然有明显改进，但由于存在对互斥量的加锁和解锁开销，所以多少还是有些低效。**可重入函数则无需使用互斥量即可实现线程安全**

> [!tip] 可重入函数的要诀：**避免对全局和静态变量的使用**
> 
> 如需维护函数的调用信息或者返回值，都存储在调用者分配的缓冲区中
> 
> 首次遇见可重入问题是在 [[信号处理器函数#可重入函数和异步信号安全函数]] 中讨论信号处理器中的全局变量时
> 

> [!warning] 并非所有的函数都可以实现为可重入
> 
> 有些函数必须访问全局数据结构。例如，`malloc()` 的家族函数，因为需要为堆中的空闲块维护有一个全局链表，所以 `malloc()` 函数无法实现为可重入的。**`malloc` 库函数的线程安全是通过使用 _互斥量_ 来实现的**
> 
> 在线程发明前就已经问世的接口本身就定位不可入。要么返回静态变量的指针，要么使用的静态数据结构维护函数的历次调用。对于此类函数，SUSv3 定义了 `_r` 结尾的可重入替身
> 

## 一次性初始化

多线程程序有时有这样的需求：**不管创建了多少线程，有些初始化动作只能发生一次**。

> [!example] 
> 
> 使用 `pthread_mutex_init()` 对带有特殊属性的互斥量进行初始化，而且必须只能初始化一次
> 

如果由主线程来创建新线程，那么这一点易如反掌：可以在创建依赖于该初始化的线程之前进行初始化

不过，**对于库函数而言**，这样处理就不可行，因为调用者在初次调用库函数之前可能已经创建了这些线程。故而需要这样的库函数：无论首次为任何线程所调用，都会执行初始化动作

库函数可以通过函数 `pthread_once()` 实现一次性初始化

```c
#include <pthread.h>

int pthread_once(pthread_once_t *onec_control, void(*init)(void));
/* 成功返回 0; 失败返回 errno */
```

利用参数  `once_control` 的 状 态 ， 函 数  `pthread_once()` 可以确保无论有多少线程对`pthread_once()` 调用了多少次，也只会执行一次由 `init`  指向的调用者定义函数

> [!tip] 参数 `once_control`：必须是一指针，指向初始化为 `PTHREAD_ONCE_INIT` 的静态变量
> 
> 对 `pthread_once()` 的首次调用会修改 `once_control` 指向的内容，以便后续调用不会执行 `init` 指向的函数
> 
> ```c
> static pthread_once_t once = PTHREAD_ONCE_INIT;
> ```
> 

> [!tip] 参数 `init`：指向一个函数，该函数通用用于初始化一个数据类型
> 
> 函数 `init` 的原型如下：无参数并且无返回值
> ```c
> void init(void);
> ```
> 

常常将 `pthread_once()` 和 **线程特有数据** 结合使用

## 线程特有数据

**实现函数线程安全最为有效的方式就是使其可重入**，应以这种方式来实现所有新的函数库

> [!tip] 新的函数库都应该将函数实现为可重入函数
> 

然而，对于已有的不可重入函数，如果将其修改为可重入函数，意味着需要修改函数接口。从而导致使用该函数的所有应用程序都需要修改

为了解决已有不可重入函数的线程安全，线程库提供了 **线程特殊数据 API**。 

> [!tip] 线程特有数据：可以无需修改函数接口，从而实现已有函数的线程安全
> 
> 使用线程特有数据的效率要比可重入函数的效率低。但是，无需修改已有函数接口，省去了修改应用程序的时间
> 

**线程特有数据使函数得以为每个调用线程分别维护一份变量副本**。线程特有数据是 **长期存在** 的。在同一线程对相同函数的历次调用间，每个线程的变量会持续存在，函数可以向每个调用线程返回各自的结果缓冲区

![[Pasted image 20241113001713.png]]

通过线程特有数据将已有不可重入的函数接口包装起来，从而实现线程安全

### 库函数视角下的线程特有数据

要了解线程特有数据相关 API 的使用，需要从使用这一技术的库函数角度来考虑如下问题。

+ 该函数 **必须为每个调用者线程分配单独的存储**，且只需在线程初次调用此函数时分配一次即可
+ 在同一线程对此函数的后续所有调用中，该函数都需要获取初次调用时线程分配的存储块地址。由于函数调用结束时会释放自动变量，故而函数 **不应利用自动变量存放存储块指针**，也 **不能将指针存放于静态变量中**，因为静态变量在进程中只有一个实例
+ 不同（无相互依赖关系）函数各自可能都需要使用线程特有数据。每个函数都需要方法来 **标识其自身的线程特有数据（键）**，以便与其他函数所使用的线程特有数据有所区分
+ 当线程退出时，函数无法控制将要发生的情况。这时，线程可能会执行该函数之外的代码。不过，一定存在某些机制（解构器），在线程退出时会自动释放为该线程所分配的存储。若非如此，随着持续不断地创建线程，调用函数和终止线程，将会引发内存泄露

### 线程特有数据 API

调用 `pthread_key_create()` 函数为线程特有数据创建一个新键，并通过 `key` 所指向的缓冲区返回给调用者。因为进程中的所有线程都可使用返回的键，所以参数 `key` 应指向一个全局变量

```c
#include <pthread.h>

int pathread_key_create(pthread_key_t *key, void(*destuctor)(void *));
/*成功返回 0；错误返回 errno */
```

> [!tip] 参数 `key`：指向一个 `pthread_key_t` 类型的缓冲区
> 
> 用于存储 `pthread_key_create()` 创建出来的键
> 

> [!tip] 参数 `destructor`： 指向一个自定义函数，该函数用于解构线程特有数据，其格式如下
> ```c
> void destructor (void * value)
> {
> 	// 释放 value 指向的存储区
> }
> ```
> 
> 线程终止时，如果该值不是 `NULL`，Pthreads API 会自动调用该解构函数，并将与 `key` 关联的值作为参数传递给解构函数
> 
> 传入的值通常是与该 `key` 关联，且指向线程特有数据块的指针
> 

> [!attention] 
> 
> 如果一个线程有多个线程特有数据块，那么对各个解构函数的调用顺序是不确定的。对每个解构函数的设计应相互独立
> 

下图展示了线程特有数据键的实现

![[Pasted image 20241113100904.png]]

> [!tip] 典型的实现，包括 NPTL 会包含以下数组
> 
> + 一个 **全局（进程范围）数组**，存放线程特有数据的键信息
> + 每个 **线程包含一个数组**，存有为每个线程分配的线程特有数据块的指针
> 

在这一实现中，`pthread_key_create()` 返回的 `pthread_key_t` 类型值只是对全局数组的索引(`index`)，标记为 `pthread_keys`。数组的每个元素都是一个包含 $2$ 个字段的结构
+ 第一个字段标记该数组元素是否在用（即已由之前对 `pthread_key_create()` 的调用分配）
+ 第二个字段用于存放针对此键、线程特有数据块的解构函数指针（是函数 `pthread_key_create()` 中参数 `destructor` 的一份拷贝）

函数 `pthread_setspecific()` 要求 Pthreads API 将 `value` 的副本存储于一数据结构中，并将 `value` 与调用线程以及 `key` 相关联，`key` 由之前对 `pthread_key_create()`的调用·返回

```c
#include <pthread.h>

int pthread_setspecific(pthread_key_t key, const void *valu);
/* 成功返回 0，错误返回 errno */
```

>[!tip] 参数 `key`：线程特有数据的键
>
>该参数是由 `pthread_key_create()` 通过指针参数 `key` 返回的值
>

> [!tip] 参数 `value`：通常是指针指向调用者分配的一块内存
> 
> 线程终止时，该值会被传入与 `key` 绑定的解构函数中
> 

函数 `pthread_getspecific()` 执行的操作与之相反，返回之前与本线程及给定 `key` 相关的值(`value`)

```c
#include <pthread.h>

void *pthread_getspecific(pthread_key_t key);
/* 成功返回指针，没有线程特有数据与 key 关联则 NULL */
```

下图是展示了用于存储 `value` 的数据结构的常见实现

![[Pasted image 20241113102813.png]]

假设将 `pthread_keys[1]` 分配给函数 `myfunc()`。Pthreads API 为每个函数维护指向线程特有数据块的一个指针数组。其中每个数组元素都与全局 `pthread_keys` 数组的元素一一对应。函数 `pthread_ setspecific()` 在指针数组中为每个调用线程设置与 `key` 对应的元素

当线程刚刚创建时，会将所有线程特有数据的指针都初始化为 `NULL`。这意味着当线程初次调用库函数时，必须使用 `pthread_getspecific()` 函数来检查该线程是否已有与 `key` 对应的关联值。如果没有，那么此函数会分配一块内存并通过 `pthread_setspecific()` 保存指向该内存块的指针

## 线程局部存储

**线程局部存储提供了持久的每线程存储**。主要优点在于，比线程特有数据的使用要简单。要创建线程局部变量，只需简单地在全局或静态变量的声明中包含 `__thread` 说明符即可

```c
#include <threads.h>  // __thread 宏定义在此

static __thread Type buf[MAX_ERROR_LEN];
```

关于线程局部变量的声明和使用，需要注意如下几点。 
- 如果变量声明中使用了关键字 `static` 或 `extern`，那么关键字 `__thread` 必须紧随其后
- 与一般的全局或静态变量声明一样，线程局部变量在声明时可设置一个初始值
- 可以使用 C 语言取址操作符（`&`）来获取线程局部变量的地址

> [!warning] 线程局部存储是非标准特性
> 
> 作为非标准特性。需要内核（由 Linux 2.6 提供）、Pthreads 实现（由 NPTL 提供）以及 C 编译器（在 x86-32 平台上由 gcc 3.3 或后续版本提供）的支持
> 
