# 线程细节

## 线程栈

创建线程时，每个线程都有一个属于自己的线程栈，且大小固定

> [!tip] 线程拥有一个属于自己的线程栈并且大小固定
> 
> 在 $32$ 位系统架构下，主线程外的其他线程默认栈大小为 $2 MB$
> 
> 在一些 64 位架构下，默认尺寸要大一些，例如，IA-64 有 $32 MB$
> 

通过 **线程属性** 可以为指定线程栈的大小，还可以自己分配线程栈
+ 函数 `pthread_attr_setstacksize()` 所设置的线程属性决定了线程栈的大小

+ 函数 `pthread_attr_setstack()` 可以同时控制线程栈的大小和位置

> [!warning] 
> 
> 设置栈的地址将降低程序的可移植性
> 

> [!tip] 改变线程栈的两个原因
> 
> + 更大的线程栈可以容纳大型的自动变量以及更深的嵌套函数调用
> 
> + 应用程序可能希望减小线程栈，以便于创建更多的线程
> 

在 x86-32 系统中，用户态可访问的虚拟地址空间是 $3 GB$，而 $2MB$ 的缺省线程栈大小则意味着最多只能创建 $1500$ 个线程

特定架构的系统上，可采用的线程栈大小最小值可以通过调用 `sysconf(_SC_THREAD_STACK_MION)` 来确定

## 线程和信号

UNIX 信号模型是基于 UNIX 进程模型设计的，问世比 Pthreads 早几十年。自然而然，信号与线程模型之间存在一些明显的冲突

> [!warning] 信号模型与线程存在冲突的原因
> 
> + 针对单线程进程要保持传统的信号语义。**Pthreads 不应该改变传统进程的信号语义**
> + 又需要开发出适用于多线程进程环境的新信号模型
> 

> [!tip] 
> 
> 信号与线程模型之间的差异意味着，将二者结合使用，将会非常复杂，应尽可能加以避免
> 

尽管如此，有的时候还是必须在多线程程序中处理信号问题

### UNIX 信号模型映射到线程中

要了解 UNIX 信号如何映射到 Pthreads 模型，就需要了解，信号模型的哪些方面属于进程层面（由进程中的所有线程所共享），哪些方面是属于进程中的单个线程层面。如下是对其关键点的汇总

> [!tip] 信号模型中属于 **进程** 的层面：即，由进程中所有线程共享
> 
> **信号动作属于进程层面**。某个线程收到未经处理的信号，其缺省动作时 `stop` 或 `terminate`，那么将停止或终止该进程中的所有线程
> 
> **对信号的处置属于进程层面**，进程中的所有 **线程共享对每个信号的处置设置**。只要有一个线程使用 `signal()` 或 `sigaction()` 为某个信号(假设 `SIGINT`)注册了信号处理器程序。那么当收到 `SIGINT` 时，任何线程都会去调用该处理函数
> 
> 
> 

> [!tip] 信号模型中属于 **线程** 的层面：即，由线程单独持有
> 
> **信号掩码是针对每个线程而言**。Pthreads API 中的 `pthread_sigmask()` 可以为线程设置信号掩码
> 
> **备选信号栈是每线程特有的**。新创建的线程并不从创建者处继承备选信号栈
> 

> [!tip] 信号模型中进程和线程 **分别维护** 的：即，进程和线程分别持有
> 
> 进程和线程的 **等待信号集** 内核分别维护 。调用函数 `sigpending()` 会返回为 **整个进程** 和 **当前线程** 所挂起信号的 **并集**
> 

### 面向线程发送信号

信号的发送既可 **针对整个进程**，也可 **针对某个特定线程**。满足如下三者之一的信号当属面向线程的

> [!tip] 发送给线程的信号
>  
> + 信号的产生 **源于线程上下文** 中对特定硬件指令的执行
> 
> + 当线程试图对已断开的管道进行写操作时所产生的 `SIGPIPE` 信号
>   
> + 由函数 `pthread_kill()` 或 `pthread_sigqueue()` 所发出的信号，这些函数允许线程向 **同一进程下的其他线程** 发送信号
> 

除了上述三个原因，由其他机制产生的所有信号都是面向进程的

### 线程的信号掩码

刚创建的 **新线程会从其创建者处继承信号掩码的一份拷贝**。线程可以使用 `pthread_sigmask()`来改变或获取当前的信号掩码

```c
#include <pthread.h>

int pthread_sigmask(int how, const sigset_t *set, sigset_t *oldset);
/* 成功返回 0；失败返回 errno */
```

`pthread_sigmask()` 的使用方法与 `sigprocmask()` 完全一直，除了前者是操作线程信号掩码之外

> [!warning] 
> 
> 在多线程程序中使用函数 `sigprocmask()`，其结果是未定义的，也无法保证程序的可移植性
> 

> [!seealso] 
> 
> 参考 [[信号集#信号掩码]] 查看 `sigprocmask()` 的用法
> 

### 向线程发送信号

函数 `pthread_kill()` 向同一进程下的其他线程发送信号

```c
#include <pthread.h>

int pthread_kill(pthread_t thread, int sig);
/* 成功返回 0；失败返回 errno */
```

> [!tip] 参数 `thread`：目标线程的标识符
> 

> [!tip] 参数 `sig`：需要发送的信号
> 

此外，还有一个 Linux 特有函数 `pthread_sigqueue()`，该函数向同一进程中的其他线程发送携带数据的信号

```c
#include <pthread.h>

int pthread_sigqueue(pthread_t thread, int sig, const union sigval value);
/* 成功返回 0；失败返回 errno */
```

`pthread_sigqueue()` 函数的使用方式与 `sigquque()` 相同

> [!seealso] 
> 
> 参考  [[信号高级特性#实时信号]] 查看 `sigqueue()` 的用法
> 

### 妥善处理异步信号

**没有任何 Pthreads API 属于异步信号安全函数**，均无法在信号处理函数中安全加以调用。所以 当多线程应用程序 **必须处理异步产生的信号** 时，通常 **不应该将信号处理函数作为接收信号到达的通知机制**

> [!tip] 多线程应用程序对异步信号的处理
> 
> + **所有线程都阻塞进程可能接收的所有异步信号**：在创建任何其他线程之前，由主线程阻塞这些信号。后续创建的线程都会复制主线程信号掩码的拷贝
> + **再创建一个专用线程**，调用函数 `sigwaitinfo()` `sigtimedwait()` 或 `sigwait()` 来接收收到的信号。参考 [[信号高级特性#同步等待信号]]
> 

这一方法的优势在于，同步接收异步产生的信号。当接收到信号时，专有线程可以安全地修改共享变量（在互斥量的保护之下），并可调用并非异步信号安全的函数。也可以就条件变量发出信号，并采用其他线程或进程的通讯及同步机制

