# 服务器设计

服务器设计有两种思路：**迭代型** 和 **并发型**

> [!tip] 迭代型服务器：**每次处理一个客户端的请求**，当该客户端的请求处理完成后才去处理下一个客户端
> 
> 服务器每次只处理一个客户端，只有当完全处理完一个客户端的请求后才去处理下一个客户端
> 

> [!tip] 并发型服务器：能够 **同时处理多个客户端的请求**

迭代型服务器通常只适用于能够快速处理客户端请求的场景，因为每个客户端都必须等待，直到前面所有的客户端都处理完了服务器才能继续服务下一个客户端。迭代型服务器的典型应用场景是当客户端和服务器之间交换单个请求和响应时

> [!attention] 迭代型服务器的使用场景：能够快速处理客户端请求
> 
> 因为每个客户端必须等待上一个客户端的请求被服务器处理完毕，所以迭代型服务器通常是在 **客户端和服务器之间交换单个请求和响应** 的场景下使用
> 

并发型服务器适用于 **对每个请求都需要大量处理时间**，或者是当客户端和服务器在进行扩展对话中 **需要来回传递消息** 的场景。下面我们讨论几种并发型服务器设计方案

## 基于进程/线程的并发型服务器

最简单的并发型服务器设计方法就是基于进程/线程的并发服务器

> [!important] 
> 
> 针对每个新的客户端连接，创建一个新的子进程来处理。每个服务器子进程执行完所有服务于单个客户端的任务后就终止
> 
> + 由于这些子进程能独立地运行，因此可以同时处理多个客户端
> 
> 服务器主进程（父进程）的主要任务就是为每个新的客户端连接创建一个新的子进程。这种方法有一个变种，即为每个客户端创建一个新的线程
> 

主程序在一个无限循环中接受客户端的连接，然后创建子进程/线程用户处理与客户端的通信。主程序的代码片段如下

```c
//...
while(true) {
	int netfd = accept(sockfd, &sockaddr, &sockLen);
	switch(fork()) {
		case -1:
			// fork 错误处理
			break;
		case 0:
			// 与客户端进行通信
			_exit(EXIT_SUCCESS);
	}
}
```

> [!summary] 
> 
> 优点
> 
> + 代码简单
> + 进程/线程都具有隔离性，一个进程/或线程错误不会导致程序卡死
> 
> 缺点
> 
> + 并发量低：进程/线程占用内存大
> + 性能差：进程/线程数量太多从而导致切换时间长；创建和释放进程/线程导致性能降低
> + 处理不同的客户端的调度有内核控制，非常麻烦
> 

## 事件驱动的并发型服务器

服务端做的主要事情就是处理客户端发送过来的消息并响应对应的数据。例如，在 [[作业41：SOCKET 概览 和 SOCKET 地址转换#聊天服务器]] 和 [[作业42：Linux epoll]] 实现的聊天服务器。当客户端发送了消息，服务端将消息读取出来并转发给其他客户端。就是基于 **读事件就绪** 实现的。

基于事件驱动的服务器的基本结构如下

```c
while(true) {
	// select/poll/epoll 监控多路 IO
	int nfds = epoll_wait(epfd, events, maxlength, timeout);
	if(nfds == -1) {
		// 错误处理
	}
	// ...
}
```

> [!summary] 
> 
> 优点
> + 并发量高，内核中的文件对象占用的系统资源少。可以监控跟多的客户端
> + CPU 调度消耗小。单线程，CPU 调度简单
> + 处理不同的客户端是在用户态切换的，不涉及陷入操作系统
> 
> 缺点
> + 导致业务代码实现困难
> + 不能有效利用多核 CPU：只有一个线程，无法有效利用多核 CPU
> 

> [!example] 业务代码实现困难
> 
> 假设一个业务需要读取 $3$ 的客户端发来的消息。如果使用进程/线程模式，由于进程/线程是隔离的，不会相互影响。因此，让这 $3$ 个读取操作在各自的进程/线程中读取即可
> 
> 然而，如果使用事件驱动模型，就不能连续的读。假设在等待第 $1$ 客户端发来消息的同时，第 $2$ 个客户端发来了消息。此时，我们并不能立即处理第 $2$ 个客户端的消息，需要等待。因此，为了能立即响应各个客户端，就需要将每个客户端拆分出来，形成一个独立的事件
> 

```c
while(true) {
	select(...);
	
	// 事件 A
	if(A) {
		recv(A,...);
	}
	
	// 事件 B
	if(B) {
		recv(B,...);
	}
	
	// 事件 C
	if(C) {
		recv(C,...);
	}
}
```

## 适用于多核CPU的事件驱动模型

为了使事件驱动模型适用于多核 CPU，可以将事件驱动模型与基于进程/线程模型组合起来。这种组合方式有许多种。下面，我们将介绍一个简单的组合方式

我们让 **主进程/线程监控每个客户端的连接套接字**，当客户端发送来消息时，**产生一个任务**，然后，**唤醒** 一个 **空闲** 的进程/线程来处理这个任务

![Pasted image 20241206235626|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755784817077-27f8717a3d0e4b59aaea7abd78d453f3.png)

这样 主进程/线程 的职责就是 **创建和管理 worker** 和 **event loop 处理客户端连接**。工作进程/线程就负责与客户端保持通信即可

> [!summary] 
> 
> + 创建出来的进程/线程完成工作后，并不是立即将其释放，而是陷入空闲状态
> + 当有新任务时，就使用空闲的进程/线程来执行这个任务
> 
> 这就是 **进程池** 和 **线程池** 的概念。这样就能屏蔽掉不断创建进程/线程和释放进程/线程带来的性能损失
> 
> 主进程/线程采用事件驱动模型，当事件就绪时产生任务，并将该任务交给进程池或线程池执行
> 

> [!tip] 池：**提前申请好的一批资源**
> 
> 这是解决类似于创建和释放带来性能损失的方法。
> + **TCP 连接池**： 建立 TCP 连接就是一种耗时操作，就可以提前建立好一批连接，每次要使用的时候，就使用这些已经建立好的连接
> + **内存池**：分配内存也是一种耗时操作。程序运行时就提前分配好内存，然后需要的时候就从已分配的内存划出即可，不需要再向操作系统申请
> 

所谓的 **进程池** 和 **线程池** 也是类似的。程序在运行时就 **提前创建若干个子进程/线程**。创建的数量通常是 **CPU 核心数的 $1\sim 2$ 倍**
+ 有任务需要执行时，分配一个空闲的进程/线程执行
+ 当任务执行完成时，进程/线程回到空闲状态

> [!tip] 
> 
> + 如果是 **计算密集型** 任务，就创建 $1$ 倍 CPU 核心数
> + 如果是 **IO 密集型** 任务，就创建 $2$ 倍 CPU 核心数
> 

