# 基本概念

C 语言是 `Dennis Ritchie` 和 `Ken Thompson` 于 1972 年在贝尔电话实验室开发的。他们合著的  《C 程序设计语言》 成为了许多 C 程序员的圣经

1983 年，美国国家标准学会(`ANSI`)成立了 `X3J11` 委员会来建立一个标准的 C 语言规范。1989 年，C 语言标准被批准为 `ANSI X3.159-1989`。C语言标准的 `1989` 版本称为 `ANSI C` 或 `C89`。

国际标准化组织(`ISO`)和国际电工委员会(`IEC`)组成的联合技术委员会
- 于 1990 年通过了 `ANSI C` 标准（未做修改），并作为 C 语言标准的第一版，即 `C90`，发布(`ISO/IEC 9899:1990`)
- C 语言标准的第二版，即 `C99`，于 1999 年发布(`ISO/IEC 9899:1999`)
- 第三版，即 `C11`，于 2011 年发布(`ISO/IEC 9899:2011`)
- 第四版，即 `C17`，于 2018 年发布(`ISO/IEC 9899:2018`)
- `ISO/IEC `正在编制一个新的主要修订版，即为 `C23`，于 2024 年发布(`ISO/IEC 9899：2024`)


C 语言标准(`ISO/IEC 9899：2024`) 定义了该语言，是语言行为的最终权威。尽管标准晦涩难懂，但如果打算编写 **可移植**、**安全** 且 **可靠** 的代码，就必须理解标准。C 语言标准为实现提供了很大的自由度，使其在各种硬件平台上都能实现最佳效率。

> [!tip] 
> **实现**(`implementation`) 是 C 语言标准中用来 **指代编译器的术语**，定义为：特定的一组软件，运行在特定控制选项下的特定翻译环境中，为特定的执行环境翻译程序，并支持在特定的执行环境中执行函数
> + 这个定义表明，每个具有 **特定命令行选项的编译器和 C 标准库**，都被认为是一个 **独立的实现**，不同的实现可以有明显不同的由实现定义的行为
> + `GCC`（GNU Compiler Collection, GNU 编译器合集）中很明显，它使用 `-std=` 选项来指定语言标准：可能取值包括 `c89`、`c90`、`c99`、 `c11`、`c17`、`c18` 和 `c23`
> 

## 第一个 C 程序

学习任何一门编程语言的最好的方式就是使用它编写程序。经典教程《C 程序设计语言》中的入门程序就是在控制台输出 `"Hello, world!"`。要编写这个程序，需要一个 **文本编辑器** 或 **集成式开发环境**（Integrated Development Environment，**IDE**），这些工具有很多，现在我们使用 vscode 来编写我们的程序

```c title:hello.c
#include <stdio.h>

int main(int argc, char *argv[]) {
    printf("hello, world!\n");
    return 0;
}
```

### 编译并运行程序

使用 GCC 编译并运行该程序的命令如下

```shell
➜  cfiles gcc hello.c 
➜  cfiles ./a.out 
hello, world!
```

GCC 命令有大量的标志和编译器选项。`-o file` 可以让你用指定的可执行文件
名代替默认的 `a.out`。下列命令将可执行文件名指定为 `hello`。

```shell
➜  cfiles gcc -o hello hello.c 
➜  cfiles ./hello
hello, world!
```

现在来逐行考察 `hello.c` 程序

### 程序结构

#### 预处理指令

`hello.c` 中的第一行是 **预处理指令** `#include`，其行为就像是在同样的位置 **使用指定文件的内容替换** 相应的预处理器指令。引入头文件 `<stdio.h>`，方便调用其中声明的函数 `printf()`

```c hl:1 title:hello.c
#include <stdio.h>  
  
int main(int argc, char *argv[]) {  
    printf("hello, world!\n");  
    return 0;  
}
```

> [!tip] 
> `<stdio.h>` 包含 C 标准 `I/O` 函数的声明

#### `main` 函数

```c hl:3 title:hello.c
#include <stdio.h>  
  
int main(int argc, char *argv[]) {  
    printf("hello, world!\n");  
    return 0;  
}
```

`main` 函数在 **程序启动时调用**。当从命令行或其他程序中调用该程序时，**`main` 函数定义了在 _托管环境_ 中的 _主入口点_**

> [!tip] C 定义了两种可能的执行环境：**独立环境**（freestanding）和 **托管环境**（hosted）。
> + **独立环境可能不提供操作系统**，通常用于嵌入式编程。这类实现提供了最小数量的库函数，**程序启动时调用的函数名和类型由实现定义**
> + **托管环境提供操作系统**。这类实现提供了大量的库函数和系统调用，程序启动时调用 `main` 函数
> 

我们假设处于托管环境中。将 `main` 定义为返回 `int` 类型的值。*`int` 类型* 是一种有符号整数类型，可用于表述 *正整数* *负整数* 以及 *0*

类似于其他过程语言，**C 程序由能够接受参数并返回值的过程（称为 _函数_）组成**。每个函数都是一个 **_可重用的工作单元_**，可以在程序中 **根据需要频繁调用**

程序第 $4$ 行的 `printf` 函数执行格式化输出函数，用于将字符串模板参数写入 `stdout`（通常代表控制台或终端窗口）

```c hl:4 title:hello.c
#include <stdio.h>  
  
int main(int argc, char *argv[]) {  
    printf("hello, world!\n");  
    return 0;  
}
```

`"Hello, world!"` 是一个字符串字面量，其行为就像是只读字符串

程序结束后，如果想退出，可以在 `main` 函数中使用 `return` 语句，以此向托管环境或调用脚本返回一个整数值。`main` 函数的返回值指明该程序是否顺利结束

> [!tip] 
> + `main` 函数返回值为 $0$ 代表程序正常结束
> + `main` 函数返回值为非零，代表程序异常结束
> 

#### 检查函数的返回值

>[!tip]
> 函数往往会返回一个值，要么 *作为计算结果*，要么 *指明该函数是否顺利完成任务*

`printf()` 函数会将指定的字符串模板格式化后并输出。如果写入错误就会返回 `EOF`，成功则返回写入的字节数

```c title:hello.c
#include <stdio.h>

int main(int argc, char *argv[]) {
    int number;
    if ((number = printf("hello, 世界!\n")) == EOF) {
        return -1;
    }
    printf("number = %d\n", number);
    return 0;
}
// gcc hello.c -o hello.exe

```

### 程序是如何生成的

下图给出了 GCC 编译 C 程序的完整过程。我们会详细介绍每个过程

![Pasted image 20241004004518|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755700369838-945ea452d7554dab975f4e20a5033fc5.png)

#### 预处理

编译器首先会调用 **预处理器**，预处理器会解析源码中的 **预处理指令**。这里我们介绍两种预处理指令：**头文件包含** 和 **宏定义**

##### 头文件包含指令 `#include`

头文件包含指令使用 `#include <file.h>`，该指令会使用 `<file.h>` 中的内容替换 `#include <file.h>` 指令

比如，使用 `gcc -E hello.c -o hello.i` 指定 **只执行预处理**，后的内容如下

```c title:hello.i
# 0 "hello.c"  
# 0 "<built-in>"  
# 0 "<command-line>"  
# 1 "/usr/include/stdc-predef.h" 1 3 4  
# 0 "<command-line>" 2  
# 1 "hello.c"
....
# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 1 3 4  
# 209 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 3 4  
  
# 209 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 3 4  
typedef long unsigned int size_t;  
# 34 "/usr/include/stdio.h" 2 3 4
.....

extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);
      
extern int printf (const char *__restrict __format, ...);
....
# 3 "hello.c"  
int main(int argc, char *argv[]) {  
    printf("hello, world!\n");  
    return 0;  
}
```

> [!hint] 
> 
> `#include <file>` 指令是我们经常使用的预处理指令之一，它的作用就是拷贝 `file` 文件到当前文件中。
>  
>  例如，上述 `#include <stdio.h>` 被替换为了 `<stdio.h>` 中的内容
> 

##### 宏定义

C 语言中，宏定义分为两种: **对象式宏** 和 **函数式宏**。下面我们首先介绍对象式宏

###### 对象式宏

**对象式宏** 本质上就是 **替换文本**，用于替换某些字面值或符号，以提高可读性。例如，在 C89 标准中，没有提供布尔类型，而是采用整数表达布尔值

>[!tip]
>+ `True` 使用整数 `1` 表示
>+ `False` 使用整数 `0` 表示
>

为了不在程序中直接使用字面值，**宏定义允许我们使用替换文本替代字面值**

```c
#define True 1
#define False 0
```

> [!tip]
> 
> **对象式宏主要用来给字面值命名**。存在许多优点
> +  程序会更易读
> + 程序会更易于修改
> + 可以帮助避免前后不一致或键盘输入错误

> [!attention]  
> 
> 宏定义在预处理时只进行 **简单替换**。代码中的 `True`(表达式的操作数) 会被替换为 `1`，并不做额外处理
> 

###### 函数式宏

**函数式宏** 是 _带参数_ 的宏，替换文本可以提供一些参数，被替换的文本可以动态变化。例如，函数式宏 `max` 定义了一个获取两个元素中最大值的宏

```c
#define max(A, B) ((A) > (B) ? (A) : (B))
```

>[!attention] 
>
>需要注意 `max` 和 `()`  之间没有空格，否则 `max` 变为对象式宏
>
>**替换文本** 及其 **参数** 通常需要使用圆括号(`()`) 括起来，以避免 **简单替换** 带来的运行优先级不明的问题
>
>警惕：宏函数可能带来的 **多次副作用** `max(i++, j++)` => `((i++) > (j++) ? (i++):(j++))`
>

当我们以 `max(p+q, r+s)` 调用 `max` 宏时，宏参数 `A` 和 `B` 就会被 `p+q` 和 `r+s` 简单的替换

```c
//  A         B         A         B
((p + q) > (r + s) ? (p + q) : (r + s))
```

简单替换带来的错误的一个例子。我们有如下定义的一个函数式宏

```c
#define square(x) x * x
```

当我们调用 `square(i+1)` 时，会被替换为 `i + 1 * i + 1`。这是不我们期望的表达式。因此，**使用圆括号包裹所有宏参数是非常有必要的**

表达式 `1/square(x)` 时，会被替换为 `1 / x * x`。这也不是我们期望的表达式。因此，将整个替换文本使用圆括号包裹起来也势在必行

我们修改 `square` 宏的定义为如下形式时，就不会出现任何问题

```c
#define square(x) ((x) * (x))
```

> [!tip]
> 
> 使用 **宏函数** 可以比普通函数执行效率更高。宏函数不涉及参数传递，保存寄存器值等操作 
> 

#### 编译

将 `*.i` 文件中的代码(预处理之后的代码)翻译为对应平台的 **汇编代码**

> [!hint] 
> 
> [godbolt](https://godbolt.org/) 是一个在线的编译器平台。可以方便的观察 C 代码生成的汇编指令
> 

#### 汇编 和 链接

汇编阶段将汇编代码翻译为目标平台可识别的机器码(**目标程序**)。链接阶段将目标程序需要的库函数进行链接， **可执行文件**

### 程序是如何执行的

程序仅仅只是一个可执行的文件。在 Linux/Unix 中采用的是 **ELF(Executable and Linkable Format) 格式文件**；Windows中采用 **PE 格式文件**。我们以 ELF 文件为例子介绍。ELF 文件包含 $4$ 部分，如下图所示

![Pasted image 20241004004451|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755700751059-33bad709b68f4dfea0a296f9c107fa0e.png)

> [!tip] 
> ELF 文件中 **不一定包含全部内容**，而且它们的位置 **只有ELF头是固定的**，其余各部分的位置、大小等信息由 ELF 头中的各项值来决定
> 

#### 进程及其虚拟内存空间

程序要执行就需要被加载到计算机内存中，当 **程序被加载到内存中** 之后，可以称其为 **进程**

> [!tip]
> 
> **程序**：程序是可执行 **文件** (ELF格式的文件或 PE 格式的文件)
> 
> **进程**：进程简单来讲就是 **正在执行的程序**
> 

操作系统采用 **虚拟内存**，提供了 **进程独占所有物理内存** 的假象。在进程中看见的地址都是虚拟内存地址。下图展示了 **进程虚拟内存地址的结构**

![Pasted image 20241013130418|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755700888676-0975388a1ad74852b746c12312df74c1.png)

> [!tip] 非标准特性
> 
> 大多数 UNIX 实现（包括 Linux）中 C 语言编程环境提供了 $3$ 个全局符号：`etext` `edata` 和 `end`，可在程序内使用这些符号以获取相应程序文本段、初始化数据段和非初始化数据段结尾处下一字节的地址。在程序中使用必须显示声明
> 
> ```c
> extern char etext, edata, end;
> ```
> 
> 不是所有的系统都支持这个特性
> 

## 变量与常量

**对象** 是可以在其中 **表示值的一块存储区域**。

> [!tip] ISO/IEC 9899:2018 标准定义的对象
> 
> 执行环境中的 **数据存储区域**，其内容可用于表示值。 在被引用时，对象可以具有特定的类型
> 
> 变量就是对象的一个例子
> 

### 变量

变量本质上就是一块 **数据存储区域**，其中存储的 **位模式** 可用于表示值。变量被引用时，会根据特定的 **类型** 解释位模式的含义

> [!tip] **类型** 决定了存储区域的尺寸和其存储的位模式的含义
> 
> 类型决定了存储区域的 **尺寸**，以及其中存储的 **位模式表示的内容**
> 

如何引用一个变量呢？C 语言(大部分语言)中采用 **变量名** 引用一块内存区域(对象)。下图形象的表示一个变量

![Pasted image 20241004004409|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755701028908-7ea8e39e6b714242932d5ac139e2edb1.png)

**变量在使用前要先声明** 。在 C 语言中，声明一个变量的语法如下

```c
<类型> <变量名> [= 初始值] [, <变量名>[= 初始值], ...]
```

> [!tip] 类型：用来说明变量所存储的数据的种类
>  
>  目前，我们将只限定在两种类型范围内：`int` 类型和 `float` 类型
> 
> `int`(`integer`)型变量可以存储 _整数_，如 `0` `1` `392` 或 `-2553`。`int`类型变量的取值范围有限，最大的整数通常是 `2 147 483 647`，但在某些计算机上也可能是 `32 767`
> 
> `float`(`floating-point`)型变量可以存储比 `int` 型变量大得多的数值。`float` 类型的变量可以存储 _带小数的数_，如 `379.125`
> + `float` 型变量所存储的数值往往只是实际数值的一个近似值。如果在一个 `float` 型变量中存储 `0.1`，以后可能会发现变量的值为 `0.099 999 999 999 999 87`，这是舍入造成的误差
> 

> [!tip] 变量名：指代一个对象
> 
> 这里的 **对象** 是一个表示 **数据存储区域**。当这块数据存储区域被引用时，保存在此的位模式就会按照 **类型** 进行解释
> 

> [!tip] 初始值
> 
> 指定数据存储区域中最开始的位模式
> 

如下示例代码片段，演示了如何什么一组变量。由于我们没有提供初始值，这个变量的值是不可信的

```c
// 声明几个相同类型的变量
int height, length, width, volume;
float profit, loss;
```

变量通过 **赋值** 的方式获得值。如下所示，赋值运算符(`=`)表示将其右边的值写入到左边变量中 

```c
height = 8; 
length = 12; 
width = 10;
```

> [!attention] 
> 
> 请注意，赋值运算符(`=`)的左侧必须是一块存储区域
> 

变量一旦被赋值，就可以用它来辅助计算其他变量的值

```c
height = 8; 
length = 12; 
width = 10; 

/* 通过变量名引用对象的值 */
volume = height * length * width; /* volume 现在是 960 */
```

### 常量与常量表达式

常量本质和变量一样，唯一不同的就是 **数据存储区域中的 _位模式不能被修改_**

C 语言中提供了三种常量：**字面值常量**、**符号常量** 和 **const 常量**

> [!tip] 
> 
> + **字面值常量**：写出来就是一个值，不需要做内存引用。它可以用于初始化变量或常量
> + **符号常量**：本质上也是字面值常量，通过 `#define` 指令创建
>
>字面值常量和符号常量可以在编译时求值。
>   
> + **const常量**：使用 `const` 关键字定义的 **只读变量**，`const` 定义的只读变量不会在编译时求值
>

声明一个常量的语法只需要在变量声明语法的基础上添加一个 `const` 关键字即可。

```c
const <类型> <常量名> = 初始值
```

> [!tip] 
> 
> 由于常量时不能修改的，因此 **在声明常量时必须提供初始值**
> 

```c
#define M 10  // 定义了一个符号常量 M，它的值是 10

const int N = 10; // 定义了一个只读变量(常量)，它的值是 10
```

> [!tip] 使用 `const` 定义只读变量时，必须提供初始值
> 
> + 在编译时 `const` 定义的只读变量的值可能是不定的
> 

**常量表达式**：能够 **在编译时求值** 的表达式，称为常量表达式。

> [!tip]
> 
> **常量表达式** 最核心的要求就是 **_编译时求值_**。也就是说，常量表达式只能由 _字面值常量_ 和 _符号常量_ 组成
> 

C23 标准新增了一个关键字 `constexpr`，该关键字用于声明一个 **常量表达式对象**，该对象可以当做常量表达式使用

```c
constexpr int M = 10; 
```

>[!attention]  
>C23 标准的提供的 `constexpr` 关键字只能用于声明对象，不能用于声明函数
>

常量表达式通常用于声明数组时指定长度；在 `switch` 语句中的 `case` 标签中

```c
#define N 10

int num[10] = {};  // 使用字面值常量
int num[N] = {};   // 使用符号常量

constexpr int M = 10; // 使用 constexpr 常量
int num[M] = {};

const Z = 10;
int num[Z] = {0}; // error：const 常量不是编译时求值的
```

> [!tip] 
> 
> C99 标准支持 **变长数组**，因此使用 C99 即之后的标准，在声明数组时不要求数组的长度为常量表达式
> 
> + 关于数组的更详细内容在 [[C 语言：数组]] 中介绍
> 

```c
#include <stdio.h>

#define N 10

const int M = 11;

constexpr int Z = 12;


int main(int argc, char *argv[]) {

    int i;
    scanf("%d", &i);

    switch (i) {
        case N:  // 常量表达式；N 等价于 10
            printf("%d\n", N);
            break;
        case M:  // 不是常量表达式；M 不能再编译时求值
            printf("%d\n", M);
            break;
        case Z: // constexpr 声明的变量在编译时获得值
            printf("%d\n", Z);
            break;
        default:
            printf("Hello 世界!\n");
    }

    return 0;
}
```

> [!attention]  
> 
> 这段代码是不能通过编译的，因为 `const` 声明的变量 `M` 不能作为常量表达式
> 

## 标识符与关键字

**标识符**(`identifier`) 为 _变量_ _常量_ _宏_ _函数_ 等程序对象起的 **名字**，称为 **标识符**。命名需要遵循一些规则

> [!tip] 命名规则
> + **只能包含** _字母_(英文字母) _数字_ 和 _下划线_(`_`)
> + **数字不能打头**
>

> [!tip] 命名规范
> 
> 多词名字可以采用 **蛇形命名** 或 **驼峰命名**
> 
> + **蛇形**：单词之间使用下划线(`_`)区分
> + **驼峰**：单词之间使用大小写进行区分
> 
> 名字需要做到 **见名知义**，名字需要提供较高的可读性
> 

> [!attention] 注意事项
> 
> 标识符区分大小写：`Job` `job` `JOB` 是三个不同的标识符
> 
> **关键字** 不能做完标识符
> 

**关键字** 语言使用的具有特殊含义的名字称为 [关键字](https://en.cppreference.com/w/c/keyword)

| 关键字         | 起始标准    | 废弃标准 | 关键字              | 起始标准    | 废弃标准  |
| :---------- | :------ | ---- | :--------------- | :------ | ----- |
| `alignas`   | `>=C23` |      | `sizeof`         |         |       |
| `alignof`   | `>=C23` |      | `static`         |         |       |
| `auto`      |         |      | `static_assert`  | `>=C23` |       |
| `bool`      | `>=C23` |      | `struct`         |         |       |
| `break`     |         |      | `switch`         |         |       |
| `case`      |         |      | `thread_local`   | `>=C23` |       |
| `char`      |         |      | `true`           | `>=C23` |       |
| `const`     |         |      | `typedef`        |         |       |
| `constexpr` | `>=C23` |      | `typeof`         | `>=C23` |       |
| `continue`  |         |      | `typeof_unqual`  | `>=C23` |       |
| `default`   |         |      | `union`          |         |       |
| `do`        |         |      | `unsigned`       |         |       |
| `double`    |         |      | `void`           |         |       |
| `else`      |         |      | `volatile`       |         |       |
| `enum`      |         |      | `while`          |         |       |
| `extern`    |         |      | `_Alignas`       | `>=C11` | `C23` |
| `false`     | `>=C23` |      | `_Alignof`       | `>=C11` | `C23` |
| `float`     |         |      | `_Atomic`        | `>=C11` |       |
| `for`       |         |      | `_BitInt`        | `>=C23` |       |
| `goto`      |         |      | `_Bool`          | `>=C99` | `C23` |
| `if`        |         |      | `_Complex`       | `>=C99` |       |
| `inline`    | `>=C99` |      | `_Decimal128`    | `>=C23` |       |
| `int`       |         |      | `_Decimal32`     | `>=C23` |       |
| `long`      |         |      | `_Decimal64`     | `>=C23` |       |
| `nullptr`   | `>=C23` |      | `_Generic`       | `>=C11` |       |
| `register`  |         |      | `_Imaginary`     | `>=C99` |       |
| `restrict`  | `>=C99` |      | `_Noreturn`      | `>=C11` | `C23` |
| `short`     |         |      | `_Static_assert` | `>=C11` | `C23` |
| `signed`    |         |      | `_Thread_local`  | `>=C11` | `C23` |

## 格式化输入和输出

在 [[计算机组成：计算机组成原理]] 我们知道最简单的计算机必须包含三个子系统：**中央处理单元(_CPU_)** **主存储器(内存)** 和 **IO 子系统(_存储设备/非存储设备_)**。由于这三个子系统的实现材料不同，导致它们的 **_运行频率存在巨大差异_**。为了平衡它们之间的差异，计算机设计者们采用 [[计算机组成：计算机组成原理#存储器层次结构|存储器层次结构]] 来 _缓解由于 IO子系统低效带来的性能损失_

在 **存储器层次结构** 中，_距离 CPU 越近的存储器工作频率越高_，这种存储器在存储器层次结构的金字塔中处于的位置越越高

![Pasted image 20240922002317|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755701482895-d5e6eec7fa1e4095abdcdc9cf1d52627.png)


上层的存储器通常作为下层存储器的 **缓冲**。这里，我们需要注意区分 **缓冲(buffer)** 和 **缓存(cache)**

> [!tip] **缓冲**：是对 **数据的暂存**
> 
> 批量传输或者写入。多使用顺序方式，用来缓解不同设备之间运行频率差异带来的性能损失
> 
>+ 缓冲区：平衡系统两端处理速度的差异，用于 **减小短期内突发 I/O 的影响**
> 

> [!tip] **缓存**：是对 **已读数据的复用**
> 
> 缓存是将反复被使用的数据存储起来，供程序直接读取，避免反复计算或从数据库中读取
> 
> 


因此，进程在执行输入输出时，都需要经过 **缓冲区**。因此从输入到输出的流程如下图

![Pasted image 20240922003312|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755701495667-4c113b4fdf1340be9985b7ecbd80d166.png)

### 格式化输出

标准库 `<stdio.h>` 提供了一个函数 `prinf()`，该函数用于执行 **格式化输出**。该函数将内容 **输出在屏幕上(标准输出)**

```c
 int printf (const char * restrict format, ...);
```

`printf` 函数将 **`format` 字符串** 中 _转换说明_ 位置插入后续指定的值。返回值表示 _写入标准输出的字节数_；如果写入失败，返回 `EOF`

`format` 字符串包含两类字符：**普通字符** 和 **转换说明**

> [!tip] 
> 
> _普通字符_ 不做任何修改的 **直接输出**
> 
> _转换说明_ 根据其在 `format` 字符串中的位置，使用 `printf()` 中 `format` 之后的其余参数，**按顺序进行替换**
> 

_转换说明_ 包含 字符`%` 和跟随其后的最多 $5$ 个不同的选项构成。下图给出了转换说明的示例

![Pasted image 20240922005552|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755701509953-85a95eaac0ab47afb5982deb12c3b19b.png)


> [!hint] 标志，可选
> + `-` 左对齐，默认右对齐
> + `+` 有符号数转换得到的数总是以 `+` 或 `-` 开头。通常只有负数前面附上 `-`
> + `#` 以 `0` 开头显示八进制，以 `0x` 或 `0X` 开头的十进制非零数
> + `0` 使用前导 $0$ 在栏宽内进行填充 
> 

> [!hint] 最小栏宽，可选
> 
> 如果数据项太小以至于 _无法达到这一宽度_，那么会 _进行填充_。默认使用空格，通过标志位可以指定使用 `0` 进行填充
> 
> 如果数据项过大以至于 _超过了这个宽度_，那么会 _完整地显示_ 数据项
> 
> 最小栏宽可以指定为整数或字符 `*`。当指定为字符 `*` 时，栏宽由参数决定
> 

> [!hint] 精度，可选
> 
> 精度的含义依赖于转换指定符
> 
> + 如果转换指定符为 `d, i, o, u, x, X`(**_整数_ 的转换指定符**)，那么精度的含义表示 **显示最小位数**（如果位数不够，则添加前导零）
> 
> + 如果转换指定符为 `a, A, e, E, f, F`(**_浮点数_ 的转换指定符**)，那么 精度的含义表示 **小数点后的位数**
> 
> + 如果转换指定符为 `g, G`(浮点数转换指定符，自动选择 `e` 或 `f` 格式)，那么精度表示 **有效数字的个数**
> 
> + 如果转换指定符是 `s` (**_字符串_ 转换指定符**)，那么精度表示 **最大字节数**
>
> 精度可以指定为 `.整数` 或 `.*`。当指定为 `.*` 时，精度由参数决定
>

> [!tip] 转换指定符，必须的
> 
> 转换指定符说明了 _以什么类型引用对象_，并控制 _输出的字符串形式_
> 
> + `d`： 表示 [[计算机组成：数字系统#十进制系统：以 $10$ 为底|十进制]] (基数为 $10$)形式的 **整数** 字面值字符串输出
> + `e`：表示指数（科学记数法）形式的 **浮点数** 字面值字符串输出
> + `f`：表示 _定点十进制_ 形式的 **浮点数** 字面值字符串输出
> + `g`：表示指数形式或者定点十进制形式的浮点数，形式的选择根据数的大小决定。_转换将不显示尾随的零_
> 

```c
#include <stdio.h>

int main(int argc, char *argv[]) {
    constexpr int i = 40;
    constexpr float f = 839.12f;

    printf("|%d|%5d|%-5d|%5.3d|\n", i, i, i, i);
    printf("|%f|%10f|%10.2f|%-10.2f|\n", f, f, f, f);

    return 0;
}
```

> [!tip]
> 
> 长度指定符在数据类型之后介绍
> 

### 格式化输入

标准库 `<stdio.h>` 提供了一个函数 `scanf()`，该函数用于执行 **格式化输入**。该函数 **从标准输入中读取数据** 

```c
int scanf (const char * restrict format, ...);
```

`scanf()` 函数本质上是一种 **模式匹配** 函数：试图把输入的字符组与转换说明相匹配，然后 _将字符组转换为指定的数据类型的值_，并 _存入_ 后续参数指定的 _数据存储区域(**指针**)_。返回值表示成功处理转换说明的个数

调用时，`scanf` 函数 **从左边开始处理字符串中的信息**。对于格式串中的每一个转换说明， `scanf` 函数从输入的数据中 _定位适当类型的项_，并在必要时 _跳过空格_。然后，`scanf` 函数读入数据项，并且在遇到不可能属于此项的字符时停止。如果读入数据项成功，那么 `scanf` 函数会继续处理格式串的剩余部分；如果 **某一项不能成功读入**，那么 `scanf` 函数将不再查看格式串的剩余部分（或者余下的输入数据），并 **立即返回**。

在寻找数的起始位置时，`scanf` 函数会 **忽略空白字符**（`white-space character`，包括 _空格符_、_水平和垂直制表符_、_换页符和换行符_）。因此，我们可以把数字放在同一行或者分为几行来输入

当 `scanf` 函数遇到一个不可能属于当前项的字符时，它会把此字符 _放回原处_，以便在扫描下一个输入项或者下一次调用 `scanf` 函数时再次读入

```c
#include <stdio.h>

int main(int argc, char *argv[]) {

    int i;
    float f;
    scanf("%d %f", &i, &f);

    printf("i = %d, f = %f\n", i, f);

    return 0;
}
```

> [!tip]
> 
> `scanf` 函数的`format` 参数通常 **只包含转换说明**
> 

以 `scanf("%d%d%f%f", &i, &j, &x, &y);` 方式调用 `scanf` 函数；假设用户的输入为 `1-20.3-4.0e3`，那么 `i, j, x, y` 的值分别是多少？下面列出了 `scanf` 函数处理这组输入的方法

+ 转换说明 `%d`。第一个非空的输入字符是 `1`；因为整数可以以 `1` 开始，所以 `scanf` 函数接着读取下一个字符，即`-`。`scanf` 函数识别出字符 `-` 不能出现在整数内，因此把 `1` 存入变量 `i` 中，而把字符 `-` 放回原处
+ 转换说明 `%d`。随后，`scanf` 函数读取字符 `-` `2` `0`和 `.`。因为整数不能包含小数点，所以 `scanf` 函数把 `–20` 存入变量j中，而把字符 `.` 放回原处
+ 转换说明 `%f`。接下来 `scanf` 函数读取字符 `.` `3` 和 `-` 。因为浮点数不能在数字后边有负号，所以 `scanf` 函数把 `0.3` 存入变量 `x` 中，而把字符 `-` 放回原处
+ 转换说明`%f`。最后，`scanf` 函数读取字符`-` `4` `.` `0` `e` `3` 和 `\n`（换行符）。因为浮点数不能包含换行符，所以 `scanf` 函数把 $-4.0 \times 10^3$ 存入变量 `y` 中，而把换行符放回原处

> [!tip] 
> 
> `scanf` 函数从左到右依次匹配转换说明，直到匹配结束或者遇到不可转换的输入，`scanf` 立即返回成功匹配的转换说明的个数
>

## 基本类型

C 语言支持两种根本不同的 **数值类型**：_整数类型_（也称整型）和 _浮点类型_（也称浮点型）

### 整型

整数类型分为两类：**有符号整数** 和 **无符号整数**。C 语言中，整数类型使用关键字 `int` 声明，默认是有符号的。如果需要声明为无符号整数，使用关键字 `unsigned` 限定 `int` 为无符号整数

| 符号限定符      | 描述      |
| :--------- | :------ |
| `signed`   | 有符号，默认的 |
| `unsigned` | 无符号     |

C 语言的整数类型有 **不同的大小**。`int` 类型的变量通常占 $32$ 位，但在老的 CPU 上可能是 $16$ 位。使用 `long` 关键字声明比 `int` 类型大的变量，`short` 关键字声明比 `int` 类型小的变量

| 长度限定符   | 描述              |
| :------ | :-------------- |
| `short` | 尺寸比 `int` 短或者相等 |
| `long`  | 尺寸比 `int` 长或者相等 |

下表列出了 C 语言支持的整数类型

| 整数类型                                   | 描述           |
| :------------------------------------- | :----------- |
| `short int` `signed short int`         | 有符号短整数       |
| `unsigned short int`                   | 无符号短整数       |
| `int` `signed int`                     | 有符号整数        |
| `unsigned int`                         | 无符号整数        |
| `long int` `signed long int`           | 有符号长整数       |
| `unsigned long int`                    | 无符号长整数       |
| `long long int` `signed long long int` | 有符号长长整数（C99） |
| `unsigned long long int`               | 无符号长长整数（C99） |

#### 整型对象

##### 值

整型对象中保存的 **位模式**  可以按照两种编码进行解释：**无符号编码** 和 **补码编码** 

假设整型对象 $x$ 占 $n$ 为，其位模式为 $[x_{n-1},x_{n-2}, \cdots,x_{2},x_{1},x_{0}]$ 按照 **无符号编码** 解释为，整型对象 $x$ 的值为

$$
x = \sum_{i=0}^{n-1} 2^{i} \cdot x_{i}
$$

假设整型对象 $x$ 占 $n$ 为，其位模式为 $[x_{n-1},x_{n-2}, \cdots,x_{2},x_{1},x_{0}]$ 按照 **补码编码** 解释为，整型对象 $x$ 的值为

$$
x = -2^{n-1} \cdot x_{n-1} + \sum_{i=0}^{n-2} 2^{i} \cdot x_{i}
$$

> [!tip] **无符号编码** 和 **补码编码** 差异
> 
> 无符号编码：位模式的所有位都表示数值。第 $i$ 为的权重为 $2^{i}$ 
> 
> 补码编码：位模式的最高位表示符号为，但是最高位同时包含权重信息；最高位的权重为 $-2^{n-1}$
> 
> 

关于整数编码的更多信息参考 [[计算机组成：数据存储#存储整数]] [[计算机组成：整数的表示与运算]] [[计算机组成：浮点数表示与运算]]

##### 尺寸

C 标准没有明确规定整数类型的具体尺寸，可能随着机器或者编译器实现而不同。标准只规定了整数类型的尺寸应该满足下面的关系

`sizeof(short int) <= sizeof(int) <= sizeof(long int) <= sizeof(long long int) `

> [!tip] sizeof 运算符
> `sizeof` 是 C 语言的一个运算符，用户获取对象或类型的尺寸(字节为单位)

在 $64$ 位的机器上整数类型的常见尺寸为

| 类型                       | 尺寸             | 取值范围                  |
| :----------------------- | :------------- | --------------------- |
| `short int`              | $2$ 字节（$16$ 位） | $[-2^{15}, 2^{15}-1]$ |
| `unsigned short int`     | $2$ 字节         | $[0, 2^{16}-1]$       |
| `int`                    | $4$ 字节（$32$ 位） | $[-2^{31}, 2^{31}-1]$ |
| `unsigned int`           | $4$ 字节         | $[0, 2^{32}-1]$       |
| `long int`               | $8$ 字节（64 位）   | $[-2^{63}, 2^{63}-1]$ |
| `unsigned long int`      | $8$ 字节         | $[0, 2^{64}-1]$       |
| `long long int`          | $8$ 字节         |                       |
| `unsigned long long int` | $8$ 字节         |                       |

在 $32$ 位的机器上整数类型的常见尺寸为

| 类型                       | 尺寸             | 取值范围                  |
| :----------------------- | :------------- | --------------------- |
| `short int`              | $2$ 字节（$16$ 位） | $[-2^{15}, 2^{15}-1]$ |
| `unsigned short int`     | $2$ 字节         | $[0, 2^{16}-1]$       |
| `int`                    | $2$ 字节（$16$ 位） | $[-2^{15}, 2^{15}-1]$ |
| `unsigned int`           | $2$ 字节         | $[0, 2^{16}-1]$       |
| `long int`               | $4$ 字节（$32$ 位） | $[-2^{31}, 2^{31}-1]$ |
| `unsigned long int`      | $32$ 字节        | $[-2^{31}, 2^{31}-1]$ |
| `long long int`          | $8$ 字节         | $[-2^{63}, 2^{63}-1]$ |
| `unsigned long long int` | $8$ 字节         | $[0, 2^{64}-1]$       |

>[!tip] 
>
>`int` 类型的尺寸必须 $\ge 16$ 位
>  
>`long` 类型的尺寸必须 $\ge 32$ 位
>
>`long long` 类型的尺寸必须 $\ge 64$ 位
>

#### 字面值

C23 标准中，整数字面值支持 $4$ 中表示方式：**二进制** **八进制** **十进制** 和 **十六进制**

在 [[计算机组成：数字系统]] 中详细介绍了这 $4$ 中进制，这里不在赘述

| 进制   | 表示方式                                              |
| :--- | :------------------------------------------------ |
| 二进制  | 字面值以 `0b` 开头，并且只能包含 `0` 和 `1` 两种符号                |
| 八进制  | 字面值以 `0` 开头，并且只能包含 `0, ..., 7` 八种符号               |
| 十进制  | 字面值 **不能** 以 `0` 开头，包含 `0, ..., 9` 十种符号           |
| 十六进制 | 字面值以 `0x` 开头，包含 `0, ..., 9` 和 `a, ..., f` 共 十六种符号 |

整数字面值的类型默认为 `int`， 值可以附加一些 **后缀** 指定字面值为其他类型

| 后缀        | 类型              |
| :-------- | :-------------- |
| `u` `U`   | `unsigned int`  |
| `l` `L`   | `long int`      |
| `ll` `LL` | `long long int` |

> [!tip] 这些后缀可以结合使用
> + `ul` `lu` 表示 `unsigned long int`
> + `ull` `llu` 表示 `unsigned long long int`

> [!tip] **没有后缀** 情况下，编译器按照下面的方式确定整数字面值的类型
> 
> #### C89/C90 标准：
> 
> 十进制字面值：编译器依次尝试 `int`  -> `long int` -> `unsigned long int`
> 
> 二进制 八进制和十六进制字面值：编译器会依次尝试  `int` -> `unsigned int` -> `long` -> `unsigned long`
> 
> #### C99 标准：
> 
> 十进制字面值：C99 标准与 C89 标准存在差异，在 C99 中，编译器依次尝试 `int` -> `long int` -> `long long int`，确定字面值的类型为能存储该字面值的 _最小_ 类型
> 
> 二进制，八进制和十六进制字面值： 编译器依次尝试 `int` -> `unsigned int` -> `long int` -> `unsigned long int` -> `long long int` -> `unsigned long long int`
> 

C23 标准中，整数字面值可以使用单引号(`'` ) 进行分隔，从而提高字面值的可读性

```c
int bin  = 0b111111010;  
int oct   = 0772;  
int dec   = 506;  
int hex   = 0x1fa;

unsigned int uint = 506u;   
unsigned long ulint = 123456789ul;  
unsigned long long ullint = 123'456'789ull; // C23 标准起，才能使用分隔符
```

#### 读写整数

读写 _无符号整数_ _短整数_ 和 _长整数_ 需要一些 _新的转换指定符_

> [!tip] 读写无符号整数
> 使用字母 `u` `o` 或 `x` 代替转换说明中的 `d
>  + `u` 说明将按十进制读写
>  + `o` 表示八进制
>  + `x` 表示十六进制

```c
unsigned int u; 
 
scanf("%u", &u);    /* reads  u in base 10 */ 
printf("%u", u);    /* writes u in base 10 */ 
scanf("%o", &u);    /* reads  u in base  8 */ 
printf("%o", u);    /* writes u in base  8 */ 
scanf("%x", &u);    /* reads  u in base 16 */ 
printf("%x", u);    /* writes u in base 16 */
```

> [!tip] 读写短整数
> 在 `d` `o` `u` 或 `x` 前面加上字母 `h`(`half`)
> 

```c
short s; 
 
scanf("%hd", &s); 
printf("%hd", s);
```

> [!tip] 读写长长整数（C99）
> 
> 在 `d` `o` `u` 或 `x` 前面加上字母 `ll`
> 

```c
long long ll; 
 
scanf("%lld",  &ll); 
printf("%lld",  ll);
```

### 浮点型

有些时候需要变量能存储 **带小数点的数**，或者能存储 **极大数** 或 **极小数**。这类数可以用 **浮点**（因小数点是 _浮动的_ 而得名）格式进行存储。C 语言提供了 $3$ 种浮点类型，对应三种不同的浮点格式

| 类型            | 描述      |
| :------------ | :------ |
| `float`       | 单精度浮点数  |
| `double`      | 双精度浮点数  |
| `long double` | 扩展精度浮点数 |

C23 标准起 **十进制浮点类型** 亦得到支持。忽略它

| 类型            | 描述                                                                                                                                 |
| :------------ | ---------------------------------------------------------------------------------------------------------------------------------- |
| `_Decimal32`  | [IEEE-754 decimal32 格式](https://en.wikipedia.org/wiki/decimal32_floating-point_format "enwiki:decimal32 floating-point format")    |
| `_Decimal64`  | [IEEE-754 decimal64 格式](https://en.wikipedia.org/wiki/decimal64_floating-point_format "enwiki:decimal64 floating-point format")    |
| `_Decimal128` | [IEEE-754 decimal128 格式](https://en.wikipedia.org/wiki/decimal128_floating-point_format "enwiki:decimal128 floating-point format") |

#### 浮点型对象

C 标准没有说明 `float` `double` 和 `long double` 类型提供的精度到底是多少，因为 _不同计算机可以用不同方法存储浮点数_。在支持 [IEEE 754 标准](https://en.wikipedia.org/wiki/IEEE_754) 的计算机中

| 类型            | 描述                                                                                                                                                                                                                                                           |
| :------------ | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `float`       | [IEEE-754 binary32 格式](https://en.wikipedia.org/wiki/Single-precision_floating-point_format "enwiki:Single-precision floating-point format")                                                                                                                 |
| `double`      | [IEEE-754 binary64 格式](https://en.wikipedia.org/wiki/Double-precision_floating-point_format "enwiki:Double-precision floating-point format")                                                                                                                 |
| `long double` | [IEEE-754 binary128 格式](https://en.wikipedia.org/wiki/Quadruple-precision_floating-point_format "enwiki:Quadruple-precision floating-point format")或者 [IEEE-754 binary64 扩展格式](https://en.wikipedia.org/wiki/Extended_precision "enwiki:Extended precision") |

浮点数编码是根据 **科学计数法** 而来的。科学计数法的形如下

$$
\text{Value} = (-1)^\text{Sign} \times \text{Fraction} \times base ^ \text{Exponent}
$$

> [!tip] 十进制下的科学计数法
> 
> 对于一个很大的数，例如 $198235928290783$ 的科学计数法表示如下
> 
> $$
> \begin{aligned}
> 198235928290783 &= 1.98235928290783 \times 10^{14}\\ 
>  &= 19.8235928290783 \times 10^{13} \\
>  &= 0.198235928290783 \times 10^{15}
> \end{aligned}
> $$
> 

也就是说，同一个数的科学计数法的表示有很多。其中，**整数部分只有 $1$ 位** 的科学计数法表示的数称为 **规格化数**。上例中 $1.98235928290783 \times 10^{14}$ 称为规格化数

##### IEEE 754 binary 格式

IEEE 754 binary 格式中，浮点数按照 **科学计数法** 进行编码

$$
\text{Value} = (-1)^\text{Sign} \times \text{Fraction} \times 2^ \text{Exponent}
$$


IEEE 754 binary 编码的位模式在计算机的布局如下图

![Pasted image 20240923162144|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755701532020-06a81b552d2a413088f1299fbf61fb28.png)

+ 指数位(`Exponent`) 采用 **移码** 表示
+ 尾数位(`Fraction`) 位采用 **无符号** 表示(规格化的) 

> [!tip] 二进制下的规格化数的整数位部分一定是 $1$ 

> [!important] 移码
> 
> [移码](https://en.wikipedia.org/wiki/Offset_binary) 也称 **偏置二进制** 编码，是一种 [有符号数字表示](https://en.wikipedia.org/wiki/Signed_number_representation "Signed number representation") 方法，其中有符号数字 $n$ 由对应于无符号数 $n+K$ 的位模式表示，$K$ 是 _偏置值_ 或 _偏移量_
> 
> 偏置二进制编码没有标准：在大多数情况下，$n$ 位偏置二进制编码的 偏置值 $K$ 为 $K=2^{n-1}$
> 
> IEEE 754 标准中，指数部分采用的偏置值是 $2^{n-1}-1$

###### 单精度浮点数(binary32)

> [!tip] 符号位宽： $1$ 位
> + `0` 表示正数
> + `1` 表示负数

> [!tip] 指数位宽：$8$ 位，采用 **移码** 系统表示
> + 偏置为 $2^{7}-1 = 127$
> + 表示指数的范围位 $[-126, 127]$
> + **指数部分全为 $0$**，即 $-127$ 和 **指数部分全为 $1$**，即 $128$ 有特殊用途

> [!tip] 尾数位宽：$23$ 位
> + 隐含表示首位的 $1$：即，尾数提供了 $24$ 位的精度，但是显示存储 $23$ 位

###### 双精度浮点数(binary64)

> [!tip] 符号位宽： $1$ 位
> + `0` 表示正数
> + `1` 表示负数

> [!tip] 指数位宽：$11$ 位，采用 **移码** 系统表示
> + 偏置为 $2^{10}-1 = 1023$
> + 表示指数的范围位 $[-1022, 1023]$
> + **指数部分全为 $0$**，即 $-1023$ 和 **指数部分全为 $1$**，即 $1024$ 有特殊用途

> [!tip] 尾数位宽：$52$ 位
> + 隐含表示首位的 $1$：即，尾数提供了 $53$ 位的精度，但是显示存储 $52$ 位

###### 特殊值

> [!tip] IEEE 754 binary 格式的 **$\pm 0$**
>  
>  指数位全为 $0$，尾数为全为 $0$，即
>  
>  ![Pasted image 20240923170006|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755701542777-ce684310349a48e9baf570caf8a433d6.png)
>  
>  符号位为 $1$ 表示为 $-0$；符号位为 $0$ 表示为 $0$
>  

> [!tip] IEEE 754 binary 格式表示的 **$\pm \infty$**
> 
> 指数为全为 $1$，尾数位全为 $0$
> 
> ![Pasted image 20240923170317|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755701550681-61e5bfbedf61472b87087962e3ff907d.png)
> 
> 符号位为 $1$ 表示为 $-\infty$；符号位为 $0$ 表示为 $+\infty$
> 

> [!tip] IEEE 754 binary 格式的 **NaN**
> 
> 指数全为 $1$，尾数不全为 $0$ 
> 
> ![Pasted image 20240923170704|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755701562148-2d27aaea3b54425796a4430cb07c2c16.png)
> 

###### 浮点值计算

> [!tip] 规约数
> 
> IEEE 754 binary 表示中，指数位为 $[000\cdots 0001, 111\cdots,1110]$
> 
> ![Pasted image 20240923183024|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755701572961-afabaa2d8fdb412aa43a045ee47a7cda.png)
> 
> 以 binary32 表示的位模式 $[b_{31}, \Vert b_{30}, \cdots, b_{23}\Vert,  b_{22},\cdots,b_2,b_1,b_0]$。其中 $b_{31}$ 表示符号位，$b_{30} \sim b_{22}$ 表示指数位，$b_{22} \sim b_{0}$ 表示尾数位。因此，该位模式在 IEEE 754 binary32 编码下的值为
> $$
> (-1)^{b_{31}} \times 2^{(b_{30}b_{29}\cdots b_{23})_2 - 127} \times (1.b_{22}b_{21}\cdots b_{2}b_{1}b_{0})_2
>$$
>

> [!tip] 非规约数：**用于表示绝对值非常接近于 $0$ 的数**
> 
> IEEE 754 binary 表示中，**指数位全为 $0$**，尾数位非零，那么这个浮点数将被称为**非规约形式的浮点数** 
> 
> ![Pasted image 20240923183223|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755701580421-5e30c283865a442e93f959aa3726df5a.png)
>  
>  IEEE 754标准规定：**非规约形式的浮点数的指数偏移值比规约形式的浮点数的指数偏移值小 1**
>  
>  最小的规约形式的单精度浮点数的指数部分编码值为 $1$，指数的实际值为 $-126$；而**非规约的单精度浮点数的指数域编码值为 $0$，对应的指数实际值也是 $-126$ 而不是 $-127$**
>  
> 以 binary32 表示的位模式 $[b_{31}, \Vert 0_{30}, \cdots, 0_{23}\Vert,  0_{22},\cdots,b_2,b_1,b_0]$
> 
> $$
> (-1)^{b_{31}} \times 2^{-126} \times (0.b_{22}b_{21}\cdots b_{2}b_{1}b_{0})_2
>$$
>

###### 范围

对于 **规约数**，取 **最大正值** 时，符号位为 $0$，指数位为 $111....110$，尾数位全为 $1$；取 **最小正值** 时，符号位 $0$，指数位为 $000....0001$，尾数位全为 $0$ 

![Pasted image 20240923190519|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755701587411-b15da3c539364222afc459d09fa073f2.png)

| 类别     | binary32                                                                                                                           | binary64                                                                                                                              |
| :----- | :--------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------ |
| 最小规约正值 | $\begin{aligned}&(-1)^{0}\times 2^{-126} \times 1.000...000\\ &\approx  2^{-126} \\ &\approx 1.17549\times 10^{-38} \end{aligned}$ | $\begin{aligned}&(-1)^{0}\times 2^{-1022} \times 1.000...000\\ &\approx  2^{-1022} \\ &\approx 2.22507\times 10^{-308} \end{aligned}$ |
|        |                                                                                                                                    |                                                                                                                                       |
| 最大规约值  | $\begin{aligned} &(-1)^{0} \times 2^{127} \times 1.111...111\\&\approx  2^{128}\\ &\approx 3.40282 \times 10^{38}\end{aligned}$    | $\begin{aligned} &(-1)^{0} \times 2^{1023} \times 1.111...111\\&\approx  2^{1024}\\ &\approx 1.79769 \times 10^{308}\end{aligned}$    |

对于 **非规约数**，取最大正值时，符号位为 $0$，指数位全为 $0$，尾数位全为 $1$；取最小正值时，符号位为 $0$，指数位全为 $0$，尾数位为 $000....0001$

![Pasted image 20240923191116|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755701603135-5dd89c38eb0d470ea20d6f176aebd402.png)


| 类别      | binary32                                                                                                                                              | binary64                                                                                                                                               |
| :------ | :---------------------------------------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------- |
| 最小非规约正值 | $\begin{aligned}&(-1)^{0}\times 2^{-126} \times 0.000...001\\ &\approx  2^{-126} \times 2^{-23} \\ &\approx 1.40130\times 10^{-45} \end{aligned}$     | $\begin{aligned}&(-1)^{0}\times 2^{-1022} \times 0.000...001\\ &\approx  2^{-1022} \times 2^{-52} \\ &\approx 4.49066\times 10^{-324} \end{aligned}$   |
|         |                                                                                                                                                       |                                                                                                                                                        |
| 最大非规约值  | $\begin{aligned} &(-1)^{0} \times 2^{-126} \times 0.111...111\\&\approx  2^{-126} \times (1-2^{-23})\\ &\approx 1.17549 \times 10^{-38}\end{aligned}$ | $\begin{aligned} &(-1)^{0} \times 2^{-1022} \times 0.111...111\\&\approx  2^{-1022}\times(1-2^{-52})\\ &\approx 2.22507 \times 10^{-308}\end{aligned}$ |

##### IEEE 754 decimal 格式

IEEE 754 decimal 格式适用于需要 **精确模拟小数舍入** 的应用程序，例如财务和税务计算。decimal 格式在 [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754 "IEEE 754") [2008 版](https://en.wikipedia.org/wiki/IEEE_754-2008) 引入

#### 字面值

浮点字面值可以有许多种书写方式。例如，下面这些字面值全都是表示数 `57.0` 的有效方式

```c
57.0  

57.  

57.0e0  

57E0  

5.7e1  

5.7e+1  

.57e2  

570.e-1
```

**浮点字面值必须包含 _小数点_ 或 _指数_**；其中，_指数_ 指明了对前面的数进行缩放所需的 $10$ 的幂次。

如果有指数，则需要在指数数值前放置字母 `E`（或`e`）。可选符号 `+` 或 `-` 可以出现在字母`E`（或`e`）的后边。

默认情况下，**浮点字面值以 _双精度数_ 的形式存储**。换句话说，当 C 语言编译器在程序中发现常量 `57.0` 时，它会安排数据以 `double` 类型变量的格式存储在内存中。这条规则通常不会引发任何问题，因为在需要时 `double` 类型的值可以自动转换为 `float` 类型值。

在某些极个别的情况下，可能会需要强制编译器以 `float` 或 `long double` 格式存储浮点字面值。为了表明只需要单精度，可以在常量的末尾处加上字母 `F` 或 `f`（如 `57.0F`）；而为了说明常量必须以 `long double` 格式存储，可以在常量的末尾处加上字母 `L` 或 `l`（如 `57.0L`）

#### 读写浮点数

转换说明 `%e` `%f` 和 `%g` 用于读写单精度浮点数

如果需要读取 `double` 类型的值时，在 `e` `f` 或 `g` 前放置字母 `l` 

```c
double d; 
 
scanf("%lf", &d);
```

> [!tip]
> 
> 只能在 `scanf` 函数格式串中使用 `l`，不能在 `printf` 函数格式串中使用。在 `printf` 函数格式串中，转换 `e` `f` 和 `g` 可以用来写 `float` 类型或 `double` 类型的值
> 
> C99 允许 `printf` 函数调用中使用 `%le` `%lf` 和 `%lg`，不过字母 `l` 不起作用
> 


读写 `long double` 类型的值时，在 `e` `f` 或 `g` 前放置字母 `L`

```c
long double ld; 
 
scanf("%Lf", &ld); 
printf("%Lf", ld);
```

### 字符类型

唯一基本类型是 `char` 类型，即 **字符类型**（也称字符型）。`char` 类型的值可以根据计算机的不同而不同，因为不同的机器可能会有不同的字符集

> [!tip] 字符集与 ASCII 码
> 
> 由于计算机只能处理二进制的数据。对于 **符号数据**，我们需要使用 **位模式** 进行表示后才能进行处理。根据基本符号的数量，可以确定位模式的长度
> 
> + 如果基本符号的数量为 $n$，则位模式的长度为 $\lceil \log_2 n  \rceil$
> 
> 例如，**ASCII 字符集**，使用 $26$ 个符号表示小写字母，$26$ 个符号表示大写字母，$10$ 个符号表示 $0\sim 9$ 的数字，基本标点符号(`. , ? : ; ... !`)，以及另外一些 **非打印的字符**，共计 $128$ 个字符。只需要 $\log_2 128 = 7$ 位位模式即可完全表示
> + 数字字符 $0\sim 9$ 用 $0110000 \sim 0111001$ 码来表示
> + 大写字母 $\text A\sim \text Z$ 用 $1000001 \sim 1011010$ 码来表示
>
> ASCII 码常被扩展用于表示 $256$ 个字符，相应的字符集 Latin-1 包含西欧语言和许多非洲语言中的字符
> 

> [!tip] 源字符集和执行字符集
> 
> 当初在标准化 C 语言的时候，尚没有普遍接受的字符编码，因此语言被设计为能够处理多种字符表示
> 
> 每种 C 语言实现都会定义 **源字符集** 和 **执行字符集**
> + **源字符集**：用于源代码书写
> + **执行字符集**：用于在编译期解释字符和字符串
> 
> 源字符集和执行字符集必须包含以下字符
> + 拉丁字母表的大小写字母
> + $10$ 个十进制数字
> + $29$ 个图形字符、空格、水平制表符、垂直制表符、馈页符和换行符
> 
> 执行字符集还包括 _响铃字符_、_退格_、_回车_ 和 _空字符_
> 

因此，存在这样一个事实：**字符被当作小整数进行处理**。毕竟所有字符都是以二进制的形式进行编码的，因此可以将这些二进制代码看成整数

在 ASCII 码中，字符的取值范围是 $0000000 \sim 1111111(0 \sim 127)$
- 字符 `' '`(空格) 编码的十进制表示为 $32$，十六进制表为 `0x20`
- 字符 `'0'` 编码的十进制表示为 $48$，十六进制表示为 `0x30`
- 字符 `'1'` 编码的十进制表示为 $49$，十六进制表示为 `0x31`
- 字符 `'A'` 编码的十进制表示为 $65$，十六进制表示为 `0x41`
- 字符 `'a'` 编码的十进制表示为 $97$，十六进制表示为 `0x61`

在 C 语言中，**字符与整数的关联非常强**，**字符事实上是 `int` 类型而不是 `char` 类型**。C 程序中出现字符时，使用它对应的整数值

当计算中出现字符时，C 语言只是使用它对应的整数值。

```c
char ch; 
int i; 
 
i = 'a';      /* i is now 97    */ 
ch = 65;      /* ch is now  'A' */ 
ch = ch + 1;   /* ch is now  'B' */ 
ch++;          /* ch is now  'C' */
```

**可以像比较数那样对字符进行比较**。下面的 `if` 语句测试 `ch` 中是否含有小写字母，如果有，那么它会把 `ch` 转换为相应的大写字母

```c
if ('a' <= ch && ch <= 'z') 
	ch = ch - 'a' + 'A';
```

#### 有符号字符与无符号字符

C 语言把字符作为整数来使用，那么 `char` 类型应该和整数一样存在符号和无符号两种

+  **有符号字符** 的取值范围是 $-128 \sim 127$
+ **无符号字符** 的取值范围是 $0 \sim 255$

对于普通的 `char` 类型，C 标准并没有规定它是有符号的还是无符号的，不同的编译器对其处理可能不同

> [!attention] 不能假设 `char` 类型的符号

> [!attention] 
>  `signed char` 用作有符号字符表示的类型
>  
 `unsigned char` 用作无符号字符表示的类型。亦可用于 **查看对象表示**

 `char` 用于字符表示的类型。它与 `signed char` 或 `unsigned char` 等价，但是具体是有符号的还是无符号的依赖于具体实现。但是 **`char` 是独立的类型**，`char` , `signed char`, `unsigned char` 是不同的类型

当需要使用 `char` 类型变量存储小整数时，允许使用 `signed` 和 `unsigned` 限定 `char` 类型，使其显示表示有符号字符和无符号字符

#### 宽字符

C89/C90 标准中字符类型 `char`  `signed char` 和 `unsigned char` 类型通常只占用 $1$ 个字节，用于处理 ASCII 字符集中的字符。对于中文这样的象形文字，这不能使用 `char` 类型进行存储，因为它们的编码的字符的位模式的长度远大于 $1$ 字节。通常，我们需要使用 `char` 数组来存储

下面面的示例在执行字符集为 UTF-8 的环境中，中文字符通常占 $3$ 字节

```c
#include <stdio.h>
#include <string.h>

int main()
{
    unsigned char a = 'a';  // 存储 ASCII 字符集中字符只需要 1 个字节
    printf("sizeof(a) = %zu\n", sizeof(a));
    unsigned char c[] = "汉"; // 中文 "汉" 的编码的位模式长度超过了 1，因此需要使用字符数组进行存储
                             // 使用双引号的 " " 括起来的时表示字符串常量，以 '\0' 结束。
                             // 因此，使用 strlen 计算 "汉" 占用的字节数
    printf("strlen(c) = %zu\n", strlen(c));  // 因此，字符 '汉' 使用 char 存储时，占 3 个字节
    return 0;
}
```

C99 标准开始，引入了 `wchar_t` 类型用于处理宽字符集。它的尺寸由具体实现定义，通常占 $2$ 字节。因此，我们可以使用 `wchar_t` 存储占用字节超过 $1$ 的字符，称为 **宽字符**。`wchar_t` 在 `<wchar.h>` 中定义

```c
#include <wchar.h>

int main()
{
    wchar_t c = L'汉';
    wprintf(L"sizeof(wchar_t) = %zu\n", sizeof(wchar_t));  // wchar_t 在 gcc 中占 2 字节
    wprintf(L"c = %#x\n", c);  // 这里中文字符可以被当作整数使用
    return 0;
}
```

#### Unicode 字符

在 C99 中，可以用 `wchar_t` 类型的变量保存宽字符。随着绝大多数计算机系统开始支持  [[计算机组成：数据存储#Unicode 编码]] ，使用 `wchar_t` 类型保存的字符也都是 `Unicode` 字符

但是，C语言没有规定 `wchar_t` 类型的长度，再加上不同的操作系统使用不同的 Unicode 编码方案，这就影响了文本的交换以及程序的可移植性

C11 标准起，标准库提供了 `<uchar.h>` 头文件，并且明确定义了两种具有明确长度的宽字符类型，它们分别是 `char16_t` 和 `char32_t `
- `char16_t` 是一个无符号整数类型，用来保存长度为 $16$ 位的字符，通常用于保存 UTF-16 编码的字符
- `char32_t` 也是一个无符号整数类型，用来保存长度为 $32$ 位的字符，通常用于保存 UTF-32 编码的字符

#### 字面值

下表列出了字符类型的字面值语法

| 语法            | 类型         | 描述                                             |
| :------------ | ---------- | ---------------------------------------------- |
| `'c-char'`    | `int`      | **_源字符集_** 中的字符，除了 `'` `\`；或者 **_转义序列_**       |
| `u8'c-char'`  | `char8_t`  | UTF-8 字符，即该 `c-char` 处于含上下界的范围 `0x00 ~ 0x7F` 内 |
| `u'c-char'`   | `char16_t` | 通常为 UTF-16 字符，例如 `u'猫'`                        |
| `U'c-char'`   | `char32_t` | 通常为 UTF-32 字符，例如 `U'猫'`                        |
| `L'c-char'`   | `wchar_t`  | 宽字符常量，例如 `L'β'` 或 `L'字'`                       |
|               |            |                                                |
| `'c-chars'`   | `int`      | 多字符常量。例如 `'AB'`                                |
| `L'c-chars'`  | `wchar_t`  | 宽多字符常量。例如 `L'AB'`                              |
| `u'c-chars '` | `char16_t` | 16 位多字符常量。C11 标准起，于 C23 标准移除                   |
| `U'c-chars '` | `char32_t` | 32 位多字符常量。C11 标准起，于 C23 标准移除                   |

```c
#include <stddef.h>
#include <stdio.h>
#include <uchar.h>

int main(void) {
    printf("constant    value     \n");
    printf("--------    ----------\n");

    // 整数字符常量
    int c1 = 'a';
    printf("'a':\t %#010x\n", c1);
    int c2 = '🍌';
    printf("'🍌':\t %#010x\n\n", c2); // 实现定义

    // 多字符常量
    int c3 = 'ab';
    printf("'ab':\t %#010x\n\n", c3); // 实现定义

    // 16 位宽字符常量
    char16_t uc1 = u'a';
    printf("'a':\t %#010x\n", (int) uc1);
    char16_t uc2 = u'¢';
    printf("'¢':\t %#010x\n", (int) uc2);
    char16_t uc3 = u'猫';
    printf("'猫':\t %#010x\n", (int) uc3);

    // 实现定义（🍌 映射到二个 16 位宽字符）
    char16_t uc4 = u'🍌';
    printf("'🍌':\t %#010x\n\n", (int) uc4);

    // 32 位宽字符常量
    char32_t Uc1 = U'a';
    printf("'a':\t %#010x\n", (int) Uc1);
    char32_t Uc2 = U'¢';
    printf("'¢':\t %#010x\n", (int) Uc2);
    char32_t Uc3 = U'猫';
    printf("'猫':\t %#010x\n", (int) Uc3);
    char32_t Uc4 = U'🍌';
    printf("'🍌':\t %#010x\n\n", (int) Uc4);

    // 宽字符常量
    wchar_t wc1 = L'a';
    printf("'a':\t %#010x\n", (int) wc1);
    wchar_t wc2 = L'¢';
    printf("'¢':\t %#010x\n", (int) wc2);
    wchar_t wc3 = L'猫';
    printf("'猫':\t %#010x\n", (int) wc3);
    wchar_t wc4 = L'🍌';
    printf("'🍌':\t %#010x\n\n", (int) wc4);
}
```

##### 转义序列

转义序列用于在 **字符串字面量** 和 **字符常量** 中表示某些 **特殊字符**

下列转义序列可用。ISO C 要求诊断是否有任何不列于此的字符出现于反斜杠之后

| 字符转义序列 | 描述   | 表示                  |
| ------ | ---- | ------------------- |
|        |      |                     |
| `\'`   | 单引号  | ASCII 编码中为字节 `0x27` |
| `\"`   | 双引号  | ASCII 编码中为字节 `0x22` |
| `\?`   | 问号   | ASCII 编码中为字节 `0x3f` |
| `\\`   | 反斜杠  | ASCII 编码中为字节 `0x5c` |
| `\a`   | 响铃   | ASCII 编码中为字节 `0x07` |
| `\b`   | 退格   | ASCII 编码中为字节 `0x08` |
| `\f`   | 换页   | ASCII 编码中为字节 `0x0c` |
| `\n`   | 换行   | ASCII 编码中为字节 `0x0a` |
| `\r`   | 回车   | ASCII 编码中为字节 `0x0d` |
| `\t`   | 水平制表 | ASCII 编码中为字节 `0x09` |
| `\v`   | 垂直制表 | ASCII 编码中为字节 `0x0b` |

| 数值转义序列   | 描述      | 表示                       |
| -------- | ------- | ------------------------ |
| `\nnn`   | 任意八进制值  | 代码单元 `nnn`               |
| `\xn...` | 任意十六进制值 | 代码单元 `n...`（任意数量的十六进制数字） |

> [!tip] 数值转义序列
> 
> 数值转义序列中，采用八进制表示的转移序列，表示一个无符号字符，最大值为 `\377`
> 
> 十六进制表示的转义序列，C 标准 _没有规定十六进制转义序列的数字的个数_，但必须表示成无符号字符。如果字符类型的长度为 $1$ 字节，十六进制数最大为 `\xFF`
> 

| 通用字符名        | 描述         | 表示              |
| ------------ | ---------- | --------------- |
| `\unnnn`     | Unicode 编码 | 码位 `U+nnnn`     |
| `\Unnnnnnnn` | Unicode 编码 | 码位 `U+nnnnnnnn` |

#### 字符处理函数

头文件 `<ctype.h>` 中定义下面几个函数

| 函数                     | 描述                   |
| :--------------------- | :------------------- |
| `int isalnum(int ch);` | 检查 `ch` 是否为字母数字字符    |
| `int isalpha(int ch);` | 检查 `ch` 是否为字母        |
| `int islower(int ch);` | 检查 `ch` 是否为小写字母      |
| `int isupper(int ch);` | 检查 `ch` 是否为大写字母      |
| `int isdigit(int ch);` | 检查 `ch` 是否为数字        |
| `int isxdigit(int ch)` | 检查 `ch` 是否为十六进制的字符   |
| `int iscntrl(int ch)`  | 检查 `ch` 是否为控制字符      |
| `int isgraph(int ch)`  | 检查 `ch` 是否为图形字符      |
| `int isspace(int ch)`  | 检查 `ch` 是否为空白字符      |
| `int isblank(int ch)`  | 检查 `ch` 是否为空格字符，C99  |
| `int isprint(int ch)`  | 检查 `ch` 是否为可打印字符，C99 |
| `int ispunct(int ch)`  | 检查 `ch` 是否为标点字符      |
|                        |                      |
| `int tolower(int ch)`  | 将字符 `ch` 转换成小写       |
| `int toupper(int ch)`  | 将字符 `ch` 转换成大写       |

#### 读写字符

转换说明 `%c` 用于读写字符

```c
char ch; 
 
scanf("%c", &ch);   /* reads a single character */ 
printf("%c", ch);   /* writes a single character */
```

> [!attention] 使用 `scanf` 读取字符时，**不会忽略空白字符**
> 
> 如果下一个未读字符是空格，那么在前面的例子中，`scanf` 函数返回后变量ch将包含一个空格
> 

为了强制 `scanf` 函数在读入字符前 **跳过空白字符**，需要在格式串中的转换说明 `%c` 前面加上一个空格

```c
scanf(" %c", &ch); /* skips white space, then reads ch */
```

### 布尔类型

布尔类型对象用于 **存储逻辑值(_真_ 或 _假_)**。从 **C99 标准** 开始，引入了 `_Bool` 类型。在此之前 C 语言并没有用于表示布尔对象的类型，通常是使用整数类型替代

+ `0` 表示 _假_
+ 非零表示 _真_

> [!attention] 被声明为 `_Bool` 类型的对象只能存储 $0$ 和 $1$

C99 提供了一个头文件 `<stdbool.h>`，它将 `_Bool` 重定义为了 `bool`，并且提供了两个宏定义：`true` 和 `false` 分别代表 `1` 和 `0`

从 C23 标准开始，`bool` `true` 和 `false` 变为了关键字，并移除了 `<stdbool.h>` 头文件

在 C23 标准之前，它们通过宏定义支持

```c
#define bool	_Bool
#define true	1
#define false	0
```

这就造成了一些问题。`bool` 类型的尺寸为 `1`，但是 `ture`, `false` 的尺寸为 `4`。在 C23 标准后，它们的尺寸均为 `1`

```c
#include <stdio.h>
#include <stdbool.h>  // 从 C99 开始 使用，在 C23 时被移除

int main()
{
    bool flag = false;  // bool, false, true 从 C23 标准开始成为关键字
    printf("sizeof(bool) = %zu\n", sizeof(bool));
    printf("sizeof(false) = %zu\n", sizeof(false));
    return 0;
}
```

### 类型转换

在执行算术运算时，计算机比 C 语言的限制更多。为了让计算机执行算术运算，通常要求操作数有 **相同的尺寸**(即位模式长度相同)，并假设其 _存储方式相同_

C 语言则允许在表达式中 **混合使用基本类型**。当然，在这种情况下 C 编译器可能需要生成一些指令，将操作数转换为 **相同的 _尺寸_ 和 _存储方式_**，使得硬件可以对表达式进行计算

_C 编译器能够自动处理转换操作_，这类转换称为 **隐式转换**。同时，C语言允许程序使用 _类型转换运算符_ 执行 **显示转换**

#### 隐式转换
 
C 语言中隐式类型转换有四类：**常规算术转换** **赋值转换** **函数调用转换** **函数返回转换**

> [!tip] 
> 
> **常规算术转换**：常规算术转换可用于大多数二元运算符（包括 _算术运算符_、_关系运算符_ 和 _判等运算符_）的操作数
> 
> **赋值转换**：当 **赋值运算符** 右侧表达式的类型和左侧变量的类型不匹配时
> 
> **函数调用转换**：函数调用中的 _实参类型_ 与其对应的 _形参类型_ 不匹配时
> 
> **函数返回转换**：当 `return` 语句中表达式的类型和函数返回值的类型不匹配时
> 

##### 常规算术转换

C89/C90 标准中，隐式类型转换按照下面两条规则进行

> [!tip] 操作数中 **有浮点类型**。将类型较狭小的操作数按照下面顺序进行提升
>
> `float` -> `double` -> `long double`
>
> + 只要有一个操作数的类型是 `long double`，另一个操作数就会转换为 `long double`
> + 否则，只要有一个操作数是 `double`，另一个操作上就会转换为 `double`
> + 最后，只要有一个操作数是 `float`，另一个操作上就会转换为 `float`
>

> [!tip] 操作数中 **没有浮点数**。首先执行 _整值提升_，然后再将类型狭小的操作数进行提升
> 
>  **整值提升**：将 `char` `short` 类型转换为 `int` 类型；然后再按照下面规则进行类型转换
>  
>  `int` -> `unsigned int` -> `long int` -> `unsigned long int`
>  
>  特殊情况：在 `long int` 类型和 `unsigned int` 类型长度相同时，如果一个操作数的类型是 `long int`，而另一个操作数的类型是 `unsigned int`，那么两个操作数都会转换成 `unsigned long int` 类型
>  

C89/C90 标准中的类型转换规则如下图

![Pasted image 20240924115450|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755701631957-e95e4ddb3e784e42aecbc4474444a8e6.png)


C99 标准起，由于 C99 新增了一些类型，导致隐式类型转换的行为发生改变

C99 用 **整数提升** 取代了 C89/C90 中的 _整值提升_。C99 允许每个整数类型具有 **_整数转换等级_**。整数转换等级 **从高到低** 排序为
+ **(1)** `long long int` `unsigned long long int`
+ **(2)** `long int` `unsigned long int`
+ **(3)** `int` `unsigned int`
+ **(4)** `short` `unsigned short`
+ **(5)** `char` `signed char` `unsigned char`
+ **(6)** `_Bool`

> [!tip] **整数提升**：任何 **等级低于** `int` 和 `unsigned int` 的类型转换为 `int`（只要该类型的所有值都可以用`int` 类型表示）或 `unsigned int`

操作数中 **有浮点数**。所有的操作数都 **不是复数类型**，类型转换规则不变 

> [!tip] 操作数中 **没有浮点数**。首先对操作数进行 _整数提升_
> 
> 如果整数提升后，操作数类型相同，则转换到此结束
> 
> 如果整数提升后，操作数类型不同，则按照下面规则进行
> 
> + 操作数 **都是有符号型** 或者 **都是无符号型**，等级低的操作数转换为等级高的操作上
> + **无符号操作数等级高于或等于有符号操作数等级**，将有符号操作数转换为无符号操作上
> + **有符号操作数的类型可以表示所有的无符号操作数类型的值**，将无符号操作数转换为有符号操作数
> + 否则，将两个操作数都转换为与有符号操作数的类型相对应的无符号类型
> 

> [!tip] 常规算术转换的思想：是将表示 **数据范围较窄** 的类型转换为表示 **数据范围较宽** 的类型
> 
> 也就是说，**整数都将转换为浮点数**，整数会按照 **整数转换等级** 进行转换
> 

> [!bug] 有符号操作数转换为无符号类型导致的bug 
> 
> 当有符号操作数和无符号操作数组合起来时，有符号操作数会被 “转换” 为无符号的值。转换过程中需要加上或者减去  $n+1$ 的倍数，其中 $n$ 是无符号类型能表示的最大值。这条规则可能会导致某些隐蔽的编程错误
>

```c
#include <stdio.h>
int main() {
    int i = -10;
    unsigned int u = 10;
    printf("%d\n", i < u);  // 这里我们期望的结果为 1, 但实际结果为 0
    return 0;
}
```

> [!attention] 
> 
> 在 C99 中，`i` 的类型是 `int`，`u` 的类型是 `unsigned int`，它们的转换等级相等。因此，将 `i` 转换为 `unsigned int` 类型的值。因此，`-10` 转换为 `unsigned int` 的值为 `-10 + 2 ^ 32 -1 = 4294967285`，所以 `i < u` 不成立
> 
> **有符号整数 与 无符号整数进行比较时必须小心**。当有符号为负数时，由于类型的转换存在，会出现我们不想要的结果
> 

> [!tip] 对于整数类型之间的相互转换：改变的只是位模式的解释方式
> 
> `int` 类型转换为 `unsigned int` 类型时，只是将 `int` 类型对象的位模式按照 `unsigned int` 类型进行解释罢了
> 

##### 赋值转换

C 语言会遵循另一条简单的转换规则，那就是 **把赋值运算右边的表达式转换成左边变量的类型**

> [!tip] 
> 
> 浮点数赋值给整型变量会丢掉该数的小数部分
> 
> 把某种类型的值赋给类型更狭小的变量时，如果该值在变量类型范围之外，那么将得到无意义的结果（甚至更糟）。
> 

#### 显式转换

强制类型转换运算符 `(type) expression` 用于将其后表达式(`expression`)的类型转换为 `type` 指定的类型

```c
int a = 102;
float f = (float) a; // 将 a 的类型转换为 float
```

> [!tip] 类型转换 **不会影响其操作数的值**，只是源操作数的值的另一种编码方式的某一个副本
> 

> [!important] 显示转换的作用
> 
> 显示转换提供了更加精确的类型转换
> 
> 表明类型转换一定会发生，提高代码可读性
> 
> 避免溢出
> 

```c
#include <stdio.h>
int main() {
    float pi = 3.14f;

    printf("pi 的整数部分: %d\npi 的小数部分: %.2f\n", (int)pi, pi - (float)(int)pi);


    return 0;
}
```

```c
#include <stdio.h>  
int main() {  
  
    long long int millisPerDay = 24 * 60 * 60 * 1000; // 一天有多少毫秒  
    long long int nanosPerDay = 24 * 60 * 60 * 1000 * 1000 * 1000;  
    // 整数字面值默认是 int，表达式 24 * 60 * 60 * 1000 * 1000 * 1000 超出了 int 表示的范围  
  
    printf("%lld\n", millisPerDay);  // 86400000 
    printf("%lld\n", nanosPerDay);   // -1857093632
  
    return 0;  
}
```

> [!attention] 整数字面值默认是 `int`
> 
> 这就导致在计算 `nanosPerDay` 的值时，结果溢出。为了防止溢出，就需要将其中一个操作数转换为 `long long int` 即可
> ```c
> long long int nanosPertDay = (long long int)24 * 60 * 60 * 1000 * 1000 * 1000;
>```
> 

#### 类型定义

C 语言的 `typedef` 关键字，称为 **类型定义**。在 [[#布尔类型]] 中使用 `#define` 指令定义了一个类型

```c
#define Bool int
```

这不是一个很好的办法，因为有时候不会向我们期待那样。例如，定义了一个 `String` 类型

```c
#define String char *
```

当我们想使用 `String` 类型声明多个变量时，问题就随之出现

```c
String s1, s2;
```

这里只有 `s1` 是我们想要的 `char *` 类型，而 `s2` 仅仅是 `char` 类型。因为经过宏替换之后的声明语句为

```c
char * s1, s2;
```

`typedef` 关键句可以解决上述问题。如果使用 `typedef` 定义 `String` 类型

```c
typedef char * String;  // 定义一个 String 类型，其基础类型是 char * 类型
```

`typedef` 导致编译器在它所识别的类型名列表中加入 `String`。编译器将把`String`类型看成是 `char *` 类型的同义词。像如下方式定义多个 `char *` 类型变量

```c
Sting s1, s2; // 这里 s1, s2 都将是 char * 类型
```

**类型定义可以将类型重命名，提供 _更清晰的变量含义_**。同时，类型定义 **方便程序修改**，还可以使得程序 **更容易移植**

#### sizeof 运算符

运算符 `sizeof(expression/type)` 用于 _计算某个类型的对象占用的字节数_

```c
sizeof(int);  // 返回 int 类型对象占用的字节数

int a;

sizeof(a); // 也会返回对象 a 占用的字节数
```

> [!tip] `sizeof` 运算符在 **编译时求值**
> + `sizeof()` 的值可以作为 `case` 的标签
> + `sizeof()` 的值可以作为数组的长度

> [!attention] 
> 
> `sizeof(expression/type)` 运算符不会对 `expression` 进行求值
> 

### 类型推断

C23 对 `auto` 关键字的语义进行修改。`auto` 原本用作 **存储类型说明** ^[[[C 语言：函数#程序结构]]] 的。由于其极少使用，在 C23 中变为了 **自动类型推导关键字**

自动类型推导有时非常有用，当我们调用一个函数时，可以使用 `auto` 自动从函数的返回类型推断变量类型

```c
const char* func()
{
	return "Hello!";
}

auto fRet = func();  // 不用知道函数返回值类型，让编译器自动推导
```

关键字 `typeof` 用于获取表达式的类型

```c
int a = 10;
typeof(a) b;
```

> [!tip] `auto` 和 `typeof` 的区别
> 
> `auto` 声明的变量必须给初始值，编译器从初始值中获取变量的类型
> 
> `typeof` 可以仅声明一个变量，不用给初始值
> 

## 表达式

表达式是 **_运算符_** 及其 **_操作数_** 的序列，它指定一个运算。

> [!tip] 
> 
> 最简单的表达式就是一个 **变量** 或 **常量**
> 

受限于计算机硬件，**运算符的操作数必须具有相同的类型(_相同长度的位模式_)**。对于类型不同的操作数，需要执行 **类型转换**

### 运算符

运算符指定了对它的操作数执行的运算。根据运算符需要的 **操作数** 个数，将运算符分为：_一元运算符_  _二元运算符_ 和 _三元运算符_

> [!tip] 大多数运算符都属于 _二元运算符_

运算符有两个重要的属性：**优先级** 和 **结合性**。下表列出 C 运算符的优先级和结合性。运算符从上到下以降序列出

![Pasted image 20240924150611|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755701648083-d5856a240a67452b9988932ef98ad8bb.png)

#### 算术运算符

算术运算符用于执行 **加 减 乘 除** 四则运算

| 运算符 | 描述   | 示例      |
| --- | ---- | ------- |
| `+` | 一元正号 | `+a`    |
| `-` | 一元负号 | `-a`    |
|     |      |         |
| `+` | 加法   | `a + b` |
| `-` | 减法   | `a - b` |
| `*` | 乘法   | `a * b` |
| `/` | 除法   | `a / b` |
| `%` | 模运算  | `a % b` |

一元正号(`+`) 运算符什么也不做；只是强调某个数值常量是正数，为了与一元负号(`-`) 保持一致，它们都是 _前缀运算符_

> [!tip] 前缀运算符
> 
> 运算符位于操作数之前
> 

二元算术运算符的作用类似于数学运算。不过需要特别注意: 除法(`/`) 和 模运算)(`%`) 

> [!important] 
> 除法(`/`)的 **操作数均为整数** 时，结果也是整数(**截断小数部分**)

```c
#include <stdio.h>

int main()
{
    int result = 1/2;
    printf("%d\n", result);  // 0

    result = -1 / 2;
    printf("%d\n", result);  // 0
    return 0;
}
```

> [!important] 
> 模运算(`%`) 的两个操作数 **只能是整数**，否则编译无法通过

> [!important] 
> 
> $0$ 作为 `/, %` 运算符的 _第二个操作数_ 时会导致 **未定义行为**
> 
> 未定义行为：**标准中没有规定的** 行为。未定义行为是非常危险的，其后果不可预料
> + 程序出现未定义行为时，可能 _编译无法通过_
> + 即使通过编译，运行 _结果也是不可信的_
> 

> [!important] 
> 
> 除法(`/`)和模运算(`%`)出现 _负操作数_ 时；在 C89/C90 标准中行为由 **实现定义**，在 C90 标准中的行为是确定的
> 
> C89/C90 标准中，除法(`/`) 出现负操作数时，结果可以向上舍入，也可以向下舍入
> + 即，`-9 / 7` 的值可以是 `-1`，也可以是 `-2`
> 
> C89/C90 标准中，模运算(`%`)出现负操作数时，结果由实现定义
> + 即，`-9 % 7` 的值可能是 `-2` 也可能是 `5`
> 
> C99 标准起，除法(`/`) 的结果总是 **趋零截断**，因此表达式 `-9 / 7` 的结果是 `-1`；模运算(`%`) 的符号总是与第一个操作数的符号相同，因此表达式 `-9 % 7` 的结果是 `-2`
> 
> + **模运算(`%`)** 需要满足一个公式：即 `i % j` 的结果为 `i - (i / j) * j`
> 
> **由实现定义**：C 标准中存在一些未加指定，并认为其细节可以由 **实现** 来具体定义。根据实现的不同，程序的行为可能会稍有差异
> 

判断一个数是否为奇数。

```c
bool isOdd(const int num) {  
    return num % 2 == 1; // ERROR, num < 0 时，num % 2 == -1  
}
```

```c
bool isOdd(const int num) {  
    return num % 2 != 0; // 避免了上述情形
}
```

```c
bool isOdd(const int num) {  
    return num & 0x1; // 位与：位模式最后一位为 1，那么一定是奇数，位模式最后一位为 0 一定是偶数
}
```

#### 赋值运算符

运算符 `=` 表示赋值运算符，将右操作数的值复制到左操作数中。右操作数可以常量，变量或者其他复杂表达式

```c
i = 5;
j = i;
k = 10 * i + j;
```

如果运算符 `=` 的两个操作数的类型不同，那么赋值时会 **将右操作数的值转换为左操作的类型**

```c
int i;
int f;
i = 72.99f;  // i 的值变为 72
j = 136; // j 的值变为 136.0
```

C 语言中，**赋值是运算符** 而不是语句。也就是说，赋值操作产生的结果，与两个数相加产生的结果一样。赋值表达式 `v = e` 的值就是赋值运算之后 `v` 的值。例如，表达式 ` i = 72.99f` 的值是 `72`

> [!tip] 副作用
> 
> 通常，我们是 **不希望运算符改变其操作数的值**。如果存在一类运算符不仅仅是计算出值，还存在一些其他的操作，称它们有 **副作用**
> + 赋值运算符是目前接触的唯一一个有副作用的运算符，因为它改变了左操作数的值
> 

既然 `=` 是运算符，那么它就有优先级和结合性，它的优先级比大多数运算符都低，并且结合性时 _从右到左_ 的

> 表达式 `i = j = k = 0` 等价于 `i = (j = (k = 0))`

> [!warning] 警告
> 
> 由于存在类型转换，**串联赋值** 可能得不到我们期望的结果
> ```c
> int i; 
> float f;
> f = i = 33.3f
> // 等价于 f=(i = 33.3f)
> ```
> 变量 `f` 的值是表达式 `i = 33.3f` 的值，而 `i = 33.3f` 的值为 `33`，所以 `f` 的值为 `33.0` 而不是我们期望的 `33.3`


> [!tip] **左值**
>
赋值运算符的 **左操作数只能是一个表示内存区域的表达式**。可以称其为 **左值**
> 
> + **左值表示对象**，而不是常量和计算的结果
> 

##### 增强赋值运算符

有时候我们需要 **改变变量自己的值**，即，使用变量本身的值计算出新的值并重新赋值给该变量

```c
i = i + 2;
```

C 语言的 _增强赋值运算符_ 可以简化该操作

```c
i += 2; // 等价于 i = i + 2
```

复合赋值运算符与 `=` 运算符具有相同的优先级和结合性。下面两个表达式是等价的

```c
i += j += k;
i += (j += k); 
```

> [!tip] 
> 
> 算数运算符和位运算符都有其对应的增强赋值运算符
> 

#### 自增自减运算符

对变量进行 **自增(`+1`)** 和 **自减(`-1`)** 操作是非常普遍的。虽然我们可以使用赋值运算符完成，但是为了使语句简单，C语言提供了 `++` 和 `--` 运算符

自增和自减运算符的使用是很复杂的。因为这两个运算符可作为 **前缀** 运算符和 **后缀** 运算符；`++` 和 `--` 也有副作用：它们会改变操作数的值。

当 `++` 和 `--` 做为前缀运算符时，表达式 `++i` 和 `--i` 的值分别为 `i + 1` 和 `i - 1`，**副作用** 就是使得变量 `i` 的值发生改变。它们的优先级与一元算术运算符 `+, -` 的优先级相同，并且是右结合的

```c
#include <stdio.h>

int main() {
	int i = 1;
	printf("++i is %d\n", ++i);  // 2
	printf("i is %d\n", i); // 2
	return 0;
}
```

当 `++` 和 `--` 作为后缀运算符是，表达式 `i++` 和 `i--` 的值都是 `i`，**副作用** 使得变量 `i` 的值发生改变。它们的优先级比一元算术运算符 `+, -` 高，且是左结合的

```c
#include <stdio.h>

int main() {
	int i = 1;
	printf("i++ is %d\n", i++); // 1
	printf("i is %d\n", i); // 2
	return 0;
}
```

#### 关系运算符

C 语言中关系运算符由 $4$ 个

| 运算符  | 描述    |
| :--- | :---- |
| `>`  | 大于    |
| `<`  | 小于    |
| `>=` | 大于或等于 |
| `<=` | 小于或等于 |

**关系运算符的优先级相同，且低于算术运算符**

```c
i + j < k - 1; 
// 等价于下列表达式
(i + j) < (k - 1);
```

关系运算符都是 **左结合的**。表达式 `i < j < k` 在 C 语言中是合法的，但是并不是我们期望的结果。该表达式等价于 `(i < j) < k`。表达式首先检测 `(i < j)` 的值，然后使用结果 `0` 或 `1` 与 `k` 进行比较

#### 判等运算符

C 语言中有 $2$ 个判等运算符

| 运算符  | 描述  |
| ---- | --- |
| `==` | 等于  |
| `!=` | 不等于 |
和关系运算符一样，判等运算符也是 **左结合的**，并且产生 `0`（假）或 `1`（真）作为结果。

**判等运算符的优先级低于关系运算符**

```c
i < j == j < k;
// 等价于 
(i < k) == (j < k);
```

#### 逻辑运算符

C 语言可以利用逻辑运算符进行逻辑运算。下表按优先级从高到低进行排列

| 运算符           | 含义        |
| ------------- | --------- |
| `!`           | 逻辑非 `not` |
| `&&`          | 逻辑与 `and` |
| &#124; &#124; | 逻辑或 `or`  |

逻辑非(`!`) 的优先级与一元算术运算符 `-, +` 相同，结合性是**右结合的**

逻辑与(`&&`) 和 逻辑或(`||`) 的优先级都低于判断运算符，结合性是 **左结合的**

逻辑运算符所产生的结果是 `0`(假) 或 `1`(真)。它将 **任何非零** 操作数当作 **真值** 处理，任何 **零值** 操作数当作 **假值** 处理

> [!tip] 逻辑与(`&&`) 和 逻辑或(`||`) 是 **短路的** 
>  
>  由 `&&` 和 `||` 连接的表达式按 **从左到右的顺序进行求值**，一旦知道表达式的值为真或假后立即停止计算
>
>  逻辑与(`&&`) 连接的表达式 **从左到右的顺序进行逻辑值检测**，一旦检查到 `false` 则立即停止计算，并返回 `false`。只有当所有表达式均为 `true` 时，整个表达式的值才为 `true`。逻辑与(`&&`) 也称寻 `false` 运算符：遇见 `false` 立即停止后续表达式的计算
>   
>  逻辑或(`||`) 连接的表达式 从左到右的依次进行逻辑检测，一旦检查到 `true` 则立即停止计算，并返回 `true`。只有当所有表达式均为 `fasle` 时，整个表达式才为 `false`。逻辑或(`||`) 也称寻 `true` 运算符：遇见 `true` 立即停止后续表达式的计算
>  

#### 位运算符

C 语言提供了 $6$ 个位操作符。这些运算符 **只能用于整数类型**

| 运算符    | 含义         |
| ------ | ---------- |
| `<<`   | 左移         |
| `>>`   | 右移         |
|        |            |
| $\sim$ | 按位取反 `NOT` |
| `&`    | 按位与 `AND`  |
| `^`    | 按位异或 `XOR` |
| &#124  | 按位或 `OR`   |

这些运算符只能用于有符号或无符号的 `char, short int, int, long int, long long int` 类型

##### 移位运算符

移位运算在 [[计算机组成：数据运算#移位运算]]  中有详细介绍。这里，我们只介绍 C 语言中处理细节

> [!tip] 左移
>  
> `i << j`：将 `i` 位模式左移 $j$ 位。若没有发生溢出，则结果等价于 $i \times 2 ^ j$
> 
> `i << j`  将 `i` 的位模式的每一位都向左移动 $j$ 位。最右位丢失，最左位填 $0$
> 
> 无论是逻辑左移，还算数左移，对于无符号数和有符号数的运算结果都是相同的
> 
> 

> [!tip] 右移
> 
> `>>` 运算符执行 _逻辑移位_ 还是 _算术移位_ 由实现定义
> 
> **对于无符号数，逻辑右移和算数右移相同**。对于有符号数，逻辑右移和逻辑左移的结果就不相同了
> 
> 因此，表达式 `i >> j` 的行为由实现定义。为了提高程序的可移植性，**尽量在无符号数上执行右移运算**
> 
> 如果 `>>` 执行算数右移，则不发生溢出的情形下，表达式的值 `i >> j` 等价于 $\lfloor i \div 2^j\rfloor$ 
> 

##### 按位逻辑运算符

在 [[计算机组成：数据运算#逻辑运算]] 中的详细介绍了位逻辑运算符。C 语言的位逻辑运算是 _位模式层次_ 上的逻辑运算

> [!tip] 
> 
> `~i` 将 `i` 的位模式中每一位 _取反_：`1->0` `0 -> 1`
> 
> `i & j` 将 `i` 的位模式与 `j` 的位模式对齐之后，每一位同时进行 _与_ 运算: `1 & 1 = 1` `1 & 0 = 0` `0 & 1 = 0` `0 & 0 = 0`
> 
> `i | j` 将 `i` 的位模式与 `j` 的位模式对齐之后，每一位同时进行 _或_ 运算：`1 | 1 = 1` `1 | 0 = 1` `0 | 1 = 1` `0 | 0 = 0`
> 
> `i ^ j` 将 `i` 的位模式与 `j` 的位模式对齐之后，每一位同时进行 _异或_ 运算：`1 ^ 1 = 0` `1 ^ 0 = 1` `0 ^ 1 = 1` `0 ^ 0 = 0`
> 

##### 位操作

**位设置**：假设我们需要设置 `n` 的第 `j` 位为 $1$。可以使用 **使用移位运算符来构造掩码**

```c
n |= 1 << j;  /* sets bit j */
```

**位清除**：假设我们需要设置 `n` 的第 `j` 位为 $0$。可以使用 **使用移位运算符来构造掩码**

```c
n &= ~(1 << j); /* clears bit j */
```


**为了使针对位的操作更容易，经常会给位命名**。定义一个于相关位的位置对应的 **掩码** 集合。例如

```c
#define KEYWORD 01
#define EXTERNAL 02
#define STATIC 04
```

```c
enum {KEYWORD = 01, EXTERNAL = 02, STATIC = 04};
//            0b001            0b010       0b100
// 这些数字必须是 2 的幂。可以使用位运算符进行简单的位操作
```

下面的语句将 `flags` 中的 `EXTERNAL` 和 `STATIC` 位置置为 $1$

```c
flags |= EXTERNAL | STATIC
```

下面的语句将 `flags` 中的 `EXTERNAL` 和 `STATIC` 位置置为 $0$

```c
flags &= ~(EXTERNAL | STATIC);
```


**修改位域**：需要 使用按位与（用来清除位域），接着使用按位或（用来将新的位存入位域）

```c
// 修改位域 先位清除 然后 位设置
// 将 101 存储如 4 - 6 位
n = n & ~0x0070;  // 位清除
n = n | 0x0050;   // 位设置

n = n & ~0x0070 | 0x0050;
```

**获取位域**：先将需要获取的位域移动到最右边，然后使用按位与获取值

```c
n = (n >> 4) & 0x0007;  // 获取 4 - 6 位
```

---

如何判断一个整数是否为 $n = 2^k, k=0,1,2,...$ 。因为 $2^k$ 的位模式只有第 $k$ 位为 `1`，其余位全为 `0`，因此 `2 ^ k - 1` 的位模式的第 $k$ 位为 `0`，低于 $k$ 的位均为 `1`

> [!tip] 假设 $n = 2 ^ 4$
> 
> $2^4$ 的位模式为 `10000`，则 $2^4 - 1$ 的位模式为 `01111` 
> 

```c
bool isPowerOf2(const int number) {  
    return !(number & (number - 1));  
}
```

----

给定一个正整数，找出位模式中最低的值为 $1$ 的位(`lowBit`) 的权重。

> [!tip]
> 
> 要计算位模式中最低值为 $1$ 的位权重，只需要提取出 最低值为 $1$ 及其后面的位即可
> 
> 
>

```c
unsigned int lowBitWeight(const unsigned int number) {    
    return ((number ^ (number - 1)) + 1) >> 1;
}
```

> [!tip] 
> 
> 给定一个正整数 $n$，根据 **补码** 计算规则， $-n$ 的二进制与 $n$ 的二进制的最低值为 $1$ 的位及其后面的位相同，其余位完全不同
> 
> 例如，`10` 的二进制表示为 `0000 1010`，`-10` 的二进制补码表示为 `1111 0110`。显然，最低值为 $1$ 及其后续为相同
> 

```c
int lowBitWeight(const int number) {  
    return number & (-number);  
}
```

----

给定一个整数数组，其中有一个数只有一个，其余数都是成对的。找出这个单独的整数

> [!tip] 使用异或运算的下面两条性质
> 
> + `0 ^ a = a`
> + `a ^ a = 0`
>  

```c
int findSingleNumber(const int* nums, int numsSize) {  
    int result = 0;  
    for (int i = 0; i < numsSize; i++) {  
        result ^= nums[i];  
    }  
    return result;  
}
```

## 语句

### 表达式语句

**任何表达式都可以用作语句**。换句话说，不论表达式是什么类型，计算什么结果，我们都可以 _通过在表达式后面 **添加分号** 将其转换成语句_

### 选择语句

#### if 语句

`if` 语句允许程序测试表达式的值并从两个分支中选择一种。完整的 `if` 语句如下

```c
if (表达式) 
	语句
else
	语句
```

注意，表达式两边的圆括号是必不可少的，它是 `if` 语句的组成部分。**语句只是一条语句**

```c
if (line_num == MAX_LINE)  // 首先检查表达式 line_num == MAX_LINE
	line_num = 0;          // 如果为真(1)，执行该语句
else
	line_num++;            // 否则(0)，执行该语句
```

**`else` 部分是可选的**

```c
if (line_num == MAX_LINE)
	line_num = 0;
```

如果要检测变量是否落入某个数值范围，例如，判断 $0 \le i < n$ 是否成立，可以如下书写

```c
if( 0 <= i && i < n)...
```

为了判定相反的情况（$i$ 在此数值范围之外），可以写成

```c
if(i < 0 || i >= n)...
```

##### 复合语句


如果想用 `if` 语句处理两条或更多语句，可以使用 **复合语句**。复合语句由 **一对花括号**，及 ==花括号内声明和语句组成==，也称为 **程序块**

> [!tip] 
> 程序块内声明的变量，只能在程序块内使用

下面就是一个复合语句的示例

```c
{
	line_num = 0;
	page_num++;
}
```

> [!tip]
> 
>  为了表示清楚，通常将一条复合语句放在多行内，每行有一条语句
>  

在 `if` 语句内部使用复合语句的形式

```c
if (line_num == MAX_LINE)
{
	line_num = 0;
	page_num++;
}
else
	line_num++;
```

##### 嵌套的 if

C 语言对可以出现在 `if` 语句内部的语句类型没有限制。事实上，在 `if` 语句内部嵌套其他 `if` 语句是非常普遍的

如下例程，用于选择三个数中的最大值

```c
#include <stdio.h>

int main() {
	int a = 10, b = 20, c = 25;
	int max = 0;
	if(a > b)
		if(a > c)
			max = a;
		else
			max = c;
	else
		if(b > c)
			max = b;
		else
			max = c;
	printf("max(%d, %d, %d) is %d", a, b, c, max);
	return 0;
}
```

上述示例程序，我们将属于 `if` 的 `else` 进行了对其，但是依旧会造成阅读上的障碍。使用 `{}` 可以极大的降低阅读难度

```c
#include <stdio.h>

int main() {
	int a = 10, b = 20, c = 25;
	int max = 0;
	if(a > b)
	{
		if(a > c)
			max = a;
		else
			max = c;
	}
	else
	{
		if(b > c)
			max = b;
		else
			max = c;
	}
	printf("max(%d, %d, %d) is %d", a, b, c, max);
	return 0;
}
```

> [!tip] 
> 
> 语句嵌套的情况下，最好使用 `{}` 包围属于一组的所有语句
> 

如下程序片段，用于判断一个数 `n` 是小于 `0`、等于 `0` 、还是大于 `0`

```c
if(n < 0) 
	printf("n is less than 0\n");
else
	if(n == 0)
		printf("n is equal to 0\n");
	else
		printf("n is greater than 0\n");
```

第二个 `if` 语句被嵌套在了第一个 `if` 语句的 `else` 内部。我们对其重新排列，就得到了

```c
if(n < 0) 
	printf("n is less than 0\n");
else if(n == 0)
	printf("n is equal to 0\n");
else
	printf("n is greater than 0\n");
```

这是一种特殊书写形式。由于 `if` 语句可以嵌套任意层。因此，**级联式 `if` 语句** 格式如下

```c
if(表达式)
	语句
else if (表达式)
	语句
...
else if (表达式)
	语句
else
	语句
```

##### 悬空 `else` 

在 `if` 语句进行嵌套的时候，会出现悬空 `else` 问题。如下程序片段

```c
if(y != 0) 
	if(x != 0)
		result = x / y;
else
	printf("Error: y is equal to 0!\n");
```

这个缩进暗示 `else` 属于第一个 `if` 语句。然而，C 语言遵循的规则是 `else` 子句属于离他最近的且还未和其他 `else` 语句匹配的 `if` 语句。因此，该程序片段出现重大错误。

为了让上述片段的 `else` 子句匹配到第一个 `if` 语句，可以把内层的 `if` 语句用花括号包裹起来 

```c
if(y != 0) 
{
	if(x != 0)
		result = x / y;
}
else
	printf("Error: y is equal to 0!\n");
```

##### 条件运算符

对于简单的选择值的 `if` 语句，例如

```c
max = 0; 
if (a > b)
	max = a;
else
	max = b;
```

C 语言提供了一个特殊的运算符，这种运算符允许表达式依据条件值产生两个值中的一个。这种运算符称为 **条件运算符**，它由 `?` 和 `:` 组成。上述代码片段等价于

```c
max = a > b ? a : b;
```

条件运算符的完整语法为

```c
expr1 ? expr2 : expr3;
```

首先计算 `expr1` 的值；如果 `expr1` 的值为 `true`，则计算 `expr2` 的值并把 `expr2` 的值当作整个表达式的值；如果 `expr1` 的值为 `fase`，则计算 `expr3` 的值并把 `expr3` 的值当作整个表达式的值

#### switch 语句

在日常编程中，常常需要 **把表达式和一系列值进行比较**，从中找出当前匹配的值。级联式 `if` 语句可以达到这个目的。但是，比较的值太多时，会对程序的可读性产生影响，更严重的情况会影响到程序的性能。

C 语言提供了 `switch` 语句作为这类级联式 `if` 语句的替代。它更容易阅读，且执行效率更高

```c
switch(控制表达式) { // 控制表达式的值必须是整数类型
	case 常量表达式: 语句序列
	....
	case 常量表达式: 语句序列
	default: 语句
}
```

> [!important] 
> 
> **控制表达式的值必须是整数类型**
> 
> 每一个 `case` 都由一个 **常量表达式** 标记，这个常量表达式的值必须是 _整数类型_。当 `case` 的标记与 控制表达式的值匹配时，则从该 `case` 开始执行
> 

> [!attention] 
> 
> **每个 `case` 的标记必须互不相同**。如果没有一个 `case` 能匹配控制表达式，则执行标记为 `default` 的分支
> 
> **`default` 是可选的**。如果没有 `default` 也没有其它 `case` 与控制表达式的值匹配，则该 `switch` 语句不执行任何动作
> 
> `case` 和 `default` 的次序是任意的，通常 `default` 放在最后
> 

> [!attention] 
> 
> 每个`case` 标记的后边可以跟任意数量的语句，并且不需要用花括号把这些语句括起来
> 
> 通常，**最后条语句是 `break` 语句**，执行 `break` 语句会导致程序跳出 `switch` 语句，继续执行 `switch` 后面的语句
> 
> 如果没有 `break` 语句，当其中一个 `case`  被选中后，所有 `case` 中的语句均会被执行

下面的代码，当 `grade = 3` 时，那么将从 `case 3` 开始，执行所有的语句，直到遇到 `break`

```c
#include <stdio.h>

int main() {
	int grade = 3;
	switch (grade)  { 
		case 4:   printf("Excellent"); 
		case 3:   printf("Good"); 
		case 2:   printf("Average"); 
		case 1:   printf("Poor"); 
		case 0:   printf("Fai1ing"); 
		default:  printf("Illegal grade"); 
	}
	return 0;
}
```

为了修复这个 `bug`，需要在每个 `case` 后的语句序列的最后添加 `break` 语句

```c
#include <stdio.h>

int main() {
	int grade = 3;
	switch (grade)  { 
		case 4:   printf("Excellent"); break; 
		case 3:   printf("Good"); break;
		case 2:   printf("Average"); break;
		case 1:   printf("Poor"); break;
		case 0:   printf("Fai1ing"); break;
		default:  printf("Illegal grade"); break;
	}
	return 0;
}
```

显示法定格式日期

```c
/* switch 例程：显示法定格式日期 

用户以月/日/年的格式输入日期，然后计算机显示出“法定”格式的日期

假设合同日期需要如下格式显示
Dated this ___ day of ___, 20___.

*/

#include <stdio.h>

int main() {
    int month, day, year;
    printf("Enter date (mm/dd/yy): ");
    scanf("%d/%d/%d", &month, &day, &year);
    printf("Dated this %d", day);
    switch (day) {
        case 1: case 21: case 31:
            printf("st"); break;
        case 2: case 22:
            printf("nd"); break;
        case 3: case 23:
            printf("rd"); break;
        default: printf("th"); break;
    }
    printf(" day of ");
    
    switch(month) {
        case 1: printf("January"); break;
        case 2: printf("February"); break;
        case 3: printf("March"); break;
        case 4: printf("April"); break;
        case 5: printf("May"); break;
        case 6: printf("June"); break;
        case 7: printf("July"); break;
        case 8: printf("August"); break;
        case 9: printf("September"); break;
        case 10: printf("October"); break;
        case 11: printf("November"); break;
        case 12: printf("December"); break;    
    }
    printf(", 20%.2d.\n", year);
    return 0;
}
```

### 循环语句

#### while 语句

在 `while` 循环语句中

```c
while (控制表达式)
	语句
```

执行 `while` 语句时，首先计算控制表达式的值。如果值不为零（即真值），那么执行循环体，接着再次判定表达式。**这个过程（先判定控制表达式，再执行循环体）持续进行，直到控制表达式的值变为零才停止**

> [!attention] 
> 
> 注意，这里语句必须是一条语句，当然可以使用复合语句
> 

例程，显示 $0 \sim 10$ 的平方表

```c
#include <stdio.h>

int main() {
	int i = 0;
	while (i <= 10) {
		printf("%d squared is %d\n", i, i * i);
		i++;
	}
	return 0;
}
```

例程，求 $1 + 2 + \cdots + 100$ 的值

```c
#include <stdio.h>

int main() {
	int i = 1;
	int sum = 0;
	while (i <= 100) {
		sum += i++;
	}
	printf("1 + 2 + ... + 100 is %d\n", sum);
	return 0;
}
```

#### do-while 语句

`do-while` 循环本质上就是 `while` 循环，只不过其控制表达式是在每次执行完循环体之后进行判定的

```c
do 语句 while(控制表达式);
```

和处理 `while` 循环一样，`do-while` **循环的循环体必须是一条语句**，当然复合语句可以使用，并且 **控制表达式外的圆括号不能省略**。注意，最后有个分号表示 `d-while` 循环语句结束

**执行 `do-while` 语句时，先执行循环体，再计算控制表达式的值**。如果控制表达式的值是非零的，那么再次执行循环体，然后再次计算控制表达式的值。在循环体执行后，若控制表达式的值变为 `0`，则终止 `do-while` 语句的执行

例程，计算整数 $n$ 的位数

```c
#include <stdio.h>

int main() {
	int digits = 0, n = 999;
	do {
		n /= 10;
		digits++;
	} while (n > 0);
	printf("Number has %d digit(s).\n", digits);
	return 0;
}
```

这里使用 `do-while` 语句在于统计数字的位数，必须要首先处理一次该数字。如下使用 `while` 语句则可能得到错误的结果

```c
#include <stdio.h>

int main() {
	int digits = 0, n = 0;
	while (n > 0) {
		n /= 10;
		digits++;
	} 
	printf("Number has %d digit(s).\n", digits);
	return 0;
}
```

这里输出数字 `0` 有 `0` 个数字，这是错误的

#### for 语句

`for` 循环语句是 C 语言中功能最强大也是最复杂的循环语句。`for` 语句的格式如下

```c
for (表达式1; 表达式2; 表达式3)
	语句
```

**表达式 1** 是循环开始执行前的 _初始化步骤_，**只执行一次**；也称为初 _始化表达式_。**表达式 2** 用来 _控制循环的终止_（在执行循环体之前，只要 **表达式 2** 的值不为零，循环就会继续执行；否则退出循环）。**表达式 3** 是每次循环中最后被执行的一个操作

它等价于下列 `while` 循环

```c
表达式1;
while (表达式2) {
	语句
	表达式3;
}
```

下面的程序片段是 `for` 语句的一个例子，用于跟踪变量的变化

```c
for(i = 10; i > 0; i--)
	printf("T minus %d and counting\n", i);
```

上述 `for` 循环替换为的 `while` 循环如下

```c
i = 10;  // 表达式1
while (i > 0)  // 表达式2
{ 
	printf("T minus %d and counting\n", i); // 语句
	i--;  // 表达式3
}
```

`for` 循环中 **表达式1** 和 **表达式3** 都是 **以语句的方式执行的**，所以它们的值互不相关，它们有用仅仅是因为有副作用

C99 标准中，**表达式 1** 可以被替换为一个声明语句

```c
for(int i = 0; i < n; i++)
	...
```

##### 省略表达式

`for` 循环用三个表达式控制循环，但是有一些 `for` 循环可能不需要这么多，因此 C 语言 **允许省略任意或全部的表达式**

如果 **省略表达式 1**，那么在执行 `for` 循环前没有初始化的操作

```c
i = 10;
for(; i > 0; i--)
	printf("T minus %d and counting\n", i);
```

> [!tip] 省略表达式1
> 
> + 变量 `i` 的初始化被转移到了 `for` 循环开始之前进行
> 
> + **保留 *表达式 $1$* 和 *表达式 $2$* 之间的分号**

如果 **省略表达式 3**，循环体中需要确保表达式 2 的结果会变为假

```c

for(i = 10; i > 0; )
	printf("T minus %d and counting\n", i--);
```

> [!tip] 省略表达式3后，要确保表达式2的结果变为假
> 
> 为了补偿省略 表达式3 产生的后果，我们使变量 `i` 在循环体中进行自减
> 

如果 **省略表达式2**，那么默认为 `1`，`for` 循环将永不终止，除非使用其他方法。因此，`for` 循环的无限循环形式为

```c
for(;;)...
```

##### 逗号运算符

有时候需要在 `for` 循环中 **控制多个变量的变化**。如下程序片段

```c
for(sum = 0, i = 1; i <= N; sum += i, i++);
```

表达式 `sum = 0, i = 1` 和 表达式 `sum += i, i++` 属于 **逗号表达式**

逗号表达式是使用逗号运算符(`,` )连起来的多个表达式。它会从左到右依次计算表达式的值，逗号表达式的值就是最后一个表达式的值。

例程，显示 $0 \sim 10$ 的平方数

```c
#include <stdio.h>

int main() {
	for(int i = 0; i <= 10; i++) {
		printf("%10d%10d\n", i, i * i);
	}
	return 0;
}
```

乘法在计算机中是一个比较费时的操作，通常可以使用加法进行替代。为了计算第 $n$ 个数的平方，我们需要对 $n^2$ 进行一些变形操作

$$
\begin{aligned}
n^{2}= (n-1)^{2}+(2n - 1)
\end{aligned}
$$

因此，我们可以使用上一个数 $n-1$ 的平方，然后再加上 $2n-1$ 即可。其中 $2n-1$ 是首项为 $1$ 的奇数序列的通项公式

```c
#include <stdio.h>

int main() {
	for(int i = 0, odd = 1, square = 0; 
		i <= 10; 
		square += odd, odd += 2, i++) 
	{
		printf("%10d%10d\n", i, square);
	}
	return 0;
}
```

### 跳转语句

#### break 语句

我们其实在 `switch` 语句中已经接触过 `break` 语句了，它的作用就是将程序的 **控制** 从 `switch` 语句中转移出来。当然，`break` 也可以用于 `while, do-while, for` 循环

例程，找出 $2 \sim 100$ 之间的所有素数

```c
#include <stdio.h>

int main() {
	int d;
	for(int n = 2; n <= 100; n++) {
		for(d = 2; d < n; d++) {
			if(n % d ==0)
				break;
		}
		if(d < n)
			printf("%d is divisible by %d\n", n, d);
		else
			printf("%d is prime number\n", n);
	}
	return 0;
}
```

> [!attention] 注意 
> 
> 当循环出现嵌套时，`break` 只能将控制转移到出现 `break` 语句的上一层循环
> 

当循环中出现 `switch` 语句且 `break` 在 `switch` 语句中时，`break` 只会把控制从 `switch` 转移到循环中，而不会转移到循环外。下面的程序片段

```c
while(...){
	...
	switch(...){
		...
		break;
		...
	}  
	// break 将控制转移到此处
	...
}
```

#### continue 语句

`continue` 语句与 `break` 类似，只是它 **不会将控制转移到循环之外**，而是将控制转移到下一次循环开始的测试表达式

在 `while`, `do-while` 语句中，`continue` 语句将控制转移到 **控制表达式**

在 `for` 语句中，`continue` 语句将控制转移到 **表达式2**

#### goto 语句

`break` 和 `continue` 把控制转移到程序中的另一个位置，不过这个转移是受到限制的。
+ `break` 将控制转移到循环外
+ `continue` 将控制转移到循环的测试表达式

C 语言提供另一种控制转移语句 `goto`，它是无条件控制转移语句。可以在 **函数内部** 跳转到任何带有标签的语句处

> [!tip] goto 的使用场景
> 
> + 跳出深层嵌套
> + 进行错误处理
> 

在 C99 标准中对它新增了一个限制，不能越过 [[C 语言：数组#变长数组]]
