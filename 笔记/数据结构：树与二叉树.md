# 树与二叉树

对于大量的输入数据，链表的线性访问效率太低了，不宜使用。下面我们将学习的数据结构是 **树**，它的大部分操作的平均运行时间为 $O(\log N)$

## 树

**树** 最常见的定义方式采用 **递归** 定义：一棵树就是一些节点的 **集合**。
+ 集合可以是空集，称树为 **空树**
+ 集合非空，则一棵树由称作 **根(root)** 的节点，以及 $0$ 个或多个非空子树组成。这些子树的根被来自 **root** 的有向边连接

子树的根称为 **root** 的 **儿子(_子节点_)**，**root** 称为子树的 **父亲(_父节点_)**

> [!tip]
> 
> 一棵树是由 $N$ 各节点和 $N-1$ 条边的集合，其中一个节点叫作根
> 
> 存在 $N-1$ 条边，这是因为每条边都将某个节点连接到它的父节点，只有 **root** 节点没有父节点
> 

下图就是一个典型的树

![Pasted image 20241001193706|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755703775201-47b6ec12ad6545d2bc52d61f698bc844.png)

节点 A 是 **root 节点**。节点 F 的父节点是 A 并且有子节点 K L M。**每个结点 _至少有零个子节点_**，没有子节点的结点称为 **树叶(_叶子节点_)**。

具有相同父节点的节点称为 **_兄弟节点_**。从节点 $n_1$ 到 $n_k$ 的 **_路径_** 定义为节点序列: $n_1, n_2, \cdots, n_k$，其中 $n_i$ 是 $n_{i+1}$ 的父节点。**_路径长_** 为 _该路径上边的条数_，即 $k-1$

节点 $n_i$ 的 **_深度_** 为从 _root节点 到 $n_i$ 的唯一路径长_。节点 $n_i$ 的 **_高度_** 是 _从 $n_i$ 到叶子节点的最长路径长_

### 树的实现

实现树的一种方法可以在每个节点中存储它子树的指针。然而，节点的子树数量是 _不固定_ 的且事先 _不可知_ 的，可能会造成空间的浪费。解决方法：**将每个结点的所有儿子都放在树结点链表中**。也就是说，按照如下方式存储

![Pasted image 20241001193948|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755703775201-33019a457cd1454092e3b87c55cdbd65.png)

> [!tip]
> + `firstChild`：表示第一个孩子
> + `nextSibling`：表示下一个兄弟
> 

上图的树可以如下表示

![Pasted image 20241001194027|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755703775201-446d4c0018e3401aba5e7363dec01705.png)

## 二叉树

**二叉树** 是一棵树，其中 **每个节点的 _子节点至多两个_**。下图是一个典型的二叉树

![Pasted image 20241001194327|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755703775201-25f5be1385d24622aed3aed6f169f691.png)

> [!tip] 
> 二叉树要求 **节点的左右子树是有顺序的**，次序不能任意颠倒。树中的某节点只有一棵子树，也要区分子树是左子树还是右子树
> 

### 二叉树分类

#### 满二叉树与完全二叉树

所谓 **满二叉树** 是指所有 **_叶子节点都在同一层_**，即 **所有叶子节点的深度相同**
+ 叶子节点只出现在最下面一层
+ 非叶子节点一定有两棵子树

![Pasted image 20241001194412|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755703775202-ad821a26522e4764b434aeca7511d214.png)

所谓 **完全二叉树** 是指所有 **_叶子节点只能出现在最后两层_**，并且 **如果节点 _只有一棵子树_，那么这棵子树 _一定是左子树_

![Pasted image 20241001194428|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755703775202-38c5035b098047859ba5bcd2a41ba187.png)

### 二叉树的存储

#### 顺序存储

二叉树的顺序存储就是将二叉树的节点按 **从上到下**，**从左到右**，依次存放在一片连续的存储空间中（即：使用 **顺序表存储**），如果一个 _内部节点_ 的子树少于 $2$，则空缺的子树在顺序表需要存储一个哑节点。

下图展示了一般二叉树的顺序存储

![Pasted image 20241001194503|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755703775202-2e57b52845ad4aa28498fa6fe641c8cd.png)

这样每个节点都会有一个索引，这个索引将作为节点编号使用。显然，**一般二叉树采用顺序存储会造成严重的空间浪费**

> [!tip] 二叉树顺序存储通常用于存储 **完全二叉树**
> 

![Pasted image 20241001194533|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755703775202-6fb5f804be044d8f843bf7e61d1a58b6.png)

通过编号，我们就可以很容易找到节点的父节点和子节点。

> [!tip] 完全二叉树顺序存储的重要结论。这里将是实现 **[[数据结构：优先队列#二叉堆]]** 的基础
> 如果一棵完全二叉树有 $n$ 个节点。每个节点按从上到下，从左到右进行编号。任意一个节点的编号为 $i, 1 \le i]\le n$，则
> + 如果 $i=1$，则节点 $i$ 是 **root节点**
> + 如果 $i \gt 1$，则节点 $i$ 的父节点是节点 $\lfloor \frac{i}{2} \rfloor$
> + 如果 $2i \gt n$，则节点 $i$ 无左孩子；否则其左孩子是节点 $2i$
> + 如果 $2i+1 \gt n$，则节点 $i$ 无右孩子；否则其右孩子是节点 $2i+1$
> 

#### 链式存储

一棵二叉树最多有两个儿子，所以我们可以使用指针直接指向它们。也就是说，每个树节点的类似于双链表

![Pasted image 20241001194636|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755703775203-e8096c324eca47739016b970c0a675f7.png)

> [!tip]
> + `left` 指向该节点的左子树
> + `right` 只想该节点的右子树

### 遍历

二叉树的遍历就是从根出发，按照某种 **次序** 依次访问二叉树中的所有节点，使得每个节点被访问且只访问一次

> [!tip] 二叉树的遍历有两个方面内容：**访问** 和 **次序**
> + 访问：根据需求确定要对节点中的数据做什么操作。例如，计算，输出
> + 次序：访问根节点、左子节点、有子节点的顺序

二叉树的遍历方法有很多种，这里介绍主要使用的 $3$ 种，它们 **根据 root 节点的访问次序** 进行划分的。通过遍历下图所示的二叉树，介绍这三种算法

![Pasted image 20241001195641|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755703775203-f2dafcb0bb8c4e1baa9a21f07f4683e3.png)

#### 前序变量

二叉树的前序遍历按照如下顺序进行
+ 如果二叉树为空，则直接返回
+ 否则，先访问 root节点，再访问左子树，最后访问右子树

> [!tip] 前序遍历的节点访问顺序：**root ==> 左子树 ==> 右子树**

下图虚线箭头显示该二叉树的前序遍历：`ABDGHICEJF`

![Pasted image 20241001195706|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755703775203-6f99041d695f48f78bfe2ce74ba940ae.png)

#### 中序遍历

二叉树的中序遍历按照如下顺序进行
+ 如果二叉树为空，则直接返回
+ 否则，先访问左子树 ，再访问root节点，最后访问右子树

> [!tip] 中序遍历的节点访问顺序：**左子树 ==> root ==> 右子树**

下图虚线箭头显示该二叉树的前序遍历：`GDIHBAEJCF`

![Pasted image 20241001195758|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755703775203-e6956e79de0d4240936bc0bab18d74bf.png)

#### 后序遍历

二叉树的后序遍历按照如下顺序进行
+ 如果二叉树为空，则直接返回
+ 否则，先访问左子树 ，再访问右子树，最后访问root节点

> [!tip] 中序遍历的节点访问顺序：**左子树 ==> 右子树 ==> root**

下图虚线箭头显示该二叉树的前序遍历：`GIHDBJEFCA`

![Pasted image 20241001195817|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755703775204-3cb767d3fa874faaa020227ed73da8c5.png)

#### 层序遍历

该技术 **使用队列** 数据结构来 **记住探索下一个顶点或节点**，并且将探索通向该顶点的每一条边，这确保了发现从源可到达的每个顶点。下图虚线箭头描述了层序遍历的访问顺序

![Pasted image 20241001195903|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755703775204-9c5f864fbeca48578c612ff923960a19.png)

