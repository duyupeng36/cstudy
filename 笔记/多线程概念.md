# 多线程概念

**线程是 CPU 使用的一个基本单元**；它包括 **线程 ID** **程序计数器(PC)** **寄存器组** 和 **堆栈**

> [!tip] 也就说，同一进程中的多个线程**共享 _代码段_ _数据段_ 和 _其他操作系统资源_**
> 

传统进程只有一个控制线程用于执行任务。现代操作系统支持 **多线程进程**，也就是说，**多线程进程具有多个控制线程**，每个控制线程能同时执行任务。下图说明了 **传统单线程进程** 和 **多线程进程** 的差异

![[Pasted image 20241111001746.png]]

> [!summary] 
> 
> 也就是说，线程是允许应用程序 **并发执行任务** 的机制
> 
> 进程中可以包含多个线程，它们均会 **独立执行**，且 **共享**  虚拟内存中的 **数据段**，**代码段** 和 **堆内存段**。线程都有自己 **独立的栈内存段**。如下图是同时执行 $4$ 个线程的进程
> 
> ![[Pasted image 20241110230539.png]]
> 
> 

现代计算机运行的大多数应用软件都是多线程的。一个应用程序通常作为具有多个控制线程的一个进程来实现

> [!example] 
> 
> 一个字处理器可能有**一个线程用于显示图形**，**另一个线程用于响应用户的键盘输入**，还有 **一个线程在后台进行拼写和语法检查**
>

多线程编程具有如下四大类的优点

> [!tip] 响应性
> 
> 如果一个交互程序采用多线程，那么即使部分阻塞或者执行冗长操作，它仍可以继续执行，从而增加对用户的响应程度。这对于用户界面设计尤其有用
> 
> + 例如，当用户触发一个耗时操作时，如果让耗时操作在一个线程上执行，服务线程已经可以继续为用户提供服务
> 

> [!tip] 资源共享
> 
> 进程间通信需要额外的 IPC 机制。然而，**线程本来就是共享 _堆内存_ 和 _数据段_ 的**，无需提供额外的通信机制
> 

> [!tip] 经济
> 
> 为一个进程分配资源是非常昂贵的。例如，每个进程都需要创建页表，打开文件描述符表等待数据结构
> 
> 由于线程能够共享它们所属进程的资源，所以创建和切换线程更加经济
> 

> [!tip] 可伸缩性
> 
> 对于 **多处理器体系结构**，多线程的优点更大，因为 **线程可在多处理核上并行运行**
> 
> 不管有多少可用 CPU, 单线程进程只能运行在一个 CPU 上
> 

## 多核编程

早期计算机设计为了响应更多的计算性能需求，单处理器系统逐步发展为多处理系统(计算核心放在多个芯片上)。现代 CPU 的设计趋势是 **将多个计算核心放在单个芯片上**。但是，无论是将多个计算核心放在多颗芯片还单颗芯片上，都称为 **多核处理器** 或 **多处理**。多线程可以更轻松的利用 CPU 的多个计算核心

> [!tip] 
> 
> 对于多核 CPU，线程可以更方便的利用 CPU 的多个核心
> 

考虑一个有 $4$ 个线程的应用程序，讨论单核系统和多核系统上线程的执行

> [!tip] 在单核系统上，**CPU 只能同一时间执行单个线程**。因此，**并发** 仅仅意味着 **线程随着时间推移交错执行**
> 
> 如下图，显示 $4$ 个线程在单核系统上的执行顺序
> 
> ![[Pasted image 20241111001916.png]]
> 

> [!tip] 在多核系统上，CPU 可以执行多个线程。因此，**并发** 意味着 **线程能并行执行**
> 
> 如下，显示 $4$ 个线程在双核系统上的执行顺序
> 
> ![[Pasted image 20241111002027.png]]
> 

这里再次接触到 **并发性** 和 **并行性** 两个概念

> [!attention] 并行性：**同时执行多个任务**
> 
> + 如果食堂有 $3$ 个打饭窗口，可以同时执行 $3$ 个相同的任务，服务不同的食客
> 
 
> [!attention] 并发性：允许多个任务可以同时向前推进
> 

在  **多核架构** 出现之前，大多数计算机系统只有单个处理器。CPU 调度器通过 **快速切换系统内的进程**，以便 **允许每个进程取得进展**，从而提供并行假象。这些进程并发运行，而非并行运行

### 并行类型

有两种类型的并行: **数据并行** 和 **任务并行**

> [!tip] 数据并行： 数据分布于多个计算核上，并在每个核上执行相同操作
> 
> 考虑一下对大小为 $n$ 的数组的内容进行求和
> + 对于单核系统，单线程只能从第 $0$ 个元素加到第 $n-1$ 个元素
> + 对于多核系统，假设有 $2$ 个线程，线程 A 从第 $0$ 个元素加到第 $\frac{n}{2}-1$ 个元素；线程 B 从第 $\frac{n}{2}$ 个元素加到第 $n-1$ 个元素
> 

> [!tip] 任务并行：多个任务分布在多个计算核上，每个任务执行独立操作
> 
> 不同线程可以操作相同的数据，或者也可以操作不同的数据
> 

## 线程模型

实现线程包的方法有两种：**在用户空间中** 和 **在内核中**

> [!tip] 在用户空间中实现的线程包称为 **用户线程**
> 

> [!tip] 在内核中实现的线程称为 **内核线程**
> 

### 用户线程

实现线程的第一种方法就 **将线程包放在用户空间中**，内核对线程包一无所知。**内核还是按照传统进程(_单线程进程_)管理方式进行管理**

> [!attention] 优点：**可以在不支持线程的操作系统上实现线程**
> 

如下图所示是用户线程实现的通用结构

![[Pasted image 20241111001259.png]]

> [!important] 运行时系统
> 
> 线程在一个 **运行时系统** 上层运行，该运行时系统是管理线程的 **过程集合**。管理线程最少需要 $4$ 个过程
> 
> + `thread_create()` 创建
> + `thread_exit()` 退出
> + `thread_join()` 等待特定线程退出
> + `thread_yield()` 让出
> 

在用户空间管理线程时，每个进程都需要有其专用的 **线程表**，用于跟踪该进程的线程。线程表与进程表类似，记录线程各种的属性

> [!tip]
> 
> 线程表由运行时系统管理。当一个线程转换到就绪状态或阻塞状态时，该线程表中存放重新启动该线程需要的所有信息
> 

当进程中的某个线程做了一些会引起 **本地阻塞** 的事情，通过下面的步骤完成线程切换

> [!summary] 线程本地阻塞：例如，等待其他线程完成工作
> 
> 第一步：运行时系统检查线程是否应该进入阻塞状态
> 
> 第二步：如果线程必须进入阻塞状态。首先，运行时系统将会 **保存该线程的寄存器** 在线程表中；然后，在线程表中挑选其中一个就绪线程
> 
> 第三步：运行时系统将被选中的线程的寄存器保存值重新装入寄存器。只要栈指针和程序计数器被装入，新线程就可以愉快的执行
> 

用户空间的线程切换非常是非常快的。如果机器存在保存全部寄存器和装入寄存器的指令，那么线程切换可以在几条指令内完成

#### 用户线程的优点

> [!tip] 用户线程的优点：**线程切换非常迅速**
> 
> + 线程调度都是本地过程，启动这些线程比内核调度效率更高
> + 不需陷入内核，也不需要上下文切换，也不需要对高速缓存进行刷新
> 

> [!tip] 用户线程的优点：每个进程都可以定制自己的线程调度算法
> 
> 如果应用程序有垃圾收集线程，那么应用程序不需要担心该线程被不合时宜的切换
> 

> [!tip] 用户线程的优点：较好的扩展性
> 
> 内核线程需要固定的内核数据结构。由于内核空间占据内存容量较小，如果内核线程数量非常大，可能会导致内核空间被占用满
> 
> 相反，用户空间占据内存容量较大，可以容纳更多的线程
> 

#### 用户线程的缺点

由于内核不知道线程的存在，也无法调度线程。用户线程完全由进程运行时系统调度，如果由一个线程调用阻塞系统调用，那么整个线程将陷入阻塞状态

> [!warning] 用户线程的缺点：**阻塞系统调用会导致整个进程阻塞**
> 
> 然而，使用线程的目标就是 **允许每个线程使用阻塞系统调用**，还要避 **免被阻塞的线程影响其他线程**。这两个目标实现起来是非常麻烦的
> + 系统调用全部改为非阻塞的，但是需要修改操作系统，甚至需要修改现有的应用程序
> + 如果系统调用会阻塞，就提前通知。参考 [[IO 多路复用]]。在系统调用周围从事检查的代码称为 **包装器**
> 

> [!warning] 用户线程的缺点：**缺页中断也会导致整个进程阻塞**
> 
> [[内存管理]] 和 [[虚拟内存]] 中介绍过，可执行程序并不是一次性的加载到内存中的。如果某个程序调用或者跳转到一条不在内存中的指令，就会发送缺页
> 
> 缺页处理器程序会从磁盘上取回这个丢失的指令和其附近的指令。在对需要的指令进定位和读入时，相关的进程就会被阻塞
> 
> 如果一个 **线程引起缺页中断**，**内核不知道其他线程的存在**，通过会把 **整个进程阻塞** 直到磁盘 IO 完成为止，尽管其他线程是可运行的
> 

> [!warning] 用户线程的缺点：**只能执行一个线程**，其他线程需要等待执行中的线程让出 CPU
> 
> 在单独的一个进程内部，**没有时钟中断**，也就是不可能时间片轮转的方式调度。除非线程自己进入运行时系统，否则调度程序没有任何机会执行
> 

### 内核线程

用户线程的诸多缺点导致用户线程的使用具有争论。因此，考虑让 **内核支持和管理线程**

![[Pasted image 20241111102024.png]]

此时运行时系统就不需要了，进程也不持有线程表。相反，**在内核中有用来记录系统中所有线程的线程表**。当某个线程希望创建一个新线程或撤销一个已有线程时，它进行一个系统调用，该系统调用通过对线程表的更新完成线程的创建和撤销

> [!tip] 内核线程表保存的信息和运行时系统中的线程表保存的信息是一样的
> 
> 它们两则之间的差异只是 **保存的位置不同**
> 

内核线程表中的信息是传统内核维护单线程进程信息的子集，内核同时维护了进程表，以便于跟踪进程状态

通过内核管理线程，内核知晓线程的存在。**当一个线程阻塞时，内核可以选择其他线程**

> [!tip] 内核选择其他线程
> 
> + 同一个进程的另一个线程
> + 另一个进程的线程
> 

内核创建线程或撤销线程的开销相比于用户线程开销较大。**当线程被撤销时，内核将其标记为不可运行，但是内核数据结构不受影响**。稍后，如果需要创建新的线程，就重新复用被撤销线程的数据结构

内核线程解决了用户线程的大部分缺点，但是内核线程也带来诸多问题

> [!question] 
> 
> + 当一个多线程进程创建子进程时，子进程如何继承父进程中的线程？
>
> + 信号是发送给进程的，当一个信号到达时，应该由哪一个线程处理？
> 
> + 如果由多个线程注册了相同的信号，会发生什么？
> 

### 混合模型

为了将用户级线程的优点和内核级线程的优点结合起来。如下图，考虑将用户级线程与某些或全部内核线程 **多路复用** 起来

![[Pasted image 20241111105201.png]]

采用上述方法，内核只识别内核级线程，并对其进行调度。其中一些内核线程会被多个用户级线程多路复用。进程的运行时系统可以管理这些用户级线程，内核级线程可以轮流使用用户级线程的集合

> [!tip] 多对一模型($M:1$)：多个用户线程映射到一个内核线程
> 
> 线程管理是由用户空间的线程库来完成的，因此效率更高。然而，如果一个线程执行阻塞系统调用，那么整个进程将会阻塞。再者，因为任一时间只有一个线程可以访问内核，所以多个线程不能并行运行在多处理核系统上
> 

> [!tip] 一对一模型($1:1$)：映射每个用户线程映射到一个内核线程
> 
> 该模型在一个线程执行阻塞系统调用时，能够允许另一个线程继续执行，所以它提供了比多对一模型更好的并发功能;它也允许多个线程并行运行在多处理器系统上
> 

> [!tip] 多对多模型($M:N$)：多路复用多个用户级线程到同样数量或更少数量的内核线程
> 
> 

## 线程库

**线程库** 为程序员提供创建和管理线程的 API。线程库可以实现为用户线程或内核线程。目前使用的 $3$ 中主要线程库是: **POSIX Pthreads**，**Windows** 和 **Java** 

> [!tip] POSIX Pthreads：POSIX 标准的扩展，提供用户级或内核级线程的库

> [!tip] Windows：用于 Windows 操作系统的内核级线程库

> [!tip] Java 线程 API：运行线程在 Java 程序中直接创建和管理
> 
> JVM 运行在宿主机上，Java 线程 API 通常采用宿主机的线程库来实现
> 

对于 POSIX 线程和 Windows 线程，**全局声明的任何数据**，可以 **为同一个进程中的所有线程共享**。由于 Java 没有全局数据的概念，所以线程对共享数据的访问必须显示安排。**属于某个函数的本地数据通常位于栈中**。由于每个线程都有自己的栈，每个线程都有自己的本地数据

后续我们将介绍使用 POSIX Pthreads 线程库进行多线程编程
